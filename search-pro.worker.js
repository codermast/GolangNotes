const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":87,\"nextId\":87,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"3\",\"3\":\"3#数组\",\"4\":\"3#声明数组\",\"5\":\"3#初始化数组\",\"6\":\"3#访问数组\",\"7\":\"3#作为参数\",\"8\":\"3#切片\",\"9\":\"3#声明切片\",\"10\":\"3#初始化切片\",\"11\":\"3#访问切片\",\"12\":\"3#作为参数-1\",\"13\":\"3#区别\",\"14\":\"3#数组-arr\",\"15\":\"3#切片-slice\",\"16\":\"3#示例比较\",\"17\":\"3#结论\",\"18\":\"4\",\"19\":\"4#背景\",\"20\":\"4#介绍\",\"21\":\"4#应用\",\"22\":\"4#结论\",\"23\":\"5\",\"24\":\"5#golang环境\",\"25\":\"5#开发工具\",\"26\":\"5#vscode\",\"27\":\"5#goland\",\"28\":\"6\",\"29\":\"6#函数\",\"30\":\"6#_1-函数定义与调用\",\"31\":\"6#_2-参数与返回值\",\"32\":\"6#_3-可变参数函数\",\"33\":\"6#_4-匿名函数\",\"34\":\"6#_5-闭包\",\"35\":\"6#_6-递归函数\",\"36\":\"6#_7-函数作为参数和返回值\",\"37\":\"6#_8-延迟执行-defer\",\"38\":\"6#_9-错误处理\",\"39\":\"6#方法\",\"40\":\"6#访问控制\",\"41\":\"7\",\"42\":\"7#if-语句\",\"43\":\"7#switch-语句\",\"44\":\"7#for-语句\",\"45\":\"7#select-语句\",\"46\":\"8\",\"47\":\"8#声明和初始化\",\"48\":\"8#操作map\",\"49\":\"8#并发安全\",\"50\":\"8#特殊情况nan\",\"51\":\"9\",\"52\":\"9#算术运算符\",\"53\":\"9#关系运算符\",\"54\":\"9#逻辑运算符\",\"55\":\"9#位运算符\",\"56\":\"9#赋值运算符\",\"57\":\"9#其他运算符\",\"58\":\"9#运算符的优先级\",\"59\":\"10\",\"60\":\"10#声明指针\",\"61\":\"10#获取变量地址\",\"62\":\"10#访问指针的值\",\"63\":\"10#作为参数\",\"64\":\"10#指针运算\",\"65\":\"10#空指针\",\"66\":\"10#指针的指针\",\"67\":\"10#指针数组\",\"68\":\"11\",\"69\":\"12\",\"70\":\"12#声明结构体\",\"71\":\"12#创建结构体实例\",\"72\":\"12#访问结构体成员\",\"73\":\"12#结构体作为参数\",\"74\":\"12#结构体标签\",\"75\":\"12#结构体标签解释\",\"76\":\"12#其他常见标签\",\"77\":\"12#空结构体\",\"78\":\"12#结构体的存储\",\"79\":\"13\",\"80\":\"13#数据类型\",\"81\":\"13#基本数据类型\",\"82\":\"13#复合数据类型\",\"83\":\"13#变量\",\"84\":\"13#常量\",\"85\":\"13#iota\",\"86\":\"14\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[2,16],\"3\":[1,5],\"4\":[1,6],\"5\":[1,52],\"6\":[1,25],\"7\":[1,9],\"8\":[1,5],\"9\":[1,3],\"10\":[1,52],\"11\":[1,78],\"12\":[1,76],\"13\":[1,10],\"14\":[1,23],\"15\":[1,26],\"16\":[1,27],\"17\":[1,8],\"18\":[3],\"19\":[1,24],\"20\":[1,32],\"21\":[1,29],\"22\":[1,15],\"23\":[2,7],\"24\":[1,16],\"25\":[1,10],\"26\":[1,13],\"27\":[1,51],\"28\":[2,20],\"29\":[1],\"30\":[2,21],\"31\":[2,34],\"32\":[2,20],\"33\":[2,16],\"34\":[2,30],\"35\":[2,18],\"36\":[2,25],\"37\":[3,15],\"38\":[2,26],\"39\":[1,130],\"40\":[1,54],\"41\":[2],\"42\":[2,17],\"43\":[2,100],\"44\":[2,107],\"45\":[2,113],\"46\":[3,16],\"47\":[1,24],\"48\":[1,91],\"49\":[1,55],\"50\":[1,82],\"51\":[2],\"52\":[1,21],\"53\":[1,22],\"54\":[1,13],\"55\":[1,32],\"56\":[1,23],\"57\":[1,26],\"58\":[1,80],\"59\":[2,20],\"60\":[1,10],\"61\":[1,11],\"62\":[1,11],\"63\":[1,24],\"64\":[1,71],\"65\":[1,14],\"66\":[1,16],\"67\":[1,4],\"68\":[1],\"69\":[2,8],\"70\":[1,25],\"71\":[1,56],\"72\":[1,38],\"73\":[1,38],\"74\":[1,72],\"75\":[1,15],\"76\":[1,40],\"77\":[1,100],\"78\":[1,113],\"79\":[2],\"80\":[1,18],\"81\":[1,29],\"82\":[1,132],\"83\":[1,61],\"84\":[1,27],\"85\":[1,26],\"86\":[1,3]},\"averageFieldLength\":[1.2988505747126438,34.50602197253897],\"storedFields\":{\"0\":{\"h\":\"Golang\"},\"1\":{\"h\":\"语法核心\"},\"2\":{\"h\":\"7. 数组和切片\",\"t\":[\"在 Golang 中提供了数组类型的数据结构，可以用于存储相同类型的数据集合。除此之外，Golang 中还提供了一个切片类型，切片是对数组的抽象。在使用上，两者几乎类似，但实际在功能上差距较大。\",\"数组是固定长度的数据结构，一旦初始化，就不能更改其大小，而切片是不定长的，可以根据数据量来自动扩充。\"]},\"3\":{\"h\":\"数组\",\"t\":[\"数组是一整块连续内存，且存储的数据类型相同，故支持随机访问。可通过下标索引进行操作。\"]},\"4\":{\"h\":\"\",\"t\":[\"数组声明的语法如下所示，在声明阶段就需要指定数组长度和数组的数据类型。\",\"var arrayName [arrayLength]dataType\"]},\"5\":{\"h\":\"\",\"t\":[\"仅声明\",\"在声明数组后，没有指定数组的数据，则默认会将所有的数组置为 dataType 类型的零值。\",\"列表初始化\",\"var arrayName = [arrayLength]dataType{data1, data2, data3 ...}\",\"这里值得注意的是，如果你定义的数组长度大于你给定的数据列表，那么 Golang 就默认将剩余的数据重置为零值。但是数据列表的长度不能超过数组的长度，否则会直接报错。\",\"var arr = [5]int{1, 2, 3} fmt.Println(arr) var arr [3]int = [3]int{1, 2, 3, 4} // 编译错误: 初始化列表中的元素个数超过数组声明的长度 // too many values in array initializer\",\"遍历输出这个数组，结果为 [1, 2, 3, 0, 0]\",\"实际上这里是分两个步骤，首先进行数组定义，然后初始化，故多余的数为零值。\",\"未知数组长度\",\"如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度：\",\"var arr = [...]int{ 1, 2, 3, 4, 5} fmt.Println(len(arr)) // 输出 5\"]},\"6\":{\"h\":\"\",\"t\":[\"数组支持随机访问，可通过索引下标来进行访问\",\"查看数据\",\"var arr = [5]int{ 1, 2, 3 } fmt.Println(arr[0]) // 输出 1 fmt.Println(arr[1]) // 输出 2 fmt.Println(arr[2]) // 输出 3 fmt.Println(arr[3]) // 输出 0 fmt.Println(arr[4]) // 输出 0 // 查询子数组的值 fmt.Println(arr[1:3]) // 输出 [2,3]\",\"如果需要获取数组的子数组，可以使用切片操作符 [:] 来创建一个切片，从而实现类似子数组的效果。但需要注意的是，这并不会创建一个新的数组，而是基于现有数组创建一个切片视图。\",\"修改数据\",\"var arr = [5]int{ 1, 2, 3 } fmt.Println(arr[2]) // 输出 3 arr[2] = 4 fmt.Println(arr[2]) // 输出 4\"]},\"7\":{\"h\":\"\",\"t\":[\"数组作为参数时，传递的是数组值的拷贝，故操作形参数组，不会改变原有的数组值。\",\"数组作为一种数据类型，其本身也可作为数组的数据类型，即二维数组，同理即可支持多维数组。\"]},\"8\":{\"h\":\"切片\",\"t\":[\"切片的应用范围更加广泛，用于存储相同类型，但不知道数据量的数据，而且可能会有频繁的插入和删除操作。\"]},\"9\":{\"h\":\"\",\"t\":[\"var slice []int\"]},\"10\":{\"h\":\"\",\"t\":[\"var slice = []int{ 1, 2, 3 } slice := []int{ 1, 2, 3 } slice := make([]int, 0, 0) slice := new([]int)\",\"这里不难看出，切片和数组的声明和初始化几乎类似，只是切片中没有初始化长度。推荐使用 make 方法来创建切片，make 方法的三个参数依次为：数据类型，长度，容量。\",\"因为使用 var slice []int 这种默认声明方式，并不会开辟内存，实际上此时的 slice 指向的是 nil 空指针，而使用 make 方法进行初始化时，指定了容量，会分配指定大小的内存空间。\",\"切片初始化时的长度和容量\",\"在 make 函数中的数据类型参数不难理解，但是长度和容量这两个有什么区别呢？可以理解为长度是实际的数据长度，即有多少数据，就有多少长度，而容量是最大长度。\",\"但是在前面说过，切片不指定长度，可以自动扩容，那到底是可以自动扩容呢？还是根据这个容量来限制呢？答案是自动扩容的，这里的容量指的是切片初始化时的容量，如果所添加的数据超过该容量，则会自动扩容，默认是扩容为当前容量的两倍。\",\"由于扩容的性能消耗，所以在声明阶段就尽可能的给定一个可能会用到的容量，以避免因为数据的添加而导致的不断扩容。\"]},\"11\":{\"h\":\"\",\"t\":[\"访问\",\"通过索引来访问切片，使用的方法和数组完全相同，具体如下：\",\"slice := []int{1, 2, 3, 4, 5} // 查询索引 2 的元素 fmt.Println(slice[2]) // 输出: 3 // 查询子切片的值 fmt.Println(slice[1:3]) // 输出 [2,3]\",\"修改\",\"修改切片内的数组，可直接使用下标索引进行修改。\",\"slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) // 输出: [1, 2, 3, 4, 5] slice[3] = 10 fmt.Println(slice) // 输出: [1, 2, 3, 10, 5]\",\"在 Go 1.21 中新添加了 clear 方法，可将切片中的所有数据置为零值。\",\"slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) // 输出: [1, 2, 3, 4, 5] clear(slice) fmt.Println(slice) // 输出: [0, 0, 0, 0, 0]\",\"添加\",\"向切片中添加元素需要使用 append 函数，添加数据到切片末尾，如果切片的容量不足，append 会自动扩容。\",\"slice := make([]int,0,0) fmt.Println(slice) // 输出 [] slice = append(slice,1,2,3,4,5) fmt.Println(slice) // 输出 [1,2,3,4,5]\",\"append 函数\",\"append 内置函数将元素附加到切片的末尾。如果有足够的容量，则重新许可目的地以容纳新元素。否则，将分配一个新的底层阵列。append 函数语法如下:\",\"func append(slice []Type, elems ...Type) []Type\",\"append 返回更新的切片。因此，有必要存储append的结果，通常存储在保存 slice 本身的变量中：\",\"slice = append(slice, elem1, elem2) slice = eappend(slice, anotherSlice ...)\",\"作为特殊情况，将字符串添加到 byte slice 是合法的，如下所示：\",\"stice = append([]byte(\\\"hello \\\")，\\\"world\\\" ...)\",\"删除\",\"切片本身并没有提供直接删除元素的接口，需要借助 append 函数来完成\",\"slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) // 输出 [1,2,3,4,5] // 删除后 n 个元素 slice = slice[:len(slice) - n] fmt.Println(slice) // 输出 [1,2,3 ...] // 删除前 n 个元素 slice = slice[n:]; fmt.Println(slice) // 输出 [... 3,4,5] // 从中间指定下标删除 n 个元素 slice = append(slice[:i], slice[i + n:]...) fmt.Println(slice) // 输出 [1,2 ... 4,5] // 删除所有元素 slice = slice[:0] fmt.Println(slice) // 输出 []\"]},\"12\":{\"h\":\"\",\"t\":[\"要了解切片作为参数时，首先需要了解切片的底层结构。\",\"type SliceHeader struct { Data uintptr // 指针：指向底层数组。 Len int // 长度：切片中的元素个数。 Cap int // 容量：从切片的起始位置到底层数组的结尾的元素个数。 }\",\"当将切片作为参数传递给函数时，传递的是这个切片的副本，通过切片的底层结构不难看出，实际上切片不存储数据，存储的是一个指向底层数组的指针，传递给函数的是该指针的副本，但指向的是同一个地址，故对形参修改，也会反应在原切片上。\",\"// 改变 slice 的值 func changeSliceValue(slice []int) { slice[len(slice) / 2] = 10 } dataSlice := []int{1,2,3,4,5} fmt.Println(dataSlice) // 输出 [1,2,3,4,5] // 修改 切片的值 changeSliceValue(dataSlice) fmt.Println(dataSlice) // 输出 [1,2,10,4,5]\",\"但是当增加切片的长度时，此时虽然通过实际的数组指针修改了底层数组，但是由于切片的元素个数和容量是值传递，并不会对原值产生影响，故表现出来的是没有做任何修改。\",\"// 改变 slice 的长度 func changeSliceLength(slice []int) { slice = append(slice,6,7,8,9) } dataSlice := []int{1,2,3,4,5} fmt.Println(dataSlice) // 输出 [1,2,3,4,5] // 修改 切片的长度 changeSliceLength(dataSlice) fmt.Println(dataSlice) // 输出 [1,2,3,4,5]\",\"那么要是减少切片长度呢？\",\"// 改变 slice 的长度 func changeSliceLength(slice []int) { slice = slice[:len(slice) / 2] } dataSlice := []int{1,2,3,4,5} fmt.Println(dataSlice) // 输出 [1,2,3,4,5] // 修改 切片的长度 changeSliceLength(dataSlice) fmt.Println(dataSlice) // 输出 [1,2,3,4,5]\",\"结果是依然没有变化，实际上这里只是重新定义了切片的范围，原切片底层的存储数组没有发生变化，故不表现出任何变化。\",\"那要是我将该指针指向另外一个新切片呢？答案依然是不会变化，因为你拷贝的只是指针的副本，修改操作都是通过该指针来进行的，即使将该指针指向其他地址，原切片中的指针指向的还是原来的底层数组，还是不会展现出任何变化。\",\"总结：只有在修改切片内元素的时候，操作到了底层数组，才会展现出修改原切片的效果，其他操作都没有操作到底层数组，故不会展现出任何变化。\"]},\"13\":{\"h\":\"\",\"t\":[\"在 Go 语言中，数组（arr）和切片（slice）有一些重要的区别，特别是在使用和传递时的行为有所不同。\"]},\"14\":{\"h\":\"\",\"t\":[\"固定长度：\",\"数组在声明时需要指定固定的长度，并且长度在整个生命周期中都是不可变的。\",\"声明方式：var arr [5]int 或 arr := [5]int{1, 2, 3, 4, 5}。\",\"值传递：\",\"当将数组作为参数传递给函数时，传递的是数组的副本而不是引用。这意味着在函数内部对数组的修改不会影响外部的原始数组。\",\"性能优化：\",\"数组是在栈上分配内存的，访问速度较快，但长度固定。\"]},\"15\":{\"h\":\"\",\"t\":[\"动态长度：\",\"切片是对数组的一层轻量级封装，它的长度和容量可以动态改变。\",\"声明方式：var slice []int 或 slice := []int{1, 2, 3, 4, 5}。\",\"引用传递：\",\"切片在作为函数参数传递时，传递的是切片结构的副本，但仍然共享相同的底层数组。因此，在函数内部对切片的修改会影响外部的原始切片。\",\"灵活性：\",\"可以使用切片表达式、append 函数等对切片进行操作，支持动态增删元素。\"]},\"16\":{\"h\":\"\",\"t\":[\"下面是一个简单的示例，说明数组和切片在传递和使用时的区别：\",\"package main import \\\"fmt\\\" func modifyArray(arr [5]int) { arr[0] = 100 fmt.Println(\\\"函数内部修改数组:\\\", arr) // 输出: [100 2 3 4 5] } func modifySlice(slice []int) { slice[0] = 100 fmt.Println(\\\"函数内部修改切片:\\\", slice) // 输出: [100 2 3 4 5] } func main() { arr := [5]int{1, 2, 3, 4, 5} slice := arr[:] modifyArray(arr) fmt.Println(\\\"函数外部数组不受影响:\\\", arr) // 输出: [1 2 3 4 5] modifySlice(slice) fmt.Println(\\\"函数外部切片受影响:\\\", slice) // 输出: [100 2 3 4 5] }\"]},\"17\":{\"h\":\"\",\"t\":[\"数组是固定长度、值传递的数据结构，适合用于需要静态长度的场景。\",\"切片是动态长度、引用传递的数据结构，更加灵活，适合处理动态增删元素的需求。\"]},\"18\":{\"h\":\"1. Golang 介绍\"},\"19\":{\"h\":\"背景\",\"t\":[\"Golang（或称 Go 语言）是由 Google 开发的一种开源编程语言，首次发布于2009年。它由 Robert Griesemer、Rob Pike 和 Ken Thompson 设计，旨在提高编程效率，解决软件工程中的常见问题。Golang 的设计灵感来自 C 语言，但它加入了并发编程和垃圾回收等现代特性，适用于构建高性能的服务器端应用。\"]},\"20\":{\"h\":\"介绍\",\"t\":[\"Golang 是一门静态类型的编程语言，以其简洁的语法和高效的编译速度而闻名。它支持并发编程，通过 goroutines 和 channels 提供了强大的并发处理能力。Golang 的主要特点包括：\",\"简单易读：Golang 的语法简洁明了，减少了学习和使用的难度。\",\"高性能：Golang 编译后的二进制文件执行速度快，适合构建高性能应用。\",\"并发性：通过 goroutines 和 channels 支持并发编程，轻松处理大量并发任务。\",\"跨平台：Golang 可以编译成跨平台的可执行文件，支持 Windows、macOS 和 Linux 等操作系统。\",\"丰富的标准库：Golang 提供了丰富的标准库，涵盖网络、文件系统、编码解码等常见功能。\"]},\"21\":{\"h\":\"应用\",\"t\":[\"Golang 由于其高性能和简洁性，在多个领域得到了广泛应用，主要包括：\",\"Web 开发：使用流行的框架如 Gin、Echo 和 Beego，可以快速构建高性能的 Web 应用和 API 服务。\",\"微服务架构：Golang 由于其高并发处理能力和小内存占用，成为微服务架构的首选语言之一。\",\"云计算：Golang 被广泛应用于云计算平台和工具的开发，如 Docker 和 Kubernetes。\",\"系统编程：Golang 的性能和效率使其适合用于系统级编程和网络服务器开发。\",\"数据处理：Golang 的并发特性使其在数据处理和流处理领域表现出色，适用于实时数据分析和处理。\"]},\"22\":{\"h\":\"结论\",\"t\":[\"Golang 以其简洁、高效和强大的并发处理能力，成为现代软件开发中的一颗新星。无论是 Web 开发、微服务架构、云计算，还是系统编程和数据处理，Golang 都能提供强大的支持。对于希望构建高性能、高并发应用的开发者来说，Golang 是一门值得学习和掌握的编程语言。\"]},\"23\":{\"h\":\"2. 环境配置\",\"t\":[\"正式学习 Golang 之前首先需要安装配置好 Golang 环境，如果您已经配好环境，跳过即可。\"]},\"24\":{\"h\":\"Golang环境\",\"t\":[\"下载地址：https://golang.google.cn/dl/\",\"选择适合自己的版本进行下载即可\",\"https://golang.google.cn/doc/install\",\"配置变量\",\"如果完全按照如上步骤进行操作，仍无法通过 go 环境检查，请重启电脑使得环境变量生效即可。\"]},\"25\":{\"h\":\"开发工具\",\"t\":[\"工欲善其事，必先利其器。一个好的开发工具能让你事半功倍，大大提高开发效率，这里我推荐 VsCode 和 Goland 这两个开发工具。\"]},\"26\":{\"h\":\"VSCode\",\"t\":[\"下载安装：https://code.visualstudio.com/\",\"下载好后安装即可。\",\"配置 Golang 插件\",\"使用 VSCode 可以直接使用我们配置好的环境变量。\"]},\"27\":{\"h\":\"Goland\",\"t\":[\"下载安装：https://www.jetbrains.com/go/\",\"下载后安装即可。\",\"配置 Golang\",\"配置 GOROOT、GOPATH、GOModuls 为你自己下载安装的对应目录即可。\",\"这里配置时，可以使用 Goland 自带的 Go 下载，也可以配置我们自己下载的 Golang。\",\"优缺点对比：\",\"VSCode 轻量级，还可开发其他任意语言。Goland 仅对 Golang 有较好支持。\",\"VSCode 免费开源，有强大的生态支持，Goland Unlimited 版本收费，且价格较高。\",\"Goland 可视化界面优秀，对于调试开发更为优雅舒适，VSCode 需要配置插件，较为麻烦。\",\"Goland 内置了许多功能，且有 AI 功能，无需其他配置，开箱即用，非常方便。VSCode 功能全靠插件，需要自己配置安装。\",\"总结：VSCode 和 Goland 各有优缺，选择合适自己的开发工具即可，两者也可同时兼备，无需精神内耗。\"]},\"28\":{\"h\":\"6. 函数方法\",\"t\":[\"在 Golang 中函数是对代码封装和重用的基本形式，与 Java 、C/C++ 不同的是，Golang 中的函数功能似乎更加强大，不仅可以当做代码的封装，还可以当做变量，也可以作为参数进行传递。\",\"以下是 Golang 函数的定义、调用、参数、返回值、匿名函数、闭包等方面的详细说明：\"]},\"29\":{\"h\":\"函数\"},\"30\":{\"h\":\"1. 函数定义与调用\",\"t\":[\"函数定义使用 func 关键字，具体如下：\",\"// 函数定义 func add(a int, b int) int { return a + b } // 函数调用 result := add(2, 3) // result == 5\",\"add : 函数名称\",\"(a int, b int )：参数列表\",\"int : 返回值类型\"]},\"31\":{\"h\":\"2. 参数与返回值\",\"t\":[\"多参数函数：可以定义多个参数，参数类型可以相同或不同。\",\"func multiply(x int, y int) int { return x * y }\",\"多返回值函数：函数可以返回多个值。\",\"func divide(x, y int) (int, int) { return x / y, x % y } quotient, remainder := divide(10, 3) // quotient == 3, remainder == 1\",\"这和 Java 等语言中函数只能返回一个值不同。\",\"命名返回值：可以为返回值命名，使得返回值在函数体内被赋值时无需显示 return。\",\"func rectangleArea(width, height int) (area int) { area = width * height return // 可直接隐藏，可用于控制逻辑执行 }\",\"这里可以看做是在函数调用之前就初始化好了返回值变量，故这里不必定义可直接使用。\"]},\"32\":{\"h\":\"3. 可变参数函数\",\"t\":[\"可变参数：函数可以接收变长参数列表。\",\"func sum(nums ...int) int { total := 0 for _, num := range nums { total += num } return total } total := sum(1, 2, 3, 4) // total == 10\"]},\"33\":{\"h\":\"4. 匿名函数\",\"t\":[\"匿名函数：函数可以是匿名的，并且可以赋值给变量或作为参数传递。\",\"add := func(a, b int) int { return a + b } result := add(3, 4) // result == 7\"]},\"34\":{\"h\":\"5. 闭包\",\"t\":[\"闭包：匿名函数可以访问其外层作用域中的变量，即使这些变量不在其参数列表中。\",\"func makeMultiplier(factor int) func(int) int { return func(x int) int { return x * factor } } double := makeMultiplier(2) result := double(5) // result == 10\",\"匿名函数和闭包有啥区别？\",\"区别\",\"匿名函数是指没有名称的函数，可以被直接调用或者作为值传递给其他函数。\",\"闭包是指一个函数值，可以访问其定义时外部作用域中的变量，即使在定义时所在的作用域已经不存在，这些变量仍然可以被访问和操作。\",\"使用场景\",\"使用匿名函数可以简化代码结构，将一些逻辑封装成临时使用的函数。\",\"使用闭包可以实现状态的保持和管理，特别适合需要持久化状态或者捕获动态变化的场景。\"]},\"35\":{\"h\":\"6. 递归函数\",\"t\":[\"递归：函数可以调用自身来解决问题。但需要明确出退出条件，否则会无限递归，导致栈溢出。\",\"func factorial(n int) int { if n <= 1 { return 1 } return n * factorial(n-1) } result := factorial(5) // result == 120\"]},\"36\":{\"h\":\"7. 函数作为参数和返回值\",\"t\":[\"函数作为参数：函数可以作为参数传递给其他函数。\",\"func apply(fn func(int, int) int, a int, b int) int { return fn(a, b) } result := apply(add, 5, 6) // result == 11\",\"函数作为返回值：函数可以返回另一个函数。\",\"func makeAdder(x int) func(int) int { return func(y int) int { return x + y } } add5 := makeAdder(5) result := add5(3) // result == 8\"]},\"37\":{\"h\":\"8. 延迟执行 ( )\",\"t\":[\"延迟执行：defer 语句可以延迟函数或方法的执行直到封闭函数返回。\",\"func main() { defer fmt.Println(\\\"World\\\") fmt.Println(\\\"Hello\\\") } // Output: // Hello // World\",\"多个 Defer 调用根据后进先出的顺序执行，类似于栈。\"]},\"38\":{\"h\":\"9. 错误处理\",\"t\":[\"错误处理：通过返回值和内置的 error 类型进行错误处理。\",\"func divide(x, y int) (int, error) { if y == 0 { return 0, fmt.Errorf(\\\"division by zero\\\") } return x / y, nil } result, err := divide(10, 0) if err != nil { fmt.Println(\\\"Error:\\\", err) }\"]},\"39\":{\"h\":\"方法\",\"t\":[\"方法是定义在类型上的函数，在 Golang 中方法与函数的区别在于，方法拥有接收者，而函数没有，且只有自定义类型能够拥有方法。\",\"type Rectangle struct { width, height int } func (r Rectangle) Area() int { return r.width * r.height } rect := Rectangle{10, 5} area := rect.Area() // area == 50\",\"这个案例中大体上和函数基本类似，只在函数名前面多了 (r Rectangle)，这定义了方法的接收者为 r，Rectangle 就是方法的接收者类型，说明方法属于该接收者，调用时需要使用到该接收者。\",\"方法的接收者分为 值接收者 和 指针接收者 两种类型\",\"值接收者\",\"type MyInt int func (m MyInt) Double() { m = m * 2 } func main() { var x MyInt = 10 var y int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"初始 x 的值为: \\\", y) // 输出: 初始 x 的值为: 10 x.Double() var z int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"成倍后 x 的值为: \\\", z) // 输出: 成倍后 x 的值为: 10 }\",\"这里调用了 Double 方法，是将 MyInt 类型的 x 变成两倍，但是实际的输出是：\",\"初始 x 的值为: 10 成倍后 x 的值为: 10\",\"并没有达到成倍的效果，这是因为这里方法的接收者是值，在方法被调用时，会将接收者的值传入方法中，可以类似的看为形参，在方法内修改形参的值，并不会对方法外面的值进行改变。\",\"如果要是通过指针调用会如何呢？\",\"func main() { var x MyInt = 10 var y int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"初始 x 的值为: \\\", y) // 输出: 初始 x 的值为: 10 (&x).Double() var z int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"成倍后 x 的值为: \\\", z) // 输出: 成倍后 x 的值为: 10 }\",\"事实上，输出的仍然是上述结果，这是因为为了能够和接收者类型进行匹配，Golang 自行进行进行了解引用操作，将 (&x).Double() 解析为(*(&x)).Double() ，以便于匹配 (m MyInt) 的接收者类型。\",\"指针接收者\",\"将上述代码进行修改，将值接收者变为指针接收者\",\"type MyInt int func (m *MyInt) Double() { *m = *m * 2 } func main() { var x MyInt = 10 var y int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"初始 x 的值为: \\\", y) // 输出: 初始 x 的值为: 10 x.Double() var z int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"成倍后 x 的值为: \\\", z) // 输出: 成倍后 x 的值为: 20 }\",\"执行后的结果为：\",\"初始 x 的值为: 10 成倍后 x 的值为: 20\",\"此时成功的修改了 x 的值，此时即便我们没有使用指针调用，依然能够修改成功，这也是因为 Golang 为了成功匹配接收者的类型，帮我们做了引用，将 x.Double() 转换为了 (&x).Double()，故方法的接收者为指针时，不管调用者是不是指针，都可以修改内部的值。\",\"函数参数的传递过程中，是值拷贝，也就是将原来的值复制一份传递，故修改形参时，不会影响原有的值。传递指针时，也是将指针的内容复制一份传递，但是由于两个指针所指向的是同一个地址，此时再通过该指针来修改形参，也会造成原值的变化，从而实现了原值的修改。\",\"了解到这些之后，可以思考切片这种类型做为参数传递，是否会修改原值？\",\"答案是：会修改原值。原因如下：在前面 数据类型的小节中，说明了切片这种数据类型底层实际上存储了指向切片的指针，对切片的操作是通过该指针来进行的，故在修改形参后，对应的也会造成原值的改变。\",\"和 Java 中不同的是，Golang 中的数组是直接存储在内存中的值，作为参数传递时会传递数组的副本，修改形参并不会对原值曹成变化，但是 Java 中是通过引用传递数组的，故会修改原值。\",\"方法和函数的区别\",\"方法和函数的却别，类似于 Java 中的 类方法 和 对象方法，即函数的归属不同。\",\"在 Golang 中接收者不能直接调用属于包的函数，只能直接调用自身绑定的方法，但是可以在这些方法的内部实现中访问包中的函数。\"]},\"40\":{\"h\":\"访问控制\",\"t\":[\"Golang 中的访问控制是通过其名称的第一个首字母进行区分的：\",\"大写字母开头：导出（exported），可以被其他包访问。\",\"小写字母开头：未导出（unexported），仅在包内可见。\",\"这种约定适用于 Go 的所有标识符，包括变量、常量、函数、类型（结构体、接口等）、字段和方法。\",\"Golang 的访问控制机制简化了代码结构，主要关注于包级别的访问限制。设计理念主要有以下几个方面：\",\"明确性：通过首字母大小写，访问控制一目了然。\",\"简洁性：避免了复杂的访问控制规则。\",\"包为单位：所有访问控制以包为基本单位，有助于实现良好的包封装\",\"如果想访问其内部的数据，可借助辅助函数或者接口\",\"辅助函数：可以定义类似于 Get、Set 类似的辅助函数，从而实现对没有权限的数据的访问。\",\"接口：虽然结构体字段可以是未导出的，但如果字段实现了某个接口的方法，并且该接口是导出的，依然可以通过接口访问其功能。\",\"这些是 Golang 函数的主要特性和用法示例，每个特性提供了强大的工具来处理函数的定义、调用、参数传递、返回值以及高级用法。在实际的开发中，函数是最高频被使用到的技术点，需要熟练掌握。\"]},\"41\":{\"h\":\"5. 逻辑控制语句\"},\"42\":{\"h\":\"If 语句\",\"t\":[\"if 语句是编程语言中最为基础也是最重要的一个逻辑控制语句，以下是几种 if 语句的具体用法。\",\"if 语句\",\"if condition { // condition 为 true 时执行的语句 }\",\"if ... else 语句\",\"if condition { // condition 为 true 时执行的语句 } else { // condition 为 false 时执行的语句 }\",\"if ... else if ... else 语句\",\"if condition1 { // condition1 为 true 时执行的语句 } else if condition2 { // condition2 为 true 时执行的语句 } else { // condition1 和 condition2 都为 false 时执行的语句 }\",\"if 语句可以嵌套使用，以满足实际需求\"]},\"43\":{\"h\":\"Switch 语句\",\"t\":[\"Switah 语句用于进行多分支条件判断，替代多个 if ... else 结构，使代码更加简洁和易读。\",\"switch expression { case value1: // 当 expression 等于 value1 时执行的代码块 case value2: // 当 expression 等于 value2 时执行的代码块 default: // 当所有 case 都不匹配时执行的代码块（可选） }\",\"特点与注意事项\",\"无需使用 break 语句：Go 的 switch 语句在匹配到某个 case 后会自动跳出 switch 块，不需要像 C/C++ 或者 Java 中那样显式使用 break 来终止 case。\",\"多个匹配条件：可以在同一个 case 分支中指定多个匹配条件，用逗号分隔：\",\"switch day { case \\\"Saturday\\\", \\\"Sunday\\\": fmt.Println(\\\"Weekend\\\") default: fmt.Println(\\\"Weekday\\\") }\",\"空 switch 语句：如果 switch 关键字后没有表达式，那么它将作为一个 true 开关，可以用于条件逻辑：\",\"switch { case x > 0: fmt.Println(\\\"x is positive\\\") case x < 0: fmt.Println(\\\"x is negative\\\") default: fmt.Println(\\\"x is zero\\\") }\",\"带初始化语句的 switch：可以在 switch 语句中初始化一个变量，该变量的作用域仅限于 switch 内部：\",\"switch x := getValue(); x { case 1: fmt.Println(\\\"x is 1\\\") case 2: fmt.Println(\\\"x is 2\\\") default: fmt.Println(\\\"x is neither 1 nor 2\\\") }\",\"类型开关：switch 语句还可以用于类型断言，以便处理接口类型的不同实现：\",\"var i interface{} = \\\"hello\\\" switch v := i.(type) { case int: fmt.Println(\\\"i is an int\\\") case string: fmt.Println(\\\"i is a string\\\") default: fmt.Printf(\\\"i is of unknown type %T\\\\n\\\", v) }\",\"在这个例子中，v 被分配为 i 的类型断言结果，并根据 v 的类型选择不同的 case。\",\"Switch 适用于同一变量的多种条件，能够使得代码逻辑更加清晰，方便维护。\"]},\"44\":{\"h\":\"For 语句\",\"t\":[\"For 循环是一种常见的控制流结构，用于重复执行一段代码块，直到指定的条件不再满足为止。与其他编程语言不同，Golang 中没有提供 While 语句，但可以使用 Golang 来实现同样的效果。\",\"基本语法\",\"Go 中的 for 循环有三种基本形式：\",\"基本的 for 循环：\",\"for initialization; condition; post { // 循环体 }\",\"initialization：循环开始前执行的初始化语句，通常是变量声明或赋值。\",\"condition：循环的条件判断表达式，当条件为 false 时退出循环。\",\"post：每次循环迭代后执行的操作，通常是更新变量的语句。\",\"示例：\",\"package main import \\\"fmt\\\" func main() { for i := 1; i <= 5; i++ { fmt.Println(i) } }\",\"上述代码将输出从 1 到 5 的数字。\",\"类似于 while 的循环：\",\"Go 中没有 while 循环，但可以通过 for 循环模拟 while 循环：\",\"for condition { // 循环体 }\",\"示例：\",\"package main import \\\"fmt\\\" func main() { sum := 0 for sum < 10 { sum += 2 fmt.Println(sum) } }\",\"上述代码会输出 2、4、6、8、10，直到 sum 的值不再小于 10。\",\"无限循环：\",\"可以使用空的 for 循环来实现无限循环：\",\"for { // 无限循环体 }\",\"示例：\",\"package main import \\\"fmt\\\" func main() { count := 0 for { count++ if count > 5 { break } fmt.Println(\\\"Count:\\\", count) } }\",\"上述代码将输出 Count: 1 到 Count: 5，然后退出循环。\",\"for range 循环\",\"Go 还提供了一种特殊的 for range 循环，用于迭代数组、切片、字符串、映射等数据结构：\",\"for index, value := range collection { // 使用 index 和 value 进行操作 }\",\"示例：\",\"package main import \\\"fmt\\\" func main() { numbers := []int{1, 2, 3, 4, 5} for index, value := range numbers { fmt.Printf(\\\"Index: %d, Value: %d\\\\n\\\", index, value) } }\",\"这段代码会输出数组 numbers 中每个元素的索引和值。\",\"注意事项\",\"Go 中的 for 循环的三个部分 initialization、condition 和 post 都是可选的。\",\"for 循环没有括号 {} 之外的条件表达式，循环体必须用大括号 {} 括起来，即使只有一行代码。\"]},\"45\":{\"h\":\"Select 语句\",\"t\":[\"在 Go 语言中，select 语句用于处理并发操作，特别是用于从多个通信通道中选择和执行不同的 case。以下是关于 select 语句在 Go 中的详细解释和用法说明：\",\"1. 基本语法\",\"select 语句类似于 switch 语句，但用于通信操作：\",\"select { case communicationCase1: // 处理通信1的逻辑 case communicationCase2: // 处理通信2的逻辑 default: // 当没有任何通信情况发生时执行的逻辑（可选） }\",\"case communicationCase1:：每个 case 都描述了一个通信操作，它可以是 channel 的发送或接收操作。\",\"default:：default 分支在所有 case 都不满足时执行，它是可选的。\",\"2. 示例\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) func main() { ch1 := make(chan string) ch2 := make(chan string) go func() { time.Sleep(2 * time.Second) ch1 <- \\\"message from ch1\\\" }() go func() { time.Sleep(1 * time.Second) ch2 <- \\\"message from ch2\\\" }() select { case msg1 := <-ch1: fmt.Println(\\\"Received\\\", msg1) case msg2 := <-ch2: fmt.Println(\\\"Received\\\", msg2) default: fmt.Println(\\\"No communication\\\") } }\",\"在这个示例中，select 语句会等待并接收来自 ch1 和 ch2 通道的消息，并打印出第一个准备好的消息。由于 ch2 的消息比 ch1 的消息先准备好，因此输出结果会是 \\\"Received message from ch2\\\"。\",\"3. 特点与注意事项\",\"select 语句在每次执行时，都会随机选择一个满足条件的 case 执行。如果多个 case 同时准备好，Go 会随机选择其中之一。\",\"如果没有任何 case 准备好，并且存在 default 分支，则会执行 default 分支的代码。\",\"select 语句可以和 for 循环结合使用，实现不断地监听多个通道的消息。\",\"select 中的 case 可以是发送操作、接收操作或者仅仅是用于阻塞当前 goroutine 的操作。\",\"4. 使用场景\",\"多路复用通信：当需要从多个通道中接收消息时，select 是一个非常有用的工具，可以有效地管理并发通信。\",\"超时控制：结合 time.After() 和 select 可以实现超时控制，例如在一定时间内等待某个操作完成或者超时返回默认结果。\",\"5. 总结\",\"select 语句是 Go 语言中处理并发编程的重要工具之一，通过选择和处理多个通道中的消息，可以简化并发程序的编写和管理。了解并熟练使用 select 可以提升代码的可读性和性能。\",\"上述的所有逻辑控制语句均可嵌套使用，从而达到流程控制的作用。这几个语句最为重要，也必须熟练掌握。\"]},\"46\":{\"h\":\"10. Map 集合\",\"t\":[\"在 Go 语言中，map 是一种内置的数据结构，用于存储键值对。它是一种无序集合，提供了非常高效的查找、插入和删除操作。所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，遍历 Map 时返回的键值对的顺序是不确定的。\"]},\"47\":{\"h\":\"声明和初始化\",\"t\":[\"Map 的声明语法如下所示\",\"var map [key]value\",\"由于 Map 是 Golang 内置的数据结构，故可以使用 make 函数来创建 map 实例\",\"m := make(map[string]int) // 也可使用字面量进行初始化 m := map[string]int{ \\\"Alice\\\": 25, \\\"Bob\\\": 30, }\"]},\"48\":{\"h\":\"操作map\",\"t\":[\"查询\",\"仅获取对应键的值\",\"bob := m[\\\"Bob\\\"]\",\"获取对应键的值，并且判断键是否存在\",\"age, exists := m[\\\"David\\\"] if exists { fmt.Println(\\\"David's age is\\\", age) } else { fmt.Println(\\\"David is not in the map\\\") }\",\"在获取 Map 的值时，如果键不存在，返回该类型的零值，例如 int 类型的零值是 0，string 类型的零值是 \\\"\\\"。\",\"插入或更新\",\"插入和更新操作是相同的，它首先会去更新，如果不存在则插入。\",\"m[\\\"height\\\"] = 180\",\"删除\",\"使用 delete 函数来删除指定的键值对\",\"delete(m, \\\"Bob\\\")\",\"获取map长度\",\"使用 len 函数来获取 map 集合的长度，该长度为键值对的个数\",\"mapLen := len(m)\",\"遍历\",\"for name, age := range m { fmt.Printf(\\\"%s is %d years old\\\\n\\\", name, age) }\",\"作为参数传递\",\"Map 是引用类型，如果将一个 Map 传递给一个函数或赋值给另一个变量，它们都指向同一个底层数据结构，因此对 Map 的修改会影响到所有引用它的变量。\",\"map 的特性\",\"无序：map 中的键值对是无序的，遍历时的顺序不一定与插入顺序相同。\",\"键的类型：map 的键可以是任何支持 == 和 != 操作的类型，如布尔型、数字、字符串、指针、接口类型（只要动态类型支持 ==）、结构体（只要所有字段支持 ==）等。切片、函数和包含切片的结构体不能作为键。\",\"值的类型：map 的值可以是任何类型。\",\"零值：map 的零值是 nil，未初始化的 map 不能直接存储键值对。\"]},\"49\":{\"h\":\"并发安全\",\"t\":[\"Go 中的 map 本身不是并发安全的。如果在多个 goroutine 中同时读写同一个 map，可能会导致数据竞态和程序崩溃。可以使用 sync.Mutex 或 sync.RWMutex 来保护 map 的并发访问，或者使用 sync.Map，它是一个并发安全的 map 实现：\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) func main() { var m sync.Map // 存储值 m.Store(\\\"Alice\\\", 25) m.Store(\\\"Bob\\\", 30) // 加载值 age, ok := m.Load(\\\"Alice\\\") if ok { fmt.Println(\\\"Alice's age:\\\", age) } // 遍历 m.Range(func(key, value interface{}) bool { fmt.Printf(\\\"%s is %d years old\\\\n\\\", key, value) return true }) }\"]},\"50\":{\"h\":\"特殊情况NaN\",\"t\":[\"这里要注意一个特殊情况，math.NaN() 并不是一个可比较的值，当其作为 key 时，因为 NaN（Not-a-Number） 与任何值（包括它自己）比较都不相等。\",\"使用 math.NaN() 作为 map 的键会导致不可预测的行为，或者编译时错误。以下是一个示例，展示为什么不能使用 math.NaN() 作为 map 的键：\",\"示例\",\"package main import ( \\\"fmt\\\" \\\"math\\\" ) func main() { m := make(map[float64]string) // 尝试使用 NaN 作为键 nan := math.NaN() m[nan] = \\\"Not-a-Number\\\" // 检查 NaN 是否在 map 中 val, exists := m[nan] fmt.Printf(\\\"Key exists: %v, Value: %v\\\\n\\\", exists, val) // 尝试使用另外一个 NaN 作为键来获取值 anotherNaN := math.NaN() val, exists = m[anotherNaN] fmt.Printf(\\\"Another key exists: %v, Value: %v\\\\n\\\", exists, val) }\",\"输出\",\"Key exists: true, Value: Not-a-Number Another key exists: false, Value:\",\"这个示例展示了以下几点：\",\"即使在 map 中插入了一个键 nan，查找时依然无法找到它，因为 NaN 不等于任何值（包括它自己）。\",\"exists 会返回 false，因为 anotherNaN 不等于 nan，即使它们都是 NaN。\",\"解决方案\",\"为了避免这种情况，不要使用 NaN 作为 map 的键。如果你有一个包含 NaN 的数据集，需要对其进行查找操作，考虑使用其他数据结构或转换策略来处理这些值。\",\"其他可比较类型的键\",\"在 Go 中，可以作为 map 键的类型包括：\",\"基本类型：int, float64, string, bool\",\"结构体类型（如果它们的所有字段都是可比较的类型）\",\"指针类型\",\"自定义类型（如果它们支持比较操作）\"]},\"51\":{\"h\":\"4. 运算符\"},\"52\":{\"h\":\"算术运算符\",\"t\":[\"+ 加法\",\"- 减法\",\"* 乘法\",\"/ 除法\",\"% 取模（求余）\",\"a := 10 b := 3 sum := a + b // 13 diff := a - b // 7 product := a * b // 30 quotient := a / b // 3 remainder := a % b // 1\"]},\"53\":{\"h\":\"关系运算符\",\"t\":[\"== 等于\",\"!= 不等于\",\"< 小于\",\"> 大于\",\"<= 小于等于\",\">= 大于等于\",\"a := 10 b := 5 isEqual := (a == b) // false isNotEqual := (a != b) // true isLess := (a < b) // false isGreaterOrEqual := (a >= b) // true\"]},\"54\":{\"h\":\"逻辑运算符\",\"t\":[\"&& 与\",\"|| 或\",\"! 非\",\"isTrue := true isFalse := false andResult := isTrue && isFalse // false orResult := isTrue || isFalse // true notResult := !isTrue // false\"]},\"55\":{\"h\":\"位运算符\",\"t\":[\"& 按位与\",\"| 按位或\",\"^ 按位异或\",\"<< 左移\",\">> 右移\",\"a := 5 // 二进制: 101 b := 3 // 二进制: 011 andResult := a & b // 1 (二进制: 001) orResult := a | b // 7 (二进制: 111) xorResult := a ^ b // 6 (二进制: 110) leftShift := a << 1 // 10 (二进制: 1010) rightShift := a >> 1 // 2 (二进制: 10)\"]},\"56\":{\"h\":\"赋值运算符\",\"t\":[\"= 简单赋值\",\"+= 加法赋值\",\"-= 减法赋值\",\"*= 乘法赋值\",\"/= 除法赋值\",\"%= 求余赋值\",\"<<= 左移赋值\",\">>= 右移赋值\",\"&= 按位与赋值\",\"|= 按位或赋值\",\"^= 按位异或赋值\",\"a := 10 b := 5 a += b // 等同于 a = a + b\"]},\"57\":{\"h\":\"其他运算符\",\"t\":[\"& 取址运算符\",\"* 指针运算符\",\". 结构体成员访问\",\"[] 数组、切片索引\",\"var i int = 10 var ptr *int ptr = &i // ptr 指向变量 i 的地址 var j int = *ptr // 取出指针并获取值 type Person struct{ name string age int } var person Person = Person{ name : \\\"CoderMast\\\", age : 18, } var name = person.name var personArr []Person;\"]},\"58\":{\"h\":\"运算符的优先级\",\"t\":[\"和数学中类似，Go语言中，运算符有不同的优先级，这影响了表达式中运算符执行的顺序。以下是Go语言中常见运算符的优先级，从高到低排列：\",\"一元运算符：\",\"+（正号）\",\"-（负号）\",\"!（逻辑非）\",\"^（按位取反）\",\"乘性运算符：\",\"*（乘法）\",\"/（除法）\",\"%（取模）\",\"加性运算符：\",\"+（加法）\",\"-（减法）\",\"位移运算符：\",\"<<（左移）\",\">>（右移）\",\"位运算符：\",\"&（按位与）\",\"|（按位或）\",\"^（按位异或）\",\"比较运算符：\",\"==（等于）\",\"!=（不等于）\",\"<（小于）\",\"<=（小于等于）\",\">（大于）\",\">=（大于等于）\",\"逻辑运算符：\",\"&&（逻辑与）\",\"逻辑运算符：\",\"||（逻辑或）\",\"赋值运算符：\",\"=（简单赋值）\",\"+=、-=、*=、/=、%=、<<=、>>=、&=、|=、^=（复合赋值运算符）\",\"运算符的优先级决定了表达式中各部分的计算顺序。例如，乘法运算符*的优先级高于加法运算符+，因此在表达式 a + b * c 中，先计算 b * c，然后再加上 a。\",\"除了优先级外，还有一些运算符是右结合的，例如赋值运算符=，意味着它从右向左结合。例如，a = b = 5 在Go语言中是合法的，先将 5 赋给 b，然后将 b 的值再赋给 a。\",\"这些规则有助于编写清晰且按预期执行的表达式。\",\"可使用括号来提升表达式中指定运算符的优先级，从而实现需求。\"]},\"59\":{\"h\":\"8. 指针\",\"t\":[\"在 C/C++ 中提供了指针这种类型，可以直接操作内存数据，在某些应用场景下非常实用。Golang 中也提供了指针，可以利用指针来简化一些任务的执行。虽然 Golang 提供了指针，但是由于操作指针的风险较大，考虑到这一点，Golang 同时也限制了指针的使用。\",\"指针是什么？\",\"指针是一个特殊类型的变量，用来存储其他变量的内存地址。指针变量指向一个内存地址，通过这个地址可以间接访问对应的变量。\"]},\"60\":{\"h\":\"声明指针\",\"t\":[\"在 Golang 中声明一个指针变量需要使用 * 符号，放在变量名前，表示这是一个指针类型的变量。\",\"var pointer *int // 一个指向整数类型的指针变量\"]},\"61\":{\"h\":\"获取变量地址\",\"t\":[\"获取变量的地址需要使用 & 符号，放在变量名前，表示取该变量的地址。\",\"var num = 10 pointer := &num // pointer 指向变量 num 的内存地址\"]},\"62\":{\"h\":\"访问指针的值\",\"t\":[\"通过 * 操作符，可以访问指针变量所指向的值。\",\"num := 10 ptr := &num fmt.Println(ptr) // 输出 0x1400012a0b0 fmt.Println(*ptr) // 输出 10\"]},\"63\":{\"h\":\"作为参数\",\"t\":[\"指针变量作为参数进行传递时，本质上还是传递的是指针的副本，只不过该副本中的内容和原指针变量的内容相同，所以通过地址来操作数据时，原数据也会发生改变。\",\"// 交换两个数的值 func swap(i *int, j *int) { var tmp = *i *i = *j *j = tmp } func main() { x := 5 y := 8 fmt.Printf(\\\"x : %d, y : %d\\\", x, y) // 输出 x : 5, y : 8 swap(&x, &y) fmt.Printf(\\\"x : %d, y : %d\\\", x, y) // 输出 x : 8, y : 5 }\"]},\"64\":{\"h\":\"指针运算\",\"t\":[\"在 C/C++ 中支持指针运算，可以通过一个指针，访问其指定偏移量的数据，自由度较高。虽然在 Golang 中也提供了指针，但是实际上是禁止了大部分指针运算的，原因是指针运算比较危险，很容易造成系统崩溃。\",\"下面是一段 C语言 的指针运算案例：\",\"#include <stdio.h> int main() { int arr[] = {1, 2, 3, 4, 5}; int* p = arr; // 指向数组的第一个元素 // 使用指针遍历数组 for (int i = 0; i < 5; ++i) { printf(\\\"Element %d: %d\\\\n\\\", i, *p); ++p; // 移动指针到下一个元素 } // 重置指针回到数组的第一个元素 p = arr; // 使用指针算术运算访问数组的特定元素 p = p + 2; printf(\\\"Third element (using pointer arithmetic): %d\\\\n\\\", *p); return 0; }\",\"在 C 语言中可以直接进行指针的运算，从而访问指定的数据，但这也就意味着，只要能够拿到对应的数据地址，即可访问，这是极度危险的。\",\"使用 unsafe 包进行指针运算\",\"如果你确实需要进行类似于 C/C++ 的指针算术运算，可以使用 unsafe 包。不过，这种方法应谨慎使用，因为它会绕过 Go 语言的内存安全检查，可能导致不可预知的行为。\"]},\"65\":{\"h\":\"空指针\",\"t\":[\"当一个指针被定义后没有分配到任何变量的时候，它的值为 nil，即空指针\",\"var pointer *int\",\"指针变量声明后，默认零值为 nil，即空指针。\",\"空指针判断\",\"if pointer == nil { // 空指针时执行 }\"]},\"66\":{\"h\":\"指针的指针\",\"t\":[\"指针是指向变量内存地址的值，这个值同样也是存储在内存中，存储到内存中的值也必然会占用内存，也会有地址。故有指针的指针。\",\"num := 10 var pointer1 = &num var pointer2 = &pointer1\",\"pointer1 即为 num 的指针\",\"pointer2 即为 pointer1 的指针，即指针的指针\",\"依次类推，可以有无限指针的循环嵌套\"]},\"67\":{\"h\":\"指针数组\",\"t\":[\"指针数组本质上是一个数组，只不过数据类型从基本类型变成了指针类型，存储的内容都是指针。\"]},\"68\":{\"h\":\"基础知识\"},\"69\":{\"h\":\"9. 结构体\",\"t\":[\"在 Golang 中相同类型的数据可以使用数组或者切片来存储，Golang 中抛弃了类与继承，保留了结构体，那么不同类型的数据可通过结构体来进行存储和组织。\",\"结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。\"]},\"70\":{\"h\":\"声明结构体\",\"t\":[\"结构体定义需要使用 type 和 struct 关键字。结构体中不仅可以使用 Golang 内置的数据类型，也可以使用结构体类型。\",\"type StructName struct { variableName1 dataType1 variableName2 dataType2 variableName3 dataType3 variableName4 dataType4 ...... }\",\"如果有相同类型的字段，可以简化声明\",\"type StructName struct { variableName1,variableName2,variableName3 ... dataType variableName4 dataType1 }\",\"结构体内部的字段名也遵循首字母大小写命名暴露的方式，在声明结构体内部的字段时，应避免其与方法名重复。\"]},\"71\":{\"h\":\"创建结构体实例\",\"t\":[\"与 Java 这种面向对象的语言不同，Golang 中没有构造方法的概念，以下是 Golang 中创建结构体实例的几种方式。\",\"// 定义一个结构体 type Person struct { Name string Age int }\",\"字面量直接实例化\",\"p1 := Person{ Name: \\\"Alice\\\", Age: 30 }\",\"字面量简写形式实例化\",\"p2 := Person{ \\\"Bob\\\", 25 }\",\"如果省略字段名，那么就必须要初始化所有字段，且必须按照声明的顺序初始化。否则就会产生歧义，语法简化的目的是为了在保证语义唯一的情况下尽可能简化。\",\"使用 new 函数实例化\",\"p3 := new(Person) p3.Name = \\\"Charlie\\\" p3.Age = 35\",\"这里只能使用 new 函数，不能使用 make 函数，两者的区别请参考 「new 和 make 详解」\",\"使用取地址符号实例化\",\"p4 := &Person{ Name: \\\"Dave\\\", Age: 40 }\",\"因为 Golang 中没有构造方法，所以可以定义一个工厂函数来创建对象。\",\"func NewPerson() Person { person := new(Person) person.Name = \\\"Golang Notes\\\" person.Age = 18 return person }\"]},\"72\":{\"h\":\"访问结构体成员\",\"t\":[\"访问结构体成员时使用 . 操作符，语法如下：\",\"structName.fieldName\",\"以本节中的 Person 结构体为例，如下所示：\",\"person := Person{ Name: \\\"Golang Notes\\\", Age: 18 } // 访问结构体字段 fmt.Println(person.Name) // 输出 ： Golang Notes fmt.Println(person.Age) // 输出 ： 18 // 修改结构体字段 person.Name = \\\"Coder Mast\\\" fmt.Println(person.Name) // 输出 ： Coder Mast\",\"那么再来看下面的这个例子\",\"person := new(Person) person.Name = \\\"Golang Notes\\\" person.Age = 18 // 或者下面这种形式 person := &Person{ Name: \\\"Golang Notes\\\", Age: 18 } // 访问结构体字段 fmt.Println(person.Name) // 输出 ： Golang Notes fmt.Println(person.Age) // 输出 ： 18 // 修改结构体字段 person.Name = \\\"Coder Mast\\\" fmt.Println(person.Name) // 输出 ： Coder Mast\",\"在这个例子中，person 实际上是结构体指针，但是在访问结构体时没有进行解引用就可直接访问结构体内容，这是 Golang 提供的语法糖，在编译后会自动进行解引用，如 person.Name 会被解析为 (*person).Name，本质还是解引用，只不过是在编译阶段，不必我们手动实现。\"]},\"73\":{\"h\":\"结构体作为参数\",\"t\":[\"和 Golang 内置的数据类型一样，结构体类型也能作为参数传递给函数。\",\"结构体值做参数\",\"type Person struct { Name string Age int } func readPerson(person Person) { fmt.Printf(\\\"Name : %s，Age : %d\\\", person.Name, person.Age) } func changePerson(person Person) { person.Name = \\\"Coder Mast\\\" person.Age = 20 } func main() { var person Person = Person{ Name: \\\"Golang Notes\\\", Age: 18 } readPerson(person) // 输出：Name : Golang Notes，Age : 18 changePerson() readPerson(person) // 输出：Name : Golang Notes，Age : 18 }\",\"结构体指针做参数\",\"type Person struct { Name string Age int } func readPerson(person *Person) { fmt.Printf(\\\"Name : %s，Age : %d\\\", person.Name, person.Age) } func changePerson(person *Person) { person.Name = \\\"Coder Mast\\\" person.Age = 20 } func main() { person := new(Person) person.Name = \\\"Golang Notes\\\" person.Age = 18 readPerson(person) // 输出：Name : Golang Notes，Age : 18 changePerson() readPerson(person) // 输出：Name : Coder Mast，Age : 20 }\",\"结构体做参数时，无论是传递指针结构体还是值结构体，都是传递对应的副本，但是由于指针的副本同样指向的是该结构体实例，故修改形参后能够对原数据造成改变，值结构体不能。\"]},\"74\":{\"h\":\"结构体标签\",\"t\":[\"在 Golang 中结构体标签是一种元数据，用于提供给反射等工具以获取结构体字段的额外信息。常见的包括 JSON序列化、数据库映射、XML映射等。\",\"结构体标签的具体使用如下：\",\"结构体标签使用案例\",\"package main import ( \\\"encoding/json\\\" \\\"fmt\\\" ) // 定义一个结构体，并使用 JSON 标签 type Person struct { Name string `json:\\\"name\\\"` Age int `json:\\\"age\\\"` Email string `json:\\\"email,omitempty\\\"` // omitempty 表示如果该字段为空，则在序列化时忽略它 Ignore string `json:\\\"-\\\"` // - 表示在序列化和反序列化时忽略该字段 } func main() { p := Person{ Name: \\\"Alice\\\", Age: 30, Email: \\\"\\\", Ignore: \\\"This will be ignored\\\", } // 将结构体序列化为 JSON jsonData, err := json.Marshal(p) if err != nil { fmt.Println(\\\"Error marshalling JSON:\\\", err) return } fmt.Println(string(jsonData)) // 输出: {\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30} // 将 JSON 反序列化为结构体 jsonStr := `{\\\"name\\\":\\\"Bob\\\",\\\"age\\\":25}` var p2 Person err = json.Unmarshal([]byte(jsonStr), &p2) if err != nil { fmt.Println(\\\"Error unmarshalling JSON:\\\", err) return } fmt.Printf(\\\"%+v\\\\n\\\", p2) // 输出: {Name:Bob Age:25 Email: Ignore:} }\"]},\"75\":{\"h\":\"结构体标签解释\",\"t\":[\"json:\\\"name\\\"：表示在进行 JSON 序列化和反序列化时，使用 name 作为 JSON 键名。\",\"json:\\\"email,omitempty\\\"：omitempty 表示如果该字段的值为空（零值），则在序列化时忽略它。\",\"json:\\\"-\\\"：表示在进行 JSON 序列化和反序列化时忽略该字段。\"]},\"76\":{\"h\":\"其他常见标签\",\"t\":[\"除了 JSON 标签外，还有其他常见的标签，例如：\",\"bson：用于 MongoDB 的 BSON 序列化。\",\"gorm：用于 GORM ORM 工具的数据库字段映射。\",\"yaml：用于 YAML 序列化和反序列化。\",\"type User struct { ID int `gorm:\\\"primary_key\\\"` // GORM 标签 Name string `bson:\\\"name\\\"` // BSON 标签 Age int `yaml:\\\"age\\\"` // YAML 标签 }\",\"通过使用结构体标签，可以更方便地控制序列化和反序列化的行为，以及与数据库、YAML 等数据格式的映射。\"]},\"77\":{\"h\":\"空结构体\",\"t\":[\"在 Golang 中，空结构体（empty struct）是一个没有任何字段的结构体。空结构体的声明如下：\",\"type EmptyStruct struct{}\",\"空结构体通常用于以下几种场景：\",\"作为信号传递的占位符：空结构体在信号传递、通知、标记等场景中使用，因为它不占用内存空间。\",\"集合数据结构中的占位符：空结构体可以用作 map 的值，以节省内存。\",\"嵌入其他结构体中：空结构体可以用于将方法注入到其他结构体中。\",\"使用空结构体作为信号传递的占位符\",\"在使用 channel 进行信号传递时，空结构体可以作为一种占位符，表示一个事件的发生，而不需要传递实际数据。\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) func main() { done := make(chan struct{}) // 创建一个空结构体的 channel go func() { fmt.Println(\\\"Goroutine started\\\") time.Sleep(2 * time.Second) close(done) // 发送信号 }() <-done // 接收信号 fmt.Println(\\\"Goroutine finished\\\") }\",\"使用空结构体作为 map 的值\",\"空结构体可以用作 map 的值，用于构建集合数据结构。这种方式比使用其他占位符（如 bool）更节省内存。\",\"package main import \\\"fmt\\\" func main() { // 使用空结构体作为 map 的值 mySet := make(map[string]struct{}) // 添加元素 mySet[\\\"apple\\\"] = struct{}{} mySet[\\\"banana\\\"] = struct{}{} // 检查元素是否存在 if _, exists := mySet[\\\"apple\\\"]; exists { fmt.Println(\\\"apple is in the set\\\") } // 输出集合中的元素 for key := range mySet { fmt.Println(key) } }\",\"使用空结构体嵌入其他结构体中\",\"空结构体可以嵌入到其他结构体中，以便为其他结构体提供方法集合。\",\"package main import \\\"fmt\\\" type Logger struct{} func (Logger) Log(message string) { fmt.Println(\\\"Log:\\\", message) } type Server struct { Logger } func main() { server := Server{} server.Log(\\\"Server started\\\") // 调用嵌入的 Logger 方法 }\",\"内存消耗\",\"空结构体不消耗任何内存空间，因为它不包含任何数据字段。这使得它非常适合作为信号或占位符使用。\",\"package main import ( \\\"fmt\\\" \\\"unsafe\\\" ) func main() { var emptyStruct struct{} fmt.Println(unsafe.Sizeof(emptyStruct)) // 输出 0 }\",\"综上所述，空结构体在 Golang 中是一个非常有用的工具，可以在多种场景中提高代码的效率和简洁性。\"]},\"78\":{\"h\":\"结构体的存储\",\"t\":[\"在 Golang 中结构体在内存中的存储是按其字段在结构体中声明的顺序来排列的，每个字段都以适当的内存对齐方式存储，以确保内存访问的效率。具体来说：\",\"内存对齐：为了提高内存访问效率，Go 会对结构体字段进行对齐。对齐意味着字段的起始地址必须是其类型大小的倍数。例如，int32 类型的字段必须对齐到 4 字节的边界，int64 类型的字段必须对齐到 8 字节的边界。\",\"填充和空洞：为了满足对齐要求，Go 编译器可能会在字段之间插入一些填充字节。这些填充字节不存储任何有效数据，只是为了使下一个字段的起始地址满足对齐要求。这会导致结构体在内存中占用的空间比字段本身的大小总和更多。\",\"内存对齐实际上是一种用空间换时间的设计。它通过将内存划分成大小均匀的小块，从而提高处理器访问内存的效率。这种设计有助于减少访问内存时的性能开销，从而提高系统整体的性能。\",\"示例和内存布局\",\"考虑以下结构体：\",\"package main import ( \\\"fmt\\\" \\\"unsafe\\\" ) type MyStruct struct { a bool // 1 byte b int32 // 4 bytes c int64 // 8 bytes } func main() { var s MyStruct fmt.Printf(\\\"Size of MyStruct: %d bytes\\\\n\\\", unsafe.Sizeof(s)) fmt.Printf(\\\"Offset of a: %d\\\\n\\\", unsafe.Offsetof(s.a)) fmt.Printf(\\\"Offset of b: %d\\\\n\\\", unsafe.Offsetof(s.b)) fmt.Printf(\\\"Offset of c: %d\\\\n\\\", unsafe.Offsetof(s.c)) }\",\"运行上述代码，会得到以下输出（具体数值可能会因编译器和平台而异）：\",\"Size of MyStruct: 16 bytes Offset of a: 0 Offset of b: 4 Offset of c: 8\",\"内存布局解释\",\"a 是一个 bool 类型，占用 1 个字节，位于偏移量 0。\",\"为了对齐 b（int32），需要在 a 后面插入 3 个填充字节，因此 b 的偏移量是 4。\",\"c 是 int64 类型，需要对齐到 8 字节的边界，b 的大小正好是 4 字节且在 a 之后填充了 3 个字节，使得 b 的末尾与 c 的起始位置对齐在 8 字节边界，因此 c 的偏移量是 8。\",\"总的来说，MyStruct 的总大小是 16 个字节，包含了字段和填充字节。\",\"内存优化\",\"为了减少结构体的内存占用，可以重新排列字段的顺序，尽量减少填充字节。例如：\",\"type OptimizedStruct struct { c int64 // 8 bytes b int32 // 4 bytes a bool // 1 byte }\",\"重新排列后的结构体可能占用更少的内存，因为字段 c 和 b 已经按对齐要求排列，只有在 b 和 a 之间需要 3 个填充字节。这样优化后的结构体的总大小可能会减小（依旧取决于具体平台和编译器）。\",\"内存布局优化\",\"package main import ( \\\"fmt\\\" \\\"unsafe\\\" ) type OptimizedStruct struct { c int64 // 8 bytes b int32 // 4 bytes a bool // 1 byte } func main() { var s OptimizedStruct fmt.Printf(\\\"Size of OptimizedStruct: %d bytes\\\\n\\\", unsafe.Sizeof(s)) fmt.Printf(\\\"Offset of c: %d\\\\n\\\", unsafe.Offsetof(s.c)) fmt.Printf(\\\"Offset of b: %d\\\\n\\\", unsafe.Offsetof(s.b)) fmt.Printf(\\\"Offset of a: %d\\\\n\\\", unsafe.Offsetof(s.a)) }\",\"运行上述优化后的代码，输出可能是：\",\"Size of OptimizedStruct: 16 bytes Offset of c: 0 Offset of b: 8 Offset of a: 12\",\"这表明通过优化字段顺序，结构体的大小可能会更小，同时保证内存对齐。\",\"总结\",\"了解结构体在内存中的存储方式和对齐规则，有助于编写更高效的代码，尤其是在处理大量结构体或需要高性能内存访问的场景中。合理地排列结构体字段可以减少内存占用和提高访问效率。\"]},\"79\":{\"h\":\"3. 数据类型及变量\"},\"80\":{\"h\":\"数据类型\",\"t\":[\"数据类型用于声明变量，虽然在函数中也有所涉及，如 参数、返回值等，但本质上仍是变量，如参数变量，返回值变量。\",\"数据类型实际上是为了优化内存空间的占用而提出的概念，根据实际的数据需求，分配不同的数据类型，从而达到节约内存的作用。\",\"Golang 中的数据类型分为：基本数据类型 和 复合数据类型。\"]},\"81\":{\"h\":\"基本数据类型\",\"t\":[\"数值类型：整数类型 (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64) 和浮点数类型 (float32, float64)、实数和虚数类型 （complex64、complex128）\",\"布尔类型：bool，Go 语言中不允许将布尔值类型强制转换为整型，也无法直接参与数值运算，也无法与其他类型转换。\",\"字符串类型：string\",\"基本类型的值，直接存在变量中。\"]},\"82\":{\"h\":\"复合数据类型\",\"t\":[\"数组类型：[n]T，表示拥有 n 个类型为 T 的元素的数组。数组是固定大小的连续内存块，其元素是存储在数组内存中的值，而不是地址。访问数组元素时，是直接访问内存中的数据。\",\"var arr [3]int = [3]int{1, 2, 3}\",\"切片类型：[]T，动态数组，可以增长和收缩。切片是一个动态数组，其底层结构包含一个指向数组的指针、长度和容量。切片本身包含了一个指向底层数组的指针，因此切片是通过地址引用数组元素的\",\"var slice []int = []int{1, 2, 3}\",\"映射类型：map[K]V，键值对集合。映射是一个哈希表，它是引用类型。映射中的键值对存储在内存中的某个位置，映射变量本身是一个指向哈希表的指针。\",\"var m map[string]int = map[string]int{\\\"a\\\": 1, \\\"b\\\": 2}\",\"结构体类型：struct，用于组织不同类型的字段。结构体是一个聚合数据类型，其字段是存储在结构体内存中的值，而不是地址。不过，结构体可以包含指针字段。\",\"type Person struct { Age int Name string } var p person = Person{ 18, \\\"CoderMast\\\" }\",\"指针类型：*T，用于声明一个指向类型 T 的指针。可使用 & 取地址符来获取指定变量的地址，使用 * 来取出指针所指向的地址的值。在 32 位系统上，指针为 4B，在 64 位系统上，指针为 8B。\",\"var i int = 10 var p *int = &i var j int = *p\",\"具体的变量信息如下：\",\"内存地址: 变量: 值: 0x0000 i 10 0x0004 p 0x0000(指向 i 的地址) 0x000C j 10\",\"Channel 类型，管道类型，用于在 goroutine 之间进行通信，从而控制 goroutine 的执行。操作符为 <-。var ch chan ChannelType 用于声明一个 channel 类型的变量 ch，且仅接受 ChannelType 类型的数据。\",\"ch := make(chan int) // 定义一个仅接受 int 类型的管道变量 ch ch <- 10 // 写入管道 i := <- ch // 读出管道\",\"管道中的值，读出即失效。 \",\"函数类型，在 Golang 中函数可像普通变量一样被传递、赋值和作为参数或者返回值。\",\"// 1. 函数类型声明 type Operator func(int, int) int // 2. 函数类型赋值 func add(a int,b int) int { return a + b } var operator Operator operator = add\",\"综上所述，在 Go 语言中\",\"数组元素直接存储在数组的内存块中。\",\"切片是引用类型，通过指针引用底层数组。\",\"映射是引用类型，通过指针引用底层哈希表。\",\"结构体字段直接存储在结构体内存块中，但结构体可以包含指针字段。\",\"这意味着在使用切片和映射时，实际操作的是底层数据的地址，而数组和结构体的操作是对其内存块中实际存储的数据进行操作。\"]},\"83\":{\"h\":\"变量\",\"t\":[\"在计算机中，数据都是存在内存中的二进制序列，可直接通过内存地址进行数据访问，但直接操作内存地址，不仅难度高、效率低，而且可能造成极其危险的后果，为了解决这个问题，引入了变量的概念，通过变量来访问数据。实际上变量的定义来源于数学，意思为可变化的量，通过变量名来访问变量的值。\",\"在 Golang 中变量可通过 var 关键字来声明，具体语法如下：\",\"变量的声明\",\"// 1. 声明单个变量 var variableName type // 2. 同时声明多个变量 var variableName1,variableName2 type\",\"该示例定义了一个数据类型为 type ，变量名为 identifier 的变量。\",\"该示例定义了两个数据类型为 type，变量名为 variableName1 和 variableName2 的变量。\",\"变量的初始化\",\"// 1. 初始化单个变量 var name string = \\\"友人\\\" // 2. 一次性初始化多个变量 var name, age = \\\"CoderMast\\\", 18\",\"Golang 提供了类型推导，可使得在不显式声明数据类型时，可直接初始化变量。\",\"var name = \\\"GolangNotes\\\"\",\"另外，Golang 还提供了一种简化变量声明和初始化的语法糖，可直接定义并初始化变量，已经被定义的变量无法使用该语法糖。\",\"name := \\\"CoderMast\\\"\",\"变量声明后如果没有给定初始值，则 Go 会默认给定对应的 零值，这里的零值并非等于 0，而是代指默认值。\"]},\"84\":{\"h\":\"常量\",\"t\":[\"变量是变化的量，那么常量即为不变的量，实际上就是这样。Golang 中常量和变量类似，只需要使用 const 关键字即可。\",\"// 单个变量 const url = \\\"https://www.golangnotes.com/\\\" // 多个变量 const ( name = \\\"CoderMast\\\" age = 18 ) // 同时声明多个常量时，如果省略了值则表示和上面一行的值相同 const ( n1 = 100 n2 n3 )\"]},\"85\":{\"h\":\"iota\",\"t\":[\"iota 是 Golang 中的一个特殊常量，可以被编译器修改。是 golang 中的常量计数器，在第一次使用 const 声明常量时初始化为 0，之后每声明一个常量则将 iota 加 1，也可将 iota 看做是常量的索引。\",\"const ( i = iota j = iota k = iota ) // fmt.Println(iota) 这样是错误的，不能直接把 iota 当做变量或常量使用 fmt.Println(i) fmt.Println(j) fmt.Println(k)\"]},\"86\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"看做是常量的索引\",{\"1\":{\"85\":1}}],[\"单个变量\",{\"1\":{\"84\":1}}],[\"已经被定义的变量无法使用该语法糖\",{\"1\":{\"83\":1}}],[\"已经按对齐要求排列\",{\"1\":{\"78\":1}}],[\"另外\",{\"1\":{\"83\":1}}],[\"友人\",{\"1\":{\"83\":1}}],[\"意思为可变化的量\",{\"1\":{\"83\":1}}],[\"意味着它从右向左结合\",{\"1\":{\"58\":1}}],[\"引入了变量的概念\",{\"1\":{\"83\":1}}],[\"引用传递的数据结构\",{\"1\":{\"17\":1}}],[\"引用传递\",{\"1\":{\"15\":1}}],[\"效率低\",{\"1\":{\"83\":1}}],[\"读出即失效\",{\"1\":{\"82\":1}}],[\"读出管道\",{\"1\":{\"82\":1}}],[\"管道中的值\",{\"1\":{\"82\":1}}],[\"管道类型\",{\"1\":{\"82\":1}}],[\"写入管道\",{\"1\":{\"82\":1}}],[\"定义一个仅接受\",{\"1\":{\"82\":1}}],[\"定义一个结构体\",{\"1\":{\"71\":1,\"74\":1}}],[\"变量是变化的量\",{\"1\":{\"84\":1}}],[\"变量声明后如果没有给定初始值\",{\"1\":{\"83\":1}}],[\"变量的初始化\",{\"1\":{\"83\":1}}],[\"变量的声明\",{\"1\":{\"83\":1}}],[\"变量名为\",{\"1\":{\"83\":2}}],[\"变量\",{\"0\":{\"83\":1},\"1\":{\"82\":1}}],[\"变成两倍\",{\"1\":{\"39\":1}}],[\"映射是引用类型\",{\"1\":{\"82\":1}}],[\"映射是一个哈希表\",{\"1\":{\"82\":1}}],[\"映射变量本身是一个指向哈希表的指针\",{\"1\":{\"82\":1}}],[\"映射中的键值对存储在内存中的某个位置\",{\"1\":{\"82\":1}}],[\"映射类型\",{\"1\":{\"82\":1}}],[\"映射等数据结构\",{\"1\":{\"44\":1}}],[\"动态数组\",{\"1\":{\"82\":1}}],[\"动态长度\",{\"1\":{\"15\":1}}],[\"直接存在变量中\",{\"1\":{\"81\":1}}],[\"直到\",{\"1\":{\"44\":1}}],[\"直到指定的条件不再满足为止\",{\"1\":{\"44\":1}}],[\"布尔类型\",{\"1\":{\"81\":1}}],[\"整数类型\",{\"1\":{\"81\":1}}],[\"复合数据类型\",{\"0\":{\"82\":1},\"1\":{\"80\":1}}],[\"复合赋值运算符\",{\"1\":{\"58\":1}}],[\"分配不同的数据类型\",{\"1\":{\"80\":1}}],[\"分支的代码\",{\"1\":{\"45\":1}}],[\"分支\",{\"1\":{\"45\":1}}],[\"分支在所有\",{\"1\":{\"45\":1}}],[\"分支中指定多个匹配条件\",{\"1\":{\"43\":1}}],[\"根据实际的数据需求\",{\"1\":{\"80\":1}}],[\"合理地排列结构体字段可以减少内存占用和提高访问效率\",{\"1\":{\"78\":1}}],[\"尤其是在处理大量结构体或需要高性能内存访问的场景中\",{\"1\":{\"78\":1}}],[\"重新排列后的结构体可能占用更少的内存\",{\"1\":{\"78\":1}}],[\"重置指针回到数组的第一个元素\",{\"1\":{\"64\":1}}],[\"尽量减少填充字节\",{\"1\":{\"78\":1}}],[\"总的来说\",{\"1\":{\"78\":1}}],[\"总结\",{\"1\":{\"12\":1,\"27\":1,\"45\":1,\"78\":1}}],[\"后面插入\",{\"1\":{\"78\":1}}],[\"后会自动跳出\",{\"1\":{\"43\":1}}],[\"个类型为\",{\"1\":{\"82\":1}}],[\"个填充字节\",{\"1\":{\"78\":2}}],[\"个字节\",{\"1\":{\"78\":3}}],[\"个元素\",{\"1\":{\"11\":3}}],[\"占用\",{\"1\":{\"78\":1}}],[\"运行上述优化后的代码\",{\"1\":{\"78\":1}}],[\"运行上述代码\",{\"1\":{\"78\":1}}],[\"运算符有不同的优先级\",{\"1\":{\"58\":1}}],[\"运算符的优先级决定了表达式中各部分的计算顺序\",{\"1\":{\"58\":1}}],[\"运算符的优先级\",{\"0\":{\"58\":1}}],[\"运算符\",{\"0\":{\"51\":1}}],[\"填充和空洞\",{\"1\":{\"78\":1}}],[\"具体语法如下\",{\"1\":{\"83\":1}}],[\"具体的变量信息如下\",{\"1\":{\"82\":1}}],[\"具体数值可能会因编译器和平台而异\",{\"1\":{\"78\":1}}],[\"具体来说\",{\"1\":{\"78\":1}}],[\"具体如下\",{\"1\":{\"11\":1,\"30\":1}}],[\"综上所述\",{\"1\":{\"77\":1,\"82\":1}}],[\"更节省内存\",{\"1\":{\"77\":1}}],[\"更加灵活\",{\"1\":{\"17\":1}}],[\"发送信号\",{\"1\":{\"77\":1}}],[\"创建一个空结构体的\",{\"1\":{\"77\":1}}],[\"创建结构体实例\",{\"0\":{\"71\":1}}],[\"进行信号传递时\",{\"1\":{\"77\":1}}],[\"进行操作\",{\"1\":{\"44\":1}}],[\"嵌入其他结构体中\",{\"1\":{\"77\":1}}],[\"标记等场景中使用\",{\"1\":{\"77\":1}}],[\"标签外\",{\"1\":{\"76\":1}}],[\"标签\",{\"1\":{\"74\":1,\"76\":3}}],[\"工具的数据库字段映射\",{\"1\":{\"76\":1}}],[\"工欲善其事\",{\"1\":{\"25\":1}}],[\"序列化和反序列化\",{\"1\":{\"76\":1}}],[\"序列化和反序列化时忽略该字段\",{\"1\":{\"75\":1}}],[\"序列化和反序列化时\",{\"1\":{\"75\":1}}],[\"序列化\",{\"1\":{\"76\":1}}],[\"键值对集合\",{\"1\":{\"82\":1}}],[\"键名\",{\"1\":{\"75\":1}}],[\"键的类型包括\",{\"1\":{\"50\":1}}],[\"键的类型\",{\"1\":{\"48\":1}}],[\"反序列化为结构体\",{\"1\":{\"74\":1}}],[\"`yaml\",{\"1\":{\"76\":1}}],[\"`bson\",{\"1\":{\"76\":1}}],[\"`gorm\",{\"1\":{\"76\":1}}],[\"`\",{\"1\":{\"74\":6,\"76\":3}}],[\"`json\",{\"1\":{\"74\":4}}],[\"常见的包括\",{\"1\":{\"74\":1}}],[\"常量\",{\"0\":{\"84\":1},\"1\":{\"40\":1}}],[\"提供的语法糖\",{\"1\":{\"72\":1}}],[\"提供了类型推导\",{\"1\":{\"83\":1}}],[\"提供了指针\",{\"1\":{\"59\":1}}],[\"提供了非常高效的查找\",{\"1\":{\"46\":1}}],[\"提供了丰富的标准库\",{\"1\":{\"20\":1}}],[\"提供了强大的并发处理能力\",{\"1\":{\"20\":1}}],[\"详解\",{\"1\":{\"71\":1}}],[\"应避免其与方法名重复\",{\"1\":{\"70\":1}}],[\"应用和\",{\"1\":{\"21\":1}}],[\"应用\",{\"0\":{\"21\":1}}],[\"保留了结构体\",{\"1\":{\"69\":1}}],[\"基础知识\",{\"0\":{\"68\":1}}],[\"基本数据类型\",{\"0\":{\"81\":1},\"1\":{\"80\":1}}],[\"基本类型的值\",{\"1\":{\"81\":1}}],[\"基本类型\",{\"1\":{\"50\":1}}],[\"基本的\",{\"1\":{\"44\":1}}],[\"基本语法\",{\"1\":{\"44\":1,\"45\":1}}],[\"依旧取决于具体平台和编译器\",{\"1\":{\"78\":1}}],[\"依次类推\",{\"1\":{\"66\":1}}],[\"依然可以通过接口访问其功能\",{\"1\":{\"40\":1}}],[\"依然能够修改成功\",{\"1\":{\"39\":1}}],[\"默认零值为\",{\"1\":{\"65\":1}}],[\"默认是扩容为当前容量的两倍\",{\"1\":{\"10\":1}}],[\"移动指针到下一个元素\",{\"1\":{\"64\":1}}],[\"很容易造成系统崩溃\",{\"1\":{\"64\":1}}],[\"交换两个数的值\",{\"1\":{\"63\":1}}],[\"本质还是解引用\",{\"1\":{\"72\":1}}],[\"本质上还是传递的是指针的副本\",{\"1\":{\"63\":1}}],[\"本身不是并发安全的\",{\"1\":{\"49\":1}}],[\"本身的变量中\",{\"1\":{\"11\":1}}],[\"表示拥有\",{\"1\":{\"82\":1}}],[\"表示一个事件的发生\",{\"1\":{\"77\":1}}],[\"表示如果该字段的值为空\",{\"1\":{\"75\":1}}],[\"表示如果该字段为空\",{\"1\":{\"74\":1}}],[\"表示在进行\",{\"1\":{\"75\":2}}],[\"表示在序列化和反序列化时忽略该字段\",{\"1\":{\"74\":1}}],[\"表示取该变量的地址\",{\"1\":{\"61\":1}}],[\"表示这是一个指针类型的变量\",{\"1\":{\"60\":1}}],[\"放在变量名前\",{\"1\":{\"60\":1,\"61\":1}}],[\"符号\",{\"1\":{\"60\":1,\"61\":1}}],[\"考虑以下结构体\",{\"1\":{\"78\":1}}],[\"考虑到这一点\",{\"1\":{\"59\":1}}],[\"考虑使用其他数据结构或转换策略来处理这些值\",{\"1\":{\"50\":1}}],[\"虽然在函数中也有所涉及\",{\"1\":{\"80\":1}}],[\"虽然在\",{\"1\":{\"64\":1}}],[\"虽然\",{\"1\":{\"59\":1}}],[\"虽然结构体字段可以是未导出的\",{\"1\":{\"40\":1}}],[\"赋值和作为参数或者返回值\",{\"1\":{\"82\":1}}],[\"赋值运算符\",{\"0\":{\"56\":1},\"1\":{\"58\":1}}],[\"赋给\",{\"1\":{\"58\":1}}],[\"先将\",{\"1\":{\"58\":1}}],[\"先计算\",{\"1\":{\"58\":1}}],[\"比较运算符\",{\"1\":{\"58\":1}}],[\"比较都不相等\",{\"1\":{\"50\":1}}],[\"位系统上\",{\"1\":{\"82\":2}}],[\"位于偏移量\",{\"1\":{\"78\":1}}],[\"位移运算符\",{\"1\":{\"58\":1}}],[\"位运算符\",{\"0\":{\"55\":1},\"1\":{\"58\":1}}],[\"乘性运算符\",{\"1\":{\"58\":1}}],[\"乘法运算符\",{\"1\":{\"58\":1}}],[\"乘法赋值\",{\"1\":{\"56\":1}}],[\"乘法\",{\"1\":{\"52\":1,\"58\":1}}],[\"负号\",{\"1\":{\"58\":1}}],[\"正号\",{\"1\":{\"58\":1}}],[\"正式学习\",{\"1\":{\"23\":1}}],[\"取地址符来获取指定变量的地址\",{\"1\":{\"82\":1}}],[\"取出指针并获取值\",{\"1\":{\"57\":1}}],[\"取址运算符\",{\"1\":{\"57\":1}}],[\"取模\",{\"1\":{\"52\":1,\"58\":1}}],[\"二进制\",{\"1\":{\"55\":7}}],[\"右移赋值\",{\"1\":{\"56\":1}}],[\"右移\",{\"1\":{\"55\":1,\"58\":1}}],[\"左移赋值\",{\"1\":{\"56\":1}}],[\"左移\",{\"1\":{\"55\":1,\"58\":1}}],[\"^=\",{\"1\":{\"56\":1,\"58\":1}}],[\"^\",{\"1\":{\"55\":2,\"58\":2}}],[\"按位取反\",{\"1\":{\"58\":1}}],[\"按位异或赋值\",{\"1\":{\"56\":1}}],[\"按位异或\",{\"1\":{\"55\":1,\"58\":1}}],[\"按位或赋值\",{\"1\":{\"56\":1}}],[\"按位或\",{\"1\":{\"55\":1,\"58\":1}}],[\"按位与赋值\",{\"1\":{\"56\":1}}],[\"按位与\",{\"1\":{\"55\":1,\"58\":1}}],[\"|=\",{\"1\":{\"56\":1,\"58\":1}}],[\"|\",{\"1\":{\"55\":2,\"58\":1}}],[\"||\",{\"1\":{\"54\":2,\"58\":1}}],[\"非\",{\"1\":{\"54\":1}}],[\"非常方便\",{\"1\":{\"27\":1}}],[\"逻辑或\",{\"1\":{\"58\":1}}],[\"逻辑与\",{\"1\":{\"58\":1}}],[\"逻辑非\",{\"1\":{\"58\":1}}],[\"逻辑运算符\",{\"0\":{\"54\":1},\"1\":{\"58\":2}}],[\"逻辑控制语句\",{\"0\":{\"41\":1}}],[\"小于等于\",{\"1\":{\"53\":1,\"58\":1}}],[\"小于\",{\"1\":{\"53\":1,\"58\":1}}],[\"小写字母开头\",{\"1\":{\"40\":1}}],[\"关系运算符\",{\"0\":{\"53\":1}}],[\"关键字即可\",{\"1\":{\"84\":1}}],[\"关键字来声明\",{\"1\":{\"83\":1}}],[\"关键字后没有表达式\",{\"1\":{\"43\":1}}],[\"关键字\",{\"1\":{\"30\":1,\"70\":1}}],[\"求余赋值\",{\"1\":{\"56\":1}}],[\"求余\",{\"1\":{\"52\":1}}],[\"除了\",{\"1\":{\"76\":1}}],[\"除了优先级外\",{\"1\":{\"58\":1}}],[\"除法赋值\",{\"1\":{\"56\":1}}],[\"除法\",{\"1\":{\"52\":1,\"58\":1}}],[\"除此之外\",{\"1\":{\"2\":1}}],[\"减法赋值\",{\"1\":{\"56\":1}}],[\"减法\",{\"1\":{\"52\":1,\"58\":1}}],[\"减少了学习和使用的难度\",{\"1\":{\"20\":1}}],[\"加\",{\"1\":{\"85\":1}}],[\"加性运算符\",{\"1\":{\"58\":1}}],[\"加法赋值\",{\"1\":{\"56\":1}}],[\"加法\",{\"1\":{\"52\":1,\"58\":1}}],[\"加载值\",{\"1\":{\"49\":1}}],[\"算术运算符\",{\"0\":{\"52\":1}}],[\"检查元素是否存在\",{\"1\":{\"77\":1}}],[\"检查\",{\"1\":{\"50\":1}}],[\"尝试使用另外一个\",{\"1\":{\"50\":1}}],[\"尝试使用\",{\"1\":{\"50\":1}}],[\"展示为什么不能使用\",{\"1\":{\"50\":1}}],[\"存储的内容都是指针\",{\"1\":{\"67\":1}}],[\"存储的是一个指向底层数组的指针\",{\"1\":{\"12\":1}}],[\"存储到内存中的值也必然会占用内存\",{\"1\":{\"66\":1}}],[\"存储值\",{\"1\":{\"49\":1}}],[\"零值\",{\"1\":{\"48\":1,\"75\":1,\"83\":1}}],[\"该示例定义了两个数据类型为\",{\"1\":{\"83\":1}}],[\"该示例定义了一个数据类型为\",{\"1\":{\"83\":1}}],[\"该长度为键值对的个数\",{\"1\":{\"48\":1}}],[\"该变量的作用域仅限于\",{\"1\":{\"43\":1}}],[\"获取变量的地址需要使用\",{\"1\":{\"61\":1}}],[\"获取变量地址\",{\"0\":{\"61\":1}}],[\"获取map长度\",{\"1\":{\"48\":1}}],[\"获取对应键的值\",{\"1\":{\"48\":1}}],[\"例如赋值运算符=\",{\"1\":{\"58\":1}}],[\"例如\",{\"1\":{\"48\":1,\"58\":2,\"76\":1,\"78\":2}}],[\"例如在一定时间内等待某个操作完成或者超时返回默认结果\",{\"1\":{\"45\":1}}],[\"操作符为\",{\"1\":{\"82\":1}}],[\"操作符\",{\"1\":{\"62\":1,\"72\":1}}],[\"操作的类型\",{\"1\":{\"48\":1}}],[\"操作map\",{\"0\":{\"48\":1}}],[\"操作到了底层数组\",{\"1\":{\"12\":1}}],[\"声明常量时初始化为\",{\"1\":{\"85\":1}}],[\"声明单个变量\",{\"1\":{\"83\":1}}],[\"声明结构体\",{\"0\":{\"70\":1}}],[\"声明指针\",{\"0\":{\"60\":1}}],[\"声明和初始化\",{\"0\":{\"47\":1}}],[\"声明方式\",{\"1\":{\"14\":1,\"15\":1}}],[\"遍历时的顺序不一定与插入顺序相同\",{\"1\":{\"48\":1}}],[\"遍历\",{\"1\":{\"46\":1,\"48\":1,\"49\":1}}],[\"遍历输出这个数组\",{\"1\":{\"5\":1}}],[\"插入和更新操作是相同的\",{\"1\":{\"48\":1}}],[\"插入和删除操作\",{\"1\":{\"46\":1}}],[\"插入或更新\",{\"1\":{\"48\":1}}],[\"插件\",{\"1\":{\"26\":1}}],[\"集合数据结构中的占位符\",{\"1\":{\"77\":1}}],[\"集合的长度\",{\"1\":{\"48\":1}}],[\"集合\",{\"0\":{\"46\":1}}],[\"上述的所有逻辑控制语句均可嵌套使用\",{\"1\":{\"45\":1}}],[\"上述代码将输出\",{\"1\":{\"44\":1}}],[\"上述代码将输出从\",{\"1\":{\"44\":1}}],[\"上述代码会输出\",{\"1\":{\"44\":1}}],[\"了解结构体在内存中的存储方式和对齐规则\",{\"1\":{\"78\":1}}],[\"了解并熟练使用\",{\"1\":{\"45\":1}}],[\"了解到这些之后\",{\"1\":{\"39\":1}}],[\"超时控制\",{\"1\":{\"45\":1}}],[\"接收信号\",{\"1\":{\"77\":1}}],[\"接收操作或者仅仅是用于阻塞当前\",{\"1\":{\"45\":1}}],[\"接口类型\",{\"1\":{\"48\":1}}],[\"接口\",{\"1\":{\"40\":1}}],[\"接口等\",{\"1\":{\"40\":1}}],[\"实际操作的是底层数据的地址\",{\"1\":{\"82\":1}}],[\"实际上就是这样\",{\"1\":{\"84\":1}}],[\"实际上变量的定义来源于数学\",{\"1\":{\"83\":1}}],[\"实际上是结构体指针\",{\"1\":{\"72\":1}}],[\"实际上这里只是重新定义了切片的范围\",{\"1\":{\"12\":1}}],[\"实际上这里是分两个步骤\",{\"1\":{\"5\":1}}],[\"实际上切片不存储数据\",{\"1\":{\"12\":1}}],[\"实际上此时的\",{\"1\":{\"10\":1}}],[\"实数和虚数类型\",{\"1\":{\"81\":1}}],[\"实现\",{\"1\":{\"49\":1}}],[\"实现不断地监听多个通道的消息\",{\"1\":{\"45\":1}}],[\"实例\",{\"1\":{\"47\":1}}],[\"准备好\",{\"1\":{\"45\":1}}],[\"同时声明多个常量时\",{\"1\":{\"84\":1}}],[\"同时声明多个变量\",{\"1\":{\"83\":1}}],[\"同时保证内存对齐\",{\"1\":{\"78\":1}}],[\"同时也限制了指针的使用\",{\"1\":{\"59\":1}}],[\"同时准备好\",{\"1\":{\"45\":1}}],[\"同理即可支持多维数组\",{\"1\":{\"7\":1}}],[\"执行\",{\"1\":{\"45\":1}}],[\"执行后的结果为\",{\"1\":{\"39\":1}}],[\"处理通信2的逻辑\",{\"1\":{\"45\":1}}],[\"处理通信1的逻辑\",{\"1\":{\"45\":1}}],[\"括起来\",{\"1\":{\"44\":1}}],[\"之后每声明一个常量则将\",{\"1\":{\"85\":1}}],[\"之后填充了\",{\"1\":{\"78\":1}}],[\"之间进行通信\",{\"1\":{\"82\":1}}],[\"之间需要\",{\"1\":{\"78\":1}}],[\"之外的条件表达式\",{\"1\":{\"44\":1}}],[\"之前首先需要安装配置好\",{\"1\":{\"23\":1}}],[\"注意事项\",{\"1\":{\"44\":1}}],[\"字节边界\",{\"1\":{\"78\":1}}],[\"字节且在\",{\"1\":{\"78\":1}}],[\"字节的边界\",{\"1\":{\"78\":3}}],[\"字面量简写形式实例化\",{\"1\":{\"71\":1}}],[\"字面量直接实例化\",{\"1\":{\"71\":1}}],[\"字符串类型\",{\"1\":{\"81\":1}}],[\"字符串\",{\"1\":{\"44\":1,\"48\":1}}],[\"字段和方法\",{\"1\":{\"40\":1}}],[\"然后将\",{\"1\":{\"58\":1}}],[\"然后再加上\",{\"1\":{\"58\":1}}],[\"然后退出循环\",{\"1\":{\"44\":1}}],[\"然后初始化\",{\"1\":{\"5\":1}}],[\"到\",{\"1\":{\"44\":2}}],[\"示例和内存布局\",{\"1\":{\"78\":1}}],[\"示例\",{\"1\":{\"44\":4,\"45\":1,\"50\":1}}],[\"每个字段都以适当的内存对齐方式存储\",{\"1\":{\"78\":1}}],[\"每个\",{\"1\":{\"45\":1}}],[\"每个特性提供了强大的工具来处理函数的定义\",{\"1\":{\"40\":1}}],[\"每次循环迭代后执行的操作\",{\"1\":{\"44\":1}}],[\"时\",{\"1\":{\"50\":1}}],[\"时返回的键值对的顺序是不确定的\",{\"1\":{\"46\":1}}],[\"时退出循环\",{\"1\":{\"44\":1}}],[\"时执行的代码块\",{\"1\":{\"43\":2}}],[\"时执行的语句\",{\"1\":{\"42\":6}}],[\"循环结合使用\",{\"1\":{\"45\":1}}],[\"循环没有括号\",{\"1\":{\"44\":1}}],[\"循环的三个部分\",{\"1\":{\"44\":1}}],[\"循环的条件判断表达式\",{\"1\":{\"44\":1}}],[\"循环来实现无限循环\",{\"1\":{\"44\":1}}],[\"循环模拟\",{\"1\":{\"44\":1}}],[\"循环开始前执行的初始化语句\",{\"1\":{\"44\":1}}],[\"循环体必须用大括号\",{\"1\":{\"44\":1}}],[\"循环体\",{\"1\":{\"44\":2}}],[\"循环\",{\"1\":{\"44\":5}}],[\"循环有三种基本形式\",{\"1\":{\"44\":1}}],[\"循环是一种常见的控制流结构\",{\"1\":{\"44\":1}}],[\"方便维护\",{\"1\":{\"43\":1}}],[\"方法和函数的却别\",{\"1\":{\"39\":1}}],[\"方法和函数的区别\",{\"1\":{\"39\":1}}],[\"方法的接收者分为\",{\"1\":{\"39\":1}}],[\"方法的三个参数依次为\",{\"1\":{\"10\":1}}],[\"方法拥有接收者\",{\"1\":{\"39\":1}}],[\"方法是定义在类型上的函数\",{\"1\":{\"39\":1}}],[\"方法\",{\"0\":{\"39\":1},\"1\":{\"11\":1,\"39\":1,\"77\":1}}],[\"方法进行初始化时\",{\"1\":{\"10\":1}}],[\"方法来创建切片\",{\"1\":{\"10\":1}}],[\"能够使得代码逻辑更加清晰\",{\"1\":{\"43\":1}}],[\"被分配为\",{\"1\":{\"43\":1}}],[\"被广泛应用于云计算平台和工具的开发\",{\"1\":{\"21\":1}}],[\"operator\",{\"1\":{\"82\":4}}],[\"optimizedstruct\",{\"1\":{\"78\":5}}],[\"orm\",{\"1\":{\"76\":1}}],[\"orresult\",{\"1\":{\"54\":1,\"55\":1}}],[\"omitempty\",{\"1\":{\"74\":2,\"75\":2}}],[\"ok\",{\"1\":{\"49\":2}}],[\"old\",{\"1\":{\"48\":1,\"49\":1}}],[\"offsetof\",{\"1\":{\"78\":6}}],[\"offset\",{\"1\":{\"78\":12}}],[\"of\",{\"1\":{\"43\":1,\"78\":16}}],[\"output\",{\"1\":{\"37\":1}}],[\"内存地址\",{\"1\":{\"82\":1}}],[\"内存布局优化\",{\"1\":{\"78\":1}}],[\"内存布局解释\",{\"1\":{\"78\":1}}],[\"内存优化\",{\"1\":{\"78\":1}}],[\"内存对齐实际上是一种用空间换时间的设计\",{\"1\":{\"78\":1}}],[\"内存对齐\",{\"1\":{\"78\":1}}],[\"内存消耗\",{\"1\":{\"77\":1}}],[\"内部\",{\"1\":{\"43\":1}}],[\"内置的数据类型一样\",{\"1\":{\"73\":1}}],[\"内置的数据类型\",{\"1\":{\"70\":1}}],[\"内置的数据结构\",{\"1\":{\"47\":1}}],[\"内置了许多功能\",{\"1\":{\"27\":1}}],[\"内置函数将元素附加到切片的末尾\",{\"1\":{\"11\":1}}],[\"带初始化语句的\",{\"1\":{\"43\":1}}],[\"<stdio\",{\"1\":{\"64\":1}}],[\"<<=\",{\"1\":{\"56\":1,\"58\":1}}],[\"<<\",{\"1\":{\"55\":2,\"58\":1}}],[\"<\",{\"1\":{\"43\":1,\"44\":1,\"45\":4,\"53\":2,\"58\":1,\"64\":1,\"77\":1,\"82\":3}}],[\"<=\",{\"1\":{\"35\":1,\"44\":1,\"53\":1,\"58\":1}}],[\">>=\",{\"1\":{\"56\":1,\"58\":1}}],[\">>\",{\"1\":{\"55\":2,\"58\":1}}],[\">=\",{\"1\":{\"53\":2,\"58\":1}}],[\">\",{\"1\":{\"43\":1,\"44\":1,\"53\":1,\"58\":1}}],[\"空结构体在\",{\"1\":{\"77\":1}}],[\"空结构体在信号传递\",{\"1\":{\"77\":1}}],[\"空结构体不消耗任何内存空间\",{\"1\":{\"77\":1}}],[\"空结构体可以嵌入到其他结构体中\",{\"1\":{\"77\":1}}],[\"空结构体可以作为一种占位符\",{\"1\":{\"77\":1}}],[\"空结构体可以用于将方法注入到其他结构体中\",{\"1\":{\"77\":1}}],[\"空结构体可以用作\",{\"1\":{\"77\":2}}],[\"空结构体通常用于以下几种场景\",{\"1\":{\"77\":1}}],[\"空结构体的声明如下\",{\"1\":{\"77\":1}}],[\"空结构体\",{\"0\":{\"77\":1},\"1\":{\"77\":1}}],[\"空\",{\"1\":{\"43\":1}}],[\"空指针时执行\",{\"1\":{\"65\":1}}],[\"空指针判断\",{\"1\":{\"65\":1}}],[\"空指针\",{\"0\":{\"65\":1},\"1\":{\"10\":1}}],[\"用来存储其他变量的内存地址\",{\"1\":{\"59\":1}}],[\"用于声明一个\",{\"1\":{\"82\":1}}],[\"用于声明一个指向类型\",{\"1\":{\"82\":1}}],[\"用于在\",{\"1\":{\"82\":1}}],[\"用于组织不同类型的字段\",{\"1\":{\"82\":1}}],[\"用于构建集合数据结构\",{\"1\":{\"77\":1}}],[\"用于\",{\"1\":{\"76\":3}}],[\"用于提供给反射等工具以获取结构体字段的额外信息\",{\"1\":{\"74\":1}}],[\"用于存储键值对\",{\"1\":{\"46\":1}}],[\"用于存储相同类型\",{\"1\":{\"8\":1}}],[\"用于迭代数组\",{\"1\":{\"44\":1}}],[\"用于重复执行一段代码块\",{\"1\":{\"44\":1}}],[\"用逗号分隔\",{\"1\":{\"43\":1}}],[\"来取出指针所指向的地址的值\",{\"1\":{\"82\":1}}],[\"来保护\",{\"1\":{\"49\":1}}],[\"来实现同样的效果\",{\"1\":{\"44\":1}}],[\"来终止\",{\"1\":{\"43\":1}}],[\"来创建一个切片\",{\"1\":{\"6\":1}}],[\"块\",{\"1\":{\"43\":1}}],[\"特殊情况nan\",{\"0\":{\"50\":1}}],[\"特点与注意事项\",{\"1\":{\"43\":1,\"45\":1}}],[\"特别是用于从多个通信通道中选择和执行不同的\",{\"1\":{\"45\":1}}],[\"特别是在使用和传递时的行为有所不同\",{\"1\":{\"13\":1}}],[\"特别适合需要持久化状态或者捕获动态变化的场景\",{\"1\":{\"34\":1}}],[\"当做变量或常量使用\",{\"1\":{\"85\":1}}],[\"当一个指针被定义后没有分配到任何变量的时候\",{\"1\":{\"65\":1}}],[\"当其作为\",{\"1\":{\"50\":1}}],[\"当需要从多个通道中接收消息时\",{\"1\":{\"45\":1}}],[\"当没有任何通信情况发生时执行的逻辑\",{\"1\":{\"45\":1}}],[\"当条件为\",{\"1\":{\"44\":1}}],[\"当所有\",{\"1\":{\"43\":1}}],[\"当\",{\"1\":{\"43\":2}}],[\"当将数组作为参数传递给函数时\",{\"1\":{\"14\":1}}],[\"当将切片作为参数传递给函数时\",{\"1\":{\"12\":1}}],[\"替代多个\",{\"1\":{\"43\":1}}],[\"辅助函数\",{\"1\":{\"40\":1}}],[\"所以可以定义一个工厂函数来创建对象\",{\"1\":{\"71\":1}}],[\"所以通过地址来操作数据时\",{\"1\":{\"63\":1}}],[\"所以我们可以像迭代数组和切片那样迭代它\",{\"1\":{\"46\":1}}],[\"所以在声明阶段就尽可能的给定一个可能会用到的容量\",{\"1\":{\"10\":1}}],[\"所有访问控制以包为基本单位\",{\"1\":{\"40\":1}}],[\"包含了字段和填充字节\",{\"1\":{\"78\":1}}],[\"包\",{\"1\":{\"64\":1}}],[\"包进行指针运算\",{\"1\":{\"64\":1}}],[\"包括它自己\",{\"1\":{\"50\":2}}],[\"包括变量\",{\"1\":{\"40\":1}}],[\"包为单位\",{\"1\":{\"40\":1}}],[\"避免了复杂的访问控制规则\",{\"1\":{\"40\":1}}],[\"简单赋值\",{\"1\":{\"56\":1,\"58\":1}}],[\"简单易读\",{\"1\":{\"20\":1}}],[\"简洁性\",{\"1\":{\"40\":1}}],[\"明确性\",{\"1\":{\"40\":1}}],[\"主要关注于包级别的访问限制\",{\"1\":{\"40\":1}}],[\"主要包括\",{\"1\":{\"21\":1}}],[\"未初始化的\",{\"1\":{\"48\":1}}],[\"未导出\",{\"1\":{\"40\":1}}],[\"未知数组长度\",{\"1\":{\"5\":1}}],[\"导出\",{\"1\":{\"40\":1}}],[\"导致栈溢出\",{\"1\":{\"35\":1}}],[\"大于等于\",{\"1\":{\"53\":1,\"58\":1}}],[\"大于\",{\"1\":{\"53\":1,\"58\":1}}],[\"大写字母开头\",{\"1\":{\"40\":1}}],[\"大大提高开发效率\",{\"1\":{\"25\":1}}],[\"作为信号传递的占位符\",{\"1\":{\"77\":1}}],[\"作为参数\",{\"0\":{\"63\":1}}],[\"作为参数传递\",{\"1\":{\"48\":1}}],[\"作为参数传递时会传递数组的副本\",{\"1\":{\"39\":1}}],[\"作为键来获取值\",{\"1\":{\"50\":1}}],[\"作为键\",{\"1\":{\"50\":1}}],[\"作为\",{\"1\":{\"50\":3,\"75\":1}}],[\"作为特殊情况\",{\"1\":{\"11\":1}}],[\"对齐意味着字段的起始地址必须是其类型大小的倍数\",{\"1\":{\"78\":1}}],[\"对象方法\",{\"1\":{\"39\":1}}],[\"对应的也会造成原值的改变\",{\"1\":{\"39\":1}}],[\"对切片的操作是通过该指针来进行的\",{\"1\":{\"39\":1}}],[\"对于调试开发更为优雅舒适\",{\"1\":{\"27\":1}}],[\"对于希望构建高性能\",{\"1\":{\"22\":1}}],[\"原因是指针运算比较危险\",{\"1\":{\"64\":1}}],[\"原因如下\",{\"1\":{\"39\":1}}],[\"原数据也会发生改变\",{\"1\":{\"63\":1}}],[\"原切片中的指针指向的还是原来的底层数组\",{\"1\":{\"12\":1}}],[\"原切片底层的存储数组没有发生变化\",{\"1\":{\"12\":1}}],[\"都是传递对应的副本\",{\"1\":{\"73\":1}}],[\"都是可选的\",{\"1\":{\"44\":1}}],[\"都会随机选择一个满足条件的\",{\"1\":{\"45\":1}}],[\"都不满足时执行\",{\"1\":{\"45\":1}}],[\"都不匹配时执行的代码块\",{\"1\":{\"43\":1}}],[\"都描述了一个通信操作\",{\"1\":{\"45\":1}}],[\"都为\",{\"1\":{\"42\":1}}],[\"都可以修改内部的值\",{\"1\":{\"39\":1}}],[\"都能提供强大的支持\",{\"1\":{\"22\":1}}],[\"转换为了\",{\"1\":{\"39\":1}}],[\"帮我们做了引用\",{\"1\":{\"39\":1}}],[\"为了解决这个问题\",{\"1\":{\"83\":1}}],[\"为了减少结构体的内存占用\",{\"1\":{\"78\":1}}],[\"为了对齐\",{\"1\":{\"78\":1}}],[\"为了满足对齐要求\",{\"1\":{\"78\":1}}],[\"为了提高内存访问效率\",{\"1\":{\"78\":1}}],[\"为了避免这种情况\",{\"1\":{\"50\":1}}],[\"为了成功匹配接收者的类型\",{\"1\":{\"39\":1}}],[\"为\",{\"1\":{\"42\":5}}],[\"为你自己下载安装的对应目录即可\",{\"1\":{\"27\":1}}],[\"此时再通过该指针来修改形参\",{\"1\":{\"39\":1}}],[\"此时即便我们没有使用指针调用\",{\"1\":{\"39\":1}}],[\"此时成功的修改了\",{\"1\":{\"39\":1}}],[\"此时虽然通过实际的数组指针修改了底层数组\",{\"1\":{\"12\":1}}],[\"解决方案\",{\"1\":{\"50\":1}}],[\"解决软件工程中的常见问题\",{\"1\":{\"19\":1}}],[\"解析为\",{\"1\":{\"39\":1}}],[\"自由度较高\",{\"1\":{\"64\":1}}],[\"自定义类型\",{\"1\":{\"50\":1}}],[\"自行进行进行了解引用操作\",{\"1\":{\"39\":1}}],[\"自带的\",{\"1\":{\"27\":1}}],[\"事实上\",{\"1\":{\"39\":1}}],[\"成倍后\",{\"1\":{\"39\":8}}],[\"成为现代软件开发中的一颗新星\",{\"1\":{\"22\":1}}],[\"成为微服务架构的首选语言之一\",{\"1\":{\"21\":1}}],[\"z\",{\"1\":{\"39\":6}}],[\"zero\",{\"1\":{\"38\":1,\"43\":1}}],[\"初始化单个变量\",{\"1\":{\"83\":1}}],[\"初始化列表中的元素个数超过数组声明的长度\",{\"1\":{\"5\":1}}],[\"初始\",{\"1\":{\"39\":8}}],[\"两种类型\",{\"1\":{\"39\":1}}],[\"两者的区别请参考\",{\"1\":{\"71\":1}}],[\"两者也可同时兼备\",{\"1\":{\"27\":1}}],[\"两者几乎类似\",{\"1\":{\"2\":1}}],[\"值\",{\"1\":{\"82\":1}}],[\"值结构体不能\",{\"1\":{\"73\":1}}],[\"值的类型\",{\"1\":{\"48\":1}}],[\"值接收者\",{\"1\":{\"39\":2}}],[\"值传递的数据结构\",{\"1\":{\"17\":1}}],[\"值传递\",{\"1\":{\"14\":1}}],[\"说明了切片这种数据类型底层实际上存储了指向切片的指针\",{\"1\":{\"39\":1}}],[\"说明方法属于该接收者\",{\"1\":{\"39\":1}}],[\"说明数组和切片在传递和使用时的区别\",{\"1\":{\"16\":1}}],[\"错误处理\",{\"0\":{\"38\":1},\"1\":{\"38\":1}}],[\"类似的辅助函数\",{\"1\":{\"40\":1}}],[\"类似于\",{\"1\":{\"39\":1,\"44\":1}}],[\"类似于栈\",{\"1\":{\"37\":1}}],[\"类方法\",{\"1\":{\"39\":1}}],[\"类型开关\",{\"1\":{\"43\":1}}],[\"类型\",{\"1\":{\"40\":1,\"78\":2,\"82\":1}}],[\"类型的管道变量\",{\"1\":{\"82\":1}}],[\"类型的数据\",{\"1\":{\"82\":1}}],[\"类型的变量\",{\"1\":{\"82\":1}}],[\"类型的字段必须对齐到\",{\"1\":{\"78\":2}}],[\"类型的\",{\"1\":{\"39\":1}}],[\"类型的零值是\",{\"1\":{\"48\":2}}],[\"类型的零值\",{\"1\":{\"5\":1}}],[\"类型进行错误处理\",{\"1\":{\"38\":1}}],[\"延迟执行\",{\"0\":{\"37\":1},\"1\":{\"37\":1}}],[\"递归\",{\"1\":{\"35\":1}}],[\"递归函数\",{\"0\":{\"35\":1}}],[\"区别\",{\"1\":{\"34\":1}}],[\"闭包是指一个函数值\",{\"1\":{\"34\":1}}],[\"闭包\",{\"0\":{\"34\":1},\"1\":{\"34\":1}}],[\"闭包等方面的详细说明\",{\"1\":{\"28\":1}}],[\"使得\",{\"1\":{\"78\":1}}],[\"使得返回值在函数体内被赋值时无需显示\",{\"1\":{\"31\":1}}],[\"使代码更加简洁和易读\",{\"1\":{\"43\":1}}],[\"使用空结构体嵌入其他结构体中\",{\"1\":{\"77\":1}}],[\"使用空结构体作为\",{\"1\":{\"77\":2}}],[\"使用空结构体作为信号传递的占位符\",{\"1\":{\"77\":1}}],[\"使用取地址符号实例化\",{\"1\":{\"71\":1}}],[\"使用指针算术运算访问数组的特定元素\",{\"1\":{\"64\":1}}],[\"使用指针遍历数组\",{\"1\":{\"64\":1}}],[\"使用闭包可以实现状态的保持和管理\",{\"1\":{\"34\":1}}],[\"使用匿名函数可以简化代码结构\",{\"1\":{\"34\":1}}],[\"使用场景\",{\"1\":{\"34\":1,\"45\":1}}],[\"使用\",{\"1\":{\"26\":1,\"44\":1,\"48\":2,\"50\":1,\"64\":1,\"71\":1,\"75\":1,\"82\":1}}],[\"使用流行的框架如\",{\"1\":{\"21\":1}}],[\"使用的方法和数组完全相同\",{\"1\":{\"11\":1}}],[\"命名返回值\",{\"1\":{\"31\":1}}],[\"等数据格式的映射\",{\"1\":{\"76\":1}}],[\"等同于\",{\"1\":{\"56\":1}}],[\"等\",{\"1\":{\"48\":1}}],[\"等于\",{\"1\":{\"43\":2,\"53\":1,\"58\":1}}],[\"等语言中函数只能返回一个值不同\",{\"1\":{\"31\":1}}],[\"等操作系统\",{\"1\":{\"20\":1}}],[\"quotient\",{\"1\":{\"31\":2,\"52\":1}}],[\"多路复用通信\",{\"1\":{\"45\":1}}],[\"多个变量\",{\"1\":{\"84\":1}}],[\"多个匹配条件\",{\"1\":{\"43\":1}}],[\"多个\",{\"1\":{\"37\":1}}],[\"多返回值函数\",{\"1\":{\"31\":1}}],[\"多参数函数\",{\"1\":{\"31\":1}}],[\"yaml\",{\"1\":{\"76\":4}}],[\"years\",{\"1\":{\"48\":1,\"49\":1}}],[\"y\",{\"1\":{\"31\":5,\"36\":2,\"38\":3,\"39\":6,\"63\":8}}],[\"xml映射等\",{\"1\":{\"74\":1}}],[\"xorresult\",{\"1\":{\"55\":1}}],[\"x\",{\"1\":{\"31\":5,\"34\":2,\"36\":2,\"38\":2,\"39\":34,\"43\":10,\"63\":8}}],[\"rightshift\",{\"1\":{\"55\":1}}],[\"rwmutex\",{\"1\":{\"49\":1}}],[\"r\",{\"1\":{\"39\":5}}],[\"range\",{\"1\":{\"32\":1,\"44\":4,\"48\":1,\"49\":1,\"77\":1}}],[\"readperson\",{\"1\":{\"73\":6}}],[\"received\",{\"1\":{\"45\":3}}],[\"rect\",{\"1\":{\"39\":2}}],[\"rectangle\",{\"1\":{\"39\":5}}],[\"rectanglearea\",{\"1\":{\"31\":1}}],[\"remainder\",{\"1\":{\"31\":2,\"52\":1}}],[\"result\",{\"1\":{\"30\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":4,\"38\":1}}],[\"return\",{\"1\":{\"30\":1,\"31\":4,\"32\":1,\"33\":1,\"34\":2,\"35\":2,\"36\":3,\"38\":2,\"39\":1,\"49\":1,\"64\":1,\"71\":1,\"74\":2,\"82\":1}}],[\"rob\",{\"1\":{\"19\":1}}],[\"robert\",{\"1\":{\"19\":1}}],[\"匿名函数是指没有名称的函数\",{\"1\":{\"34\":1}}],[\"匿名函数和闭包有啥区别\",{\"1\":{\"34\":1}}],[\"匿名函数可以访问其外层作用域中的变量\",{\"1\":{\"34\":1}}],[\"匿名函数\",{\"0\":{\"33\":1},\"1\":{\"28\":1,\"33\":1}}],[\"返回该类型的零值\",{\"1\":{\"48\":1}}],[\"返回值变量\",{\"1\":{\"80\":1}}],[\"返回值等\",{\"1\":{\"80\":1}}],[\"返回值以及高级用法\",{\"1\":{\"40\":1}}],[\"返回值类型\",{\"1\":{\"30\":1}}],[\"返回值\",{\"1\":{\"28\":1}}],[\"返回更新的切片\",{\"1\":{\"11\":1}}],[\"参数传递\",{\"1\":{\"40\":1}}],[\"参数类型可以相同或不同\",{\"1\":{\"31\":1}}],[\"参数与返回值\",{\"0\":{\"31\":1}}],[\"参数列表\",{\"1\":{\"30\":1}}],[\"参数\",{\"1\":{\"28\":1,\"80\":1}}],[\"调用嵌入的\",{\"1\":{\"77\":1}}],[\"调用时需要使用到该接收者\",{\"1\":{\"39\":1}}],[\"调用根据后进先出的顺序执行\",{\"1\":{\"37\":1}}],[\"调用\",{\"1\":{\"28\":1,\"40\":1}}],[\"不仅难度高\",{\"1\":{\"83\":1}}],[\"不仅可以当做代码的封装\",{\"1\":{\"28\":1}}],[\"不必我们手动实现\",{\"1\":{\"72\":1}}],[\"不能直接把\",{\"1\":{\"85\":1}}],[\"不能直接存储键值对\",{\"1\":{\"48\":1}}],[\"不能使用\",{\"1\":{\"71\":1}}],[\"不要使用\",{\"1\":{\"50\":1}}],[\"不等于\",{\"1\":{\"50\":1,\"53\":1,\"58\":1}}],[\"不等于任何值\",{\"1\":{\"50\":1}}],[\"不过\",{\"1\":{\"46\":1,\"64\":1,\"82\":1}}],[\"不需要像\",{\"1\":{\"43\":1}}],[\"不会影响原有的值\",{\"1\":{\"39\":1}}],[\"不会改变原有的数组值\",{\"1\":{\"7\":1}}],[\"不管调用者是不是指针\",{\"1\":{\"39\":1}}],[\"不同的是\",{\"1\":{\"28\":1}}],[\"jsonstr\",{\"1\":{\"74\":2}}],[\"jsondata\",{\"1\":{\"74\":2}}],[\"json\",{\"1\":{\"74\":8,\"75\":6,\"76\":1}}],[\"json序列化\",{\"1\":{\"74\":1}}],[\"j\",{\"1\":{\"57\":1,\"63\":3,\"82\":2,\"85\":2}}],[\"java\",{\"1\":{\"28\":1,\"31\":1,\"39\":3,\"43\":1,\"71\":1}}],[\"jetbrains\",{\"1\":{\"27\":1}}],[\"与任何值\",{\"1\":{\"50\":1}}],[\"与其他编程语言不同\",{\"1\":{\"44\":1}}],[\"与\",{\"1\":{\"28\":1,\"54\":1,\"71\":1}}],[\"选择合适自己的开发工具即可\",{\"1\":{\"27\":1}}],[\"选择适合自己的版本进行下载即可\",{\"1\":{\"24\":1}}],[\"各有优缺\",{\"1\":{\"27\":1}}],[\"开关\",{\"1\":{\"43\":1}}],[\"开箱即用\",{\"1\":{\"27\":1}}],[\"开发工具\",{\"0\":{\"25\":1}}],[\"开发\",{\"1\":{\"21\":1,\"22\":1}}],[\"开发的一种开源编程语言\",{\"1\":{\"19\":1}}],[\"无序\",{\"1\":{\"48\":1}}],[\"无限循环体\",{\"1\":{\"44\":1}}],[\"无限循环\",{\"1\":{\"44\":1}}],[\"无需使用\",{\"1\":{\"43\":1}}],[\"无需精神内耗\",{\"1\":{\"27\":1}}],[\"无需其他配置\",{\"1\":{\"27\":1}}],[\"无论是传递指针结构体还是值结构体\",{\"1\":{\"73\":1}}],[\"无论是\",{\"1\":{\"22\":1}}],[\"功能全靠插件\",{\"1\":{\"27\":1}}],[\"功能\",{\"1\":{\"27\":1}}],[\"较为麻烦\",{\"1\":{\"27\":1}}],[\"需要对齐到\",{\"1\":{\"78\":1}}],[\"需要对其进行查找操作\",{\"1\":{\"50\":1}}],[\"需要在\",{\"1\":{\"78\":1}}],[\"需要熟练掌握\",{\"1\":{\"40\":1}}],[\"需要自己配置安装\",{\"1\":{\"27\":1}}],[\"需要配置插件\",{\"1\":{\"27\":1}}],[\"需要借助\",{\"1\":{\"11\":1}}],[\"且仅接受\",{\"1\":{\"82\":1}}],[\"且必须按照声明的顺序初始化\",{\"1\":{\"71\":1}}],[\"且只有自定义类型能够拥有方法\",{\"1\":{\"39\":1}}],[\"且有\",{\"1\":{\"27\":1}}],[\"且价格较高\",{\"1\":{\"27\":1}}],[\"且存储的数据类型相同\",{\"1\":{\"3\":1}}],[\"版本收费\",{\"1\":{\"27\":1}}],[\"url\",{\"1\":{\"84\":1}}],[\"uint64\",{\"1\":{\"81\":1}}],[\"uint32\",{\"1\":{\"81\":1}}],[\"uint16\",{\"1\":{\"81\":1}}],[\"uint8\",{\"1\":{\"81\":1}}],[\"uint\",{\"1\":{\"81\":1}}],[\"uintptr\",{\"1\":{\"12\":1}}],[\"user\",{\"1\":{\"76\":1}}],[\"using\",{\"1\":{\"64\":1}}],[\"unmarshalling\",{\"1\":{\"74\":1}}],[\"unmarshal\",{\"1\":{\"74\":1}}],[\"unsafe\",{\"1\":{\"64\":2,\"77\":2,\"78\":10}}],[\"unknown\",{\"1\":{\"43\":1}}],[\"unexported\",{\"1\":{\"40\":1}}],[\"unlimited\",{\"1\":{\"27\":1}}],[\"免费开源\",{\"1\":{\"27\":1}}],[\"仅获取对应键的值\",{\"1\":{\"48\":1}}],[\"仅在包内可见\",{\"1\":{\"40\":1}}],[\"仅对\",{\"1\":{\"27\":1}}],[\"仅声明\",{\"1\":{\"5\":1}}],[\"还提供了一种简化变量声明和初始化的语法糖\",{\"1\":{\"83\":1}}],[\"还提供了一种特殊的\",{\"1\":{\"44\":1}}],[\"还有其他常见的标签\",{\"1\":{\"76\":1}}],[\"还有一些运算符是右结合的\",{\"1\":{\"58\":1}}],[\"还可以当做变量\",{\"1\":{\"28\":1}}],[\"还可开发其他任意语言\",{\"1\":{\"27\":1}}],[\"还是系统编程和数据处理\",{\"1\":{\"22\":1}}],[\"还是不会展现出任何变化\",{\"1\":{\"12\":1}}],[\"还是根据这个容量来限制呢\",{\"1\":{\"10\":1}}],[\"轻量级\",{\"1\":{\"27\":1}}],[\"轻松处理大量并发任务\",{\"1\":{\"20\":1}}],[\"优缺点对比\",{\"1\":{\"27\":1}}],[\"也无法与其他类型转换\",{\"1\":{\"81\":1}}],[\"也无法直接参与数值运算\",{\"1\":{\"81\":1}}],[\"也可将\",{\"1\":{\"85\":1}}],[\"也可使用字面量进行初始化\",{\"1\":{\"47\":1}}],[\"也可以使用结构体类型\",{\"1\":{\"70\":1}}],[\"也可以作为参数进行传递\",{\"1\":{\"28\":1}}],[\"也可以配置我们自己下载的\",{\"1\":{\"27\":1}}],[\"也必须熟练掌握\",{\"1\":{\"45\":1}}],[\"也会有地址\",{\"1\":{\"66\":1}}],[\"也会造成原值的变化\",{\"1\":{\"39\":1}}],[\"也会反应在原切片上\",{\"1\":{\"12\":1}}],[\"也是将指针的内容复制一份传递\",{\"1\":{\"39\":1}}],[\"也就是将原来的值复制一份传递\",{\"1\":{\"39\":1}}],[\"配置\",{\"1\":{\"26\":1,\"27\":2}}],[\"配置变量\",{\"1\":{\"24\":1}}],[\"v\",{\"1\":{\"43\":4,\"50\":4,\"82\":1}}],[\"visualstudio\",{\"1\":{\"26\":1}}],[\"vscode\",{\"0\":{\"26\":1},\"1\":{\"25\":1,\"26\":1,\"27\":5}}],[\"val\",{\"1\":{\"50\":4}}],[\"value\",{\"1\":{\"44\":5,\"47\":1,\"49\":2,\"50\":4}}],[\"value2\",{\"1\":{\"43\":2}}],[\"value1\",{\"1\":{\"43\":2}}],[\"values\",{\"1\":{\"5\":1}}],[\"variablename\",{\"1\":{\"83\":1}}],[\"variablename4\",{\"1\":{\"70\":2}}],[\"variablename3\",{\"1\":{\"70\":2}}],[\"variablename2\",{\"1\":{\"70\":2,\"83\":2}}],[\"variablename1\",{\"1\":{\"70\":2,\"83\":2}}],[\"var\",{\"1\":{\"4\":1,\"5\":4,\"6\":2,\"9\":1,\"10\":2,\"14\":1,\"15\":1,\"39\":9,\"43\":1,\"47\":1,\"49\":1,\"57\":6,\"60\":1,\"61\":1,\"63\":1,\"65\":1,\"66\":2,\"73\":1,\"74\":1,\"77\":1,\"78\":2,\"82\":9,\"83\":6}}],[\"一次性初始化多个变量\",{\"1\":{\"83\":1}}],[\"一个指向整数类型的指针变量\",{\"1\":{\"60\":1}}],[\"一个好的开发工具能让你事半功倍\",{\"1\":{\"25\":1}}],[\"一元运算符\",{\"1\":{\"58\":1}}],[\"一旦初始化\",{\"1\":{\"2\":1}}],[\"必先利其器\",{\"1\":{\"25\":1}}],[\"请重启电脑使得环境变量生效即可\",{\"1\":{\"24\":1}}],[\"仍无法通过\",{\"1\":{\"24\":1}}],[\"h>\",{\"1\":{\"64\":1}}],[\"height\",{\"1\":{\"31\":2,\"39\":2,\"48\":1}}],[\"hello\",{\"1\":{\"11\":1,\"37\":2,\"43\":1}}],[\"https\",{\"1\":{\"24\":2,\"26\":1,\"27\":1,\"84\":1}}],[\"下面是一段\",{\"1\":{\"64\":1}}],[\"下面是一个简单的示例\",{\"1\":{\"16\":1}}],[\"下载\",{\"1\":{\"27\":1}}],[\"下载后安装即可\",{\"1\":{\"27\":1}}],[\"下载好后安装即可\",{\"1\":{\"26\":1}}],[\"下载安装\",{\"1\":{\"26\":1,\"27\":1}}],[\"下载地址\",{\"1\":{\"24\":1}}],[\"跳过即可\",{\"1\":{\"23\":1}}],[\"环境检查\",{\"1\":{\"24\":1}}],[\"环境\",{\"1\":{\"23\":1}}],[\"环境配置\",{\"0\":{\"23\":1}}],[\"高并发应用的开发者来说\",{\"1\":{\"22\":1}}],[\"高效和强大的并发处理能力\",{\"1\":{\"22\":1}}],[\"高性能\",{\"1\":{\"20\":1}}],[\"结合\",{\"1\":{\"45\":1}}],[\"结构\",{\"1\":{\"43\":1}}],[\"结构体字段直接存储在结构体内存块中\",{\"1\":{\"82\":1}}],[\"结构体可以包含指针字段\",{\"1\":{\"82\":1}}],[\"结构体是一个聚合数据类型\",{\"1\":{\"82\":1}}],[\"结构体是由一系列具有相同类型或不同类型的数据构成的数据集合\",{\"1\":{\"69\":1}}],[\"结构体的大小可能会更小\",{\"1\":{\"78\":1}}],[\"结构体的存储\",{\"0\":{\"78\":1}}],[\"结构体标签解释\",{\"0\":{\"75\":1}}],[\"结构体标签使用案例\",{\"1\":{\"74\":1}}],[\"结构体标签的具体使用如下\",{\"1\":{\"74\":1}}],[\"结构体标签\",{\"0\":{\"74\":1}}],[\"结构体做参数时\",{\"1\":{\"73\":1}}],[\"结构体指针做参数\",{\"1\":{\"73\":1}}],[\"结构体值做参数\",{\"1\":{\"73\":1}}],[\"结构体作为参数\",{\"0\":{\"73\":1}}],[\"结构体为例\",{\"1\":{\"72\":1}}],[\"结构体内部的字段名也遵循首字母大小写命名暴露的方式\",{\"1\":{\"70\":1}}],[\"结构体中不仅可以使用\",{\"1\":{\"70\":1}}],[\"结构体定义需要使用\",{\"1\":{\"70\":1}}],[\"结构体成员访问\",{\"1\":{\"57\":1}}],[\"结构体类型也能作为参数传递给函数\",{\"1\":{\"73\":1}}],[\"结构体类型\",{\"1\":{\"50\":1,\"82\":1}}],[\"结构体\",{\"0\":{\"69\":1},\"1\":{\"40\":1,\"48\":1}}],[\"结论\",{\"0\":{\"22\":1}}],[\"结果是依然没有变化\",{\"1\":{\"12\":1}}],[\"结果为\",{\"1\":{\"5\":1}}],[\"系统编程\",{\"1\":{\"21\":1}}],[\"k\",{\"1\":{\"82\":1,\"85\":2}}],[\"key\",{\"1\":{\"47\":1,\"49\":2,\"50\":5,\"76\":1,\"77\":2}}],[\"ken\",{\"1\":{\"19\":1}}],[\"kubernetes\",{\"1\":{\"21\":1}}],[\"diff\",{\"1\":{\"52\":1}}],[\"division\",{\"1\":{\"38\":1}}],[\"divide\",{\"1\":{\"31\":2,\"38\":2}}],[\"delete\",{\"1\":{\"48\":2}}],[\"default\",{\"1\":{\"43\":5,\"45\":6}}],[\"defer\",{\"1\":{\"37\":3}}],[\"d\",{\"1\":{\"44\":2,\"48\":1,\"49\":1,\"63\":4,\"64\":3,\"73\":2,\"78\":8}}],[\"dave\",{\"1\":{\"71\":1}}],[\"david\",{\"1\":{\"48\":3}}],[\"day\",{\"1\":{\"43\":1}}],[\"dataslice\",{\"1\":{\"12\":12}}],[\"data\",{\"1\":{\"12\":1}}],[\"data3\",{\"1\":{\"5\":1}}],[\"data2\",{\"1\":{\"5\":1}}],[\"data1\",{\"1\":{\"5\":1}}],[\"datatype4\",{\"1\":{\"70\":1}}],[\"datatype3\",{\"1\":{\"70\":1}}],[\"datatype2\",{\"1\":{\"70\":1}}],[\"datatype1\",{\"1\":{\"70\":2}}],[\"datatype\",{\"1\":{\"4\":1,\"5\":2,\"70\":1}}],[\"done\",{\"1\":{\"77\":3}}],[\"double\",{\"1\":{\"34\":2,\"39\":10}}],[\"doc\",{\"1\":{\"24\":1}}],[\"docker\",{\"1\":{\"21\":1}}],[\"dl\",{\"1\":{\"24\":1}}],[\"云计算\",{\"1\":{\"21\":1,\"22\":1}}],[\"微服务架构\",{\"1\":{\"21\":1,\"22\":1}}],[\"服务\",{\"1\":{\"21\":1}}],[\"banana\",{\"1\":{\"77\":1}}],[\"bson\",{\"1\":{\"76\":3}}],[\"be\",{\"1\":{\"74\":1}}],[\"beego\",{\"1\":{\"21\":1}}],[\"bool\",{\"1\":{\"49\":1,\"50\":1,\"77\":1,\"78\":4,\"81\":1}}],[\"bob\",{\"1\":{\"47\":1,\"48\":3,\"49\":1,\"71\":1,\"74\":2}}],[\"break\",{\"1\":{\"43\":2,\"44\":1}}],[\"by\",{\"1\":{\"38\":1}}],[\"bytes\",{\"1\":{\"78\":10}}],[\"byte\",{\"1\":{\"11\":2,\"74\":1,\"78\":3}}],[\"b\",{\"1\":{\"30\":3,\"33\":2,\"36\":2,\"52\":6,\"53\":5,\"55\":4,\"56\":3,\"58\":5,\"78\":15,\"82\":3}}],[\"由于\",{\"1\":{\"45\":1,\"47\":1}}],[\"由于其高并发处理能力和小内存占用\",{\"1\":{\"21\":1}}],[\"由于其高性能和简洁性\",{\"1\":{\"21\":1}}],[\"由于扩容的性能消耗\",{\"1\":{\"10\":1}}],[\"编码解码等常见功能\",{\"1\":{\"20\":1}}],[\"编译器可能会在字段之间插入一些填充字节\",{\"1\":{\"78\":1}}],[\"编译器会根据元素个数自行推断数组的长度\",{\"1\":{\"5\":1}}],[\"编译后的二进制文件执行速度快\",{\"1\":{\"20\":1}}],[\"编译错误\",{\"1\":{\"5\":1}}],[\"文件系统\",{\"1\":{\"20\":1}}],[\"涵盖网络\",{\"1\":{\"20\":1}}],[\"丰富的标准库\",{\"1\":{\"20\":1}}],[\"log\",{\"1\":{\"77\":3}}],[\"logger\",{\"1\":{\"77\":4}}],[\"load\",{\"1\":{\"49\":1}}],[\"leftshift\",{\"1\":{\"55\":1}}],[\"len\",{\"1\":{\"5\":1,\"11\":1,\"12\":3,\"48\":2}}],[\"linux\",{\"1\":{\"20\":1}}],[\"while\",{\"1\":{\"44\":4}}],[\"weekday\",{\"1\":{\"43\":1}}],[\"weekend\",{\"1\":{\"43\":1}}],[\"web\",{\"1\":{\"21\":2,\"22\":1}}],[\"will\",{\"1\":{\"74\":1}}],[\"width\",{\"1\":{\"31\":2,\"39\":2}}],[\"windows\",{\"1\":{\"20\":1}}],[\"www\",{\"1\":{\"27\":1,\"84\":1}}],[\"world\",{\"1\":{\"11\":1,\"37\":2}}],[\"跨平台\",{\"1\":{\"20\":1}}],[\"支持\",{\"1\":{\"20\":1}}],[\"支持并发编程\",{\"1\":{\"20\":1}}],[\"支持动态增删元素\",{\"1\":{\"15\":1}}],[\"以确保内存访问的效率\",{\"1\":{\"78\":1}}],[\"以节省内存\",{\"1\":{\"77\":1}}],[\"以及与数据库\",{\"1\":{\"76\":1}}],[\"以本节中的\",{\"1\":{\"72\":1}}],[\"以便为其他结构体提供方法集合\",{\"1\":{\"77\":1}}],[\"以便处理接口类型的不同实现\",{\"1\":{\"43\":1}}],[\"以便于匹配\",{\"1\":{\"39\":1}}],[\"以满足实际需求\",{\"1\":{\"42\":1}}],[\"以下是go语言中常见运算符的优先级\",{\"1\":{\"58\":1}}],[\"以下是一个示例\",{\"1\":{\"50\":1}}],[\"以下是关于\",{\"1\":{\"45\":1}}],[\"以下是几种\",{\"1\":{\"42\":1}}],[\"以下是\",{\"1\":{\"28\":1,\"71\":1}}],[\"以其简洁\",{\"1\":{\"22\":1}}],[\"以其简洁的语法和高效的编译速度而闻名\",{\"1\":{\"20\":1}}],[\"以避免因为数据的添加而导致的不断扩容\",{\"1\":{\"10\":1}}],[\"适用于同一变量的多种条件\",{\"1\":{\"43\":1}}],[\"适用于实时数据分析和处理\",{\"1\":{\"21\":1}}],[\"适用于构建高性能的服务器端应用\",{\"1\":{\"19\":1}}],[\"适合构建高性能应用\",{\"1\":{\"20\":1}}],[\"适合处理动态增删元素的需求\",{\"1\":{\"17\":1}}],[\"适合用于需要静态长度的场景\",{\"1\":{\"17\":1}}],[\"旨在提高编程效率\",{\"1\":{\"19\":1}}],[\"设计理念主要有以下几个方面\",{\"1\":{\"40\":1}}],[\"设计\",{\"1\":{\"19\":1}}],[\"和浮点数类型\",{\"1\":{\"81\":1}}],[\"和数学中类似\",{\"1\":{\"58\":1}}],[\"和\",{\"1\":{\"19\":1,\"20\":3,\"21\":2,\"25\":1,\"27\":1,\"39\":3,\"42\":1,\"44\":2,\"45\":2,\"48\":1,\"70\":1,\"71\":1,\"73\":1,\"78\":2,\"80\":1,\"83\":1}}],[\"和切片\",{\"1\":{\"13\":1}}],[\"getvalue\",{\"1\":{\"43\":1}}],[\"get\",{\"1\":{\"40\":1}}],[\"gin\",{\"1\":{\"21\":1}}],[\"griesemer\",{\"1\":{\"19\":1}}],[\"gorm\",{\"1\":{\"76\":3}}],[\"goroutine\",{\"1\":{\"45\":1,\"49\":1,\"77\":2,\"82\":2}}],[\"goroutines\",{\"1\":{\"20\":2}}],[\"goroot\",{\"1\":{\"27\":1}}],[\"go语言中\",{\"1\":{\"58\":1}}],[\"gomoduls\",{\"1\":{\"27\":1}}],[\"gopath\",{\"1\":{\"27\":1}}],[\"goland\",{\"0\":{\"27\":1},\"1\":{\"25\":1,\"27\":6}}],[\"golangnotes\",{\"1\":{\"83\":1,\"84\":1}}],[\"golang环境\",{\"0\":{\"24\":1}}],[\"golang\",{\"0\":{\"0\":1,\"18\":1},\"1\":{\"2\":2,\"5\":1,\"19\":2,\"20\":6,\"21\":5,\"22\":3,\"23\":2,\"24\":2,\"26\":1,\"27\":3,\"28\":3,\"39\":5,\"40\":3,\"44\":2,\"47\":1,\"59\":3,\"60\":1,\"64\":1,\"69\":2,\"70\":1,\"71\":4,\"72\":6,\"73\":6,\"74\":1,\"77\":2,\"78\":1,\"80\":1,\"82\":1,\"83\":3,\"84\":1,\"85\":2}}],[\"google\",{\"1\":{\"19\":1,\"24\":2}}],[\"go\",{\"1\":{\"11\":1,\"13\":1,\"19\":1,\"24\":1,\"27\":2,\"40\":1,\"43\":1,\"44\":4,\"45\":6,\"46\":1,\"49\":1,\"50\":1,\"64\":1,\"77\":1,\"78\":2,\"81\":1,\"82\":1,\"83\":1}}],[\"它通过将内存划分成大小均匀的小块\",{\"1\":{\"78\":1}}],[\"它的值为\",{\"1\":{\"65\":1}}],[\"它的长度和容量可以动态改变\",{\"1\":{\"15\":1}}],[\"它们都指向同一个底层数据结构\",{\"1\":{\"48\":1}}],[\"它首先会去更新\",{\"1\":{\"48\":1}}],[\"它是引用类型\",{\"1\":{\"82\":1}}],[\"它是一个并发安全的\",{\"1\":{\"49\":1}}],[\"它是一种无序集合\",{\"1\":{\"46\":1}}],[\"它是可选的\",{\"1\":{\"45\":1}}],[\"它可以是\",{\"1\":{\"45\":1}}],[\"它支持并发编程\",{\"1\":{\"20\":1}}],[\"它由\",{\"1\":{\"19\":1}}],[\"首次发布于2009年\",{\"1\":{\"19\":1}}],[\"首先需要了解切片的底层结构\",{\"1\":{\"12\":1}}],[\"首先进行数组定义\",{\"1\":{\"5\":1}}],[\"是直接访问内存中的数据\",{\"1\":{\"82\":1}}],[\"是否在\",{\"1\":{\"50\":1}}],[\"是否会修改原值\",{\"1\":{\"39\":1}}],[\"是引用类型\",{\"1\":{\"48\":1}}],[\"是\",{\"1\":{\"47\":1,\"78\":1,\"85\":2}}],[\"是无序的\",{\"1\":{\"46\":1}}],[\"是一个\",{\"1\":{\"78\":1}}],[\"是一个没有任何字段的结构体\",{\"1\":{\"77\":1}}],[\"是一个非常有用的工具\",{\"1\":{\"45\":1}}],[\"是一种内置的数据结构\",{\"1\":{\"46\":1}}],[\"是一门值得学习和掌握的编程语言\",{\"1\":{\"22\":1}}],[\"是一门静态类型的编程语言\",{\"1\":{\"20\":1}}],[\"是值拷贝\",{\"1\":{\"39\":1}}],[\"是将\",{\"1\":{\"39\":1}}],[\"是由\",{\"1\":{\"19\":1}}],[\"是合法的\",{\"1\":{\"11\":1}}],[\"背景\",{\"0\":{\"19\":1}}],[\"介绍\",{\"0\":{\"18\":1,\"20\":1}}],[\"mystruct\",{\"1\":{\"78\":5}}],[\"myset\",{\"1\":{\"77\":5}}],[\"myint\",{\"1\":{\"39\":15}}],[\"mongodb\",{\"1\":{\"76\":1}}],[\"modifyslice\",{\"1\":{\"16\":2}}],[\"modifyarray\",{\"1\":{\"16\":2}}],[\"mutex\",{\"1\":{\"49\":1}}],[\"multiply\",{\"1\":{\"31\":1}}],[\"msg2\",{\"1\":{\"45\":2}}],[\"msg1\",{\"1\":{\"45\":2}}],[\"message\",{\"1\":{\"45\":3,\"77\":2}}],[\"m\",{\"1\":{\"39\":7,\"47\":2,\"48\":6,\"49\":5,\"50\":4,\"82\":1}}],[\"marshalling\",{\"1\":{\"74\":1}}],[\"marshal\",{\"1\":{\"74\":1}}],[\"mast\",{\"1\":{\"72\":4,\"73\":3}}],[\"math\",{\"1\":{\"50\":6}}],[\"maplen\",{\"1\":{\"48\":1}}],[\"map\",{\"0\":{\"46\":1},\"1\":{\"46\":3,\"47\":6,\"48\":12,\"49\":6,\"50\":7,\"77\":5,\"82\":3}}],[\"macos\",{\"1\":{\"20\":1}}],[\"main\",{\"1\":{\"16\":2,\"37\":1,\"39\":3,\"44\":8,\"45\":2,\"49\":2,\"50\":2,\"63\":1,\"64\":1,\"73\":2,\"74\":2,\"77\":8,\"78\":4}}],[\"makeadder\",{\"1\":{\"36\":2}}],[\"makemultiplier\",{\"1\":{\"34\":2}}],[\"make\",{\"1\":{\"10\":5,\"11\":1,\"45\":2,\"47\":2,\"50\":1,\"71\":2,\"77\":2,\"82\":1}}],[\"many\",{\"1\":{\"5\":1}}],[\"p4\",{\"1\":{\"71\":1}}],[\"p3\",{\"1\":{\"71\":3}}],[\"p2\",{\"1\":{\"71\":1,\"74\":3}}],[\"p1\",{\"1\":{\"71\":1}}],[\"p\",{\"1\":{\"64\":6,\"74\":2,\"82\":4}}],[\"pointer2\",{\"1\":{\"66\":2}}],[\"pointer1\",{\"1\":{\"66\":4}}],[\"pointer\",{\"1\":{\"60\":1,\"61\":2,\"64\":1,\"65\":2}}],[\"post\",{\"1\":{\"44\":3}}],[\"positive\",{\"1\":{\"43\":1}}],[\"personarr\",{\"1\":{\"57\":1}}],[\"person\",{\"1\":{\"57\":6,\"71\":11,\"72\":20,\"73\":29,\"74\":3,\"82\":3}}],[\"ptr\",{\"1\":{\"57\":4,\"62\":3}}],[\"primary\",{\"1\":{\"76\":1}}],[\"printf\",{\"1\":{\"43\":1,\"44\":1,\"48\":1,\"49\":1,\"50\":2,\"63\":2,\"64\":2,\"73\":2,\"74\":1,\"78\":8}}],[\"println\",{\"1\":{\"5\":2,\"6\":8,\"11\":13,\"12\":6,\"16\":4,\"37\":2,\"38\":1,\"39\":6,\"43\":10,\"44\":3,\"45\":3,\"48\":2,\"49\":1,\"62\":2,\"72\":6,\"74\":3,\"77\":6,\"85\":4}}],[\"product\",{\"1\":{\"52\":1}}],[\"pike\",{\"1\":{\"19\":1}}],[\"package\",{\"1\":{\"16\":1,\"44\":4,\"45\":1,\"49\":1,\"50\":1,\"74\":1,\"77\":4,\"78\":2}}],[\"灵活性\",{\"1\":{\"15\":1}}],[\"性能优化\",{\"1\":{\"14\":1}}],[\"或者下面这种形式\",{\"1\":{\"72\":1}}],[\"或者编译时错误\",{\"1\":{\"50\":1}}],[\"或者使用\",{\"1\":{\"49\":1}}],[\"或者\",{\"1\":{\"43\":1}}],[\"或称\",{\"1\":{\"19\":1}}],[\"或\",{\"1\":{\"14\":1,\"15\":1,\"49\":1,\"54\":1}}],[\"并使用\",{\"1\":{\"74\":1}}],[\"并不是一个可比较的值\",{\"1\":{\"50\":1}}],[\"并不会对方法外面的值进行改变\",{\"1\":{\"39\":1}}],[\"并不会对原值产生影响\",{\"1\":{\"12\":1}}],[\"并不会开辟内存\",{\"1\":{\"10\":1}}],[\"并发安全\",{\"0\":{\"49\":1}}],[\"并发性\",{\"1\":{\"20\":1}}],[\"并打印出第一个准备好的消息\",{\"1\":{\"45\":1}}],[\"并根据\",{\"1\":{\"43\":1}}],[\"并没有达到成倍的效果\",{\"1\":{\"39\":1}}],[\"并且判断键是否存在\",{\"1\":{\"48\":1}}],[\"并且存在\",{\"1\":{\"45\":1}}],[\"并且该接口是导出的\",{\"1\":{\"40\":1}}],[\"并且可以赋值给变量或作为参数传递\",{\"1\":{\"33\":1}}],[\"并且长度在整个生命周期中都是不可变的\",{\"1\":{\"14\":1}}],[\"固定长度\",{\"1\":{\"14\":1}}],[\"有助于编写更高效的代码\",{\"1\":{\"78\":1}}],[\"有助于实现良好的包封装\",{\"1\":{\"40\":1}}],[\"有强大的生态支持\",{\"1\":{\"27\":1}}],[\"有较好支持\",{\"1\":{\"27\":1}}],[\"有一些重要的区别\",{\"1\":{\"13\":1}}],[\"有必要存储append的结果\",{\"1\":{\"11\":1}}],[\"语法如下\",{\"1\":{\"72\":1}}],[\"语法简化的目的是为了在保证语义唯一的情况下尽可能简化\",{\"1\":{\"71\":1}}],[\"语法核心\",{\"0\":{\"1\":1}}],[\"语句是\",{\"1\":{\"45\":1}}],[\"语句是编程语言中最为基础也是最重要的一个逻辑控制语句\",{\"1\":{\"42\":1}}],[\"语句会等待并接收来自\",{\"1\":{\"45\":1}}],[\"语句类似于\",{\"1\":{\"45\":1}}],[\"语句在每次执行时\",{\"1\":{\"45\":1}}],[\"语句在\",{\"1\":{\"45\":1}}],[\"语句在匹配到某个\",{\"1\":{\"43\":1}}],[\"语句用于处理并发操作\",{\"1\":{\"45\":1}}],[\"语句用于进行多分支条件判断\",{\"1\":{\"43\":1}}],[\"语句还可以用于类型断言\",{\"1\":{\"43\":1}}],[\"语句中初始化一个变量\",{\"1\":{\"43\":1}}],[\"语句可以和\",{\"1\":{\"45\":1}}],[\"语句可以嵌套使用\",{\"1\":{\"42\":1}}],[\"语句可以延迟函数或方法的执行直到封闭函数返回\",{\"1\":{\"37\":1}}],[\"语句的具体用法\",{\"1\":{\"42\":1}}],[\"语句\",{\"0\":{\"42\":1,\"43\":1,\"44\":1,\"45\":1},\"1\":{\"42\":3,\"43\":2,\"44\":1,\"45\":1}}],[\"语言的内存安全检查\",{\"1\":{\"64\":1}}],[\"语言\",{\"1\":{\"19\":2}}],[\"语言中不允许将布尔值类型强制转换为整型\",{\"1\":{\"81\":1}}],[\"语言中可以直接进行指针的运算\",{\"1\":{\"64\":1}}],[\"语言中处理并发编程的重要工具之一\",{\"1\":{\"45\":1}}],[\"语言中\",{\"1\":{\"13\":1,\"45\":1,\"46\":1,\"82\":1}}],[\"其字段是存储在结构体内存中的值\",{\"1\":{\"82\":1}}],[\"其底层结构包含一个指向数组的指针\",{\"1\":{\"82\":1}}],[\"其元素是存储在数组内存中的值\",{\"1\":{\"82\":1}}],[\"其他常见标签\",{\"0\":{\"76\":1}}],[\"其他运算符\",{\"0\":{\"57\":1}}],[\"其他可比较类型的键\",{\"1\":{\"50\":1}}],[\"其他操作都没有操作到底层数组\",{\"1\":{\"12\":1}}],[\"其本身也可作为数组的数据类型\",{\"1\":{\"7\":1}}],[\"才会展现出修改原切片的效果\",{\"1\":{\"12\":1}}],[\"只需要使用\",{\"1\":{\"84\":1}}],[\"只有在\",{\"1\":{\"78\":1}}],[\"只有在修改切片内元素的时候\",{\"1\":{\"12\":1}}],[\"只是为了使下一个字段的起始地址满足对齐要求\",{\"1\":{\"78\":1}}],[\"只是切片中没有初始化长度\",{\"1\":{\"10\":1}}],[\"只不过是在编译阶段\",{\"1\":{\"72\":1}}],[\"只不过数据类型从基本类型变成了指针类型\",{\"1\":{\"67\":1}}],[\"只不过该副本中的内容和原指针变量的内容相同\",{\"1\":{\"63\":1}}],[\"只要能够拿到对应的数据地址\",{\"1\":{\"64\":1}}],[\"只要所有字段支持\",{\"1\":{\"48\":1}}],[\"只要动态类型支持\",{\"1\":{\"48\":1}}],[\"只能直接调用自身绑定的方法\",{\"1\":{\"39\":1}}],[\"只在函数名前面多了\",{\"1\":{\"39\":1}}],[\"答案是\",{\"1\":{\"39\":1}}],[\"答案是自动扩容的\",{\"1\":{\"10\":1}}],[\"答案依然是不会变化\",{\"1\":{\"12\":1}}],[\"9\",{\"0\":{\"38\":1,\"69\":1},\"1\":{\"12\":1}}],[\"8b\",{\"1\":{\"82\":1}}],[\"8\",{\"0\":{\"37\":1,\"59\":1},\"1\":{\"12\":1,\"36\":1,\"44\":1,\"63\":3,\"78\":9}}],[\"64\",{\"1\":{\"82\":1}}],[\"6\",{\"0\":{\"28\":1,\"35\":1},\"1\":{\"12\":1,\"36\":1,\"44\":1,\"55\":1}}],[\"的变量\",{\"1\":{\"83\":2}}],[\"的执行\",{\"1\":{\"82\":1}}],[\"的总大小是\",{\"1\":{\"78\":1}}],[\"的起始位置对齐在\",{\"1\":{\"78\":1}}],[\"的末尾与\",{\"1\":{\"78\":1}}],[\"的大小正好是\",{\"1\":{\"78\":1}}],[\"的偏移量是\",{\"1\":{\"78\":2}}],[\"的指针\",{\"1\":{\"66\":2,\"82\":1}}],[\"的指针算术运算\",{\"1\":{\"64\":1}}],[\"的指针运算案例\",{\"1\":{\"64\":1}}],[\"的内存地址\",{\"1\":{\"61\":1}}],[\"的优先级高于加法运算符+\",{\"1\":{\"58\":1}}],[\"的地址\",{\"1\":{\"57\":1,\"82\":1}}],[\"的数据集\",{\"1\":{\"50\":1}}],[\"的数字\",{\"1\":{\"44\":1}}],[\"的键\",{\"1\":{\"50\":2}}],[\"的键会导致不可预测的行为\",{\"1\":{\"50\":1}}],[\"的键可以是任何支持\",{\"1\":{\"48\":1}}],[\"的并发访问\",{\"1\":{\"49\":1}}],[\"的并发特性使其在数据处理和流处理领域表现出色\",{\"1\":{\"21\":1}}],[\"的零值是\",{\"1\":{\"48\":1}}],[\"的特性\",{\"1\":{\"48\":1}}],[\"的修改会影响到所有引用它的变量\",{\"1\":{\"48\":1}}],[\"的声明语法如下所示\",{\"1\":{\"47\":1}}],[\"的操作\",{\"1\":{\"45\":1}}],[\"的消息先准备好\",{\"1\":{\"45\":1}}],[\"的消息比\",{\"1\":{\"45\":1}}],[\"的发送或接收操作\",{\"1\":{\"45\":1}}],[\"的循环\",{\"1\":{\"44\":1}}],[\"的类型选择不同的\",{\"1\":{\"43\":1}}],[\"的类型断言结果\",{\"1\":{\"43\":1}}],[\"的\",{\"1\":{\"43\":1,\"76\":1}}],[\"的访问控制机制简化了代码结构\",{\"1\":{\"40\":1}}],[\"的所有标识符\",{\"1\":{\"40\":1}}],[\"的接收者类型\",{\"1\":{\"39\":1}}],[\"的性能和效率使其适合用于系统级编程和网络服务器开发\",{\"1\":{\"21\":1}}],[\"的语法简洁明了\",{\"1\":{\"20\":1}}],[\"的主要特点包括\",{\"1\":{\"20\":1}}],[\"的设计灵感来自\",{\"1\":{\"19\":1}}],[\"的长度\",{\"1\":{\"12\":2}}],[\"的值再赋给\",{\"1\":{\"58\":1}}],[\"的值可以是任何类型\",{\"1\":{\"48\":1}}],[\"的值时\",{\"1\":{\"48\":1}}],[\"的值不再小于\",{\"1\":{\"44\":1}}],[\"的值为\",{\"1\":{\"39\":16}}],[\"的值转换为\",{\"1\":{\"39\":6}}],[\"的值\",{\"1\":{\"12\":1,\"39\":1,\"77\":4}}],[\"的元素的数组\",{\"1\":{\"82\":1}}],[\"的元素\",{\"1\":{\"11\":1}}],[\"改变\",{\"1\":{\"12\":3}}],[\"传递给一个函数或赋值给另一个变量\",{\"1\":{\"48\":1}}],[\"传递给函数的是该指针的副本\",{\"1\":{\"12\":1}}],[\"传递指针时\",{\"1\":{\"39\":1}}],[\"传递的是切片结构的副本\",{\"1\":{\"15\":1}}],[\"传递的是数组的副本而不是引用\",{\"1\":{\"14\":1}}],[\"传递的是数组值的拷贝\",{\"1\":{\"7\":1}}],[\"传递的是这个切片的副本\",{\"1\":{\"12\":1}}],[\"close\",{\"1\":{\"77\":1}}],[\"clear\",{\"1\":{\"11\":2}}],[\"c语言\",{\"1\":{\"64\":1}}],[\"ch\",{\"1\":{\"82\":6}}],[\"charlie\",{\"1\":{\"71\":1}}],[\"changeperson\",{\"1\":{\"73\":4}}],[\"changeslicelength\",{\"1\":{\"12\":4}}],[\"changeslicevalue\",{\"1\":{\"12\":2}}],[\"chan\",{\"1\":{\"45\":2,\"77\":1,\"82\":2}}],[\"channeltype\",{\"1\":{\"82\":2}}],[\"channel\",{\"1\":{\"45\":1,\"77\":2,\"82\":2}}],[\"channels\",{\"1\":{\"20\":2}}],[\"ch2\",{\"1\":{\"45\":7}}],[\"ch1\",{\"1\":{\"45\":6}}],[\"case\",{\"1\":{\"43\":14,\"45\":12}}],[\"cap\",{\"1\":{\"12\":1}}],[\"c++\",{\"1\":{\"28\":1,\"43\":1,\"59\":1,\"64\":2}}],[\"const\",{\"1\":{\"84\":4,\"85\":2}}],[\"condition2\",{\"1\":{\"42\":3}}],[\"condition1\",{\"1\":{\"42\":3}}],[\"condition\",{\"1\":{\"42\":5,\"44\":4}}],[\"collection\",{\"1\":{\"44\":1}}],[\"count++\",{\"1\":{\"44\":1}}],[\"count\",{\"1\":{\"44\":6}}],[\"complex128\",{\"1\":{\"81\":1}}],[\"complex64\",{\"1\":{\"81\":1}}],[\"communication\",{\"1\":{\"45\":1}}],[\"communicationcase2\",{\"1\":{\"45\":1}}],[\"communicationcase1\",{\"1\":{\"45\":2}}],[\"com\",{\"1\":{\"26\":1,\"27\":1,\"84\":1}}],[\"coder\",{\"1\":{\"72\":4,\"73\":3}}],[\"codermast\",{\"1\":{\"57\":1,\"82\":1,\"83\":2,\"84\":1}}],[\"code\",{\"1\":{\"26\":1}}],[\"cn\",{\"1\":{\"24\":2}}],[\"c\",{\"1\":{\"19\":1,\"28\":1,\"43\":1,\"58\":2,\"59\":1,\"64\":3,\"78\":13}}],[\"要了解切片作为参数时\",{\"1\":{\"12\":1}}],[\"+v\",{\"1\":{\"74\":1}}],[\"++p\",{\"1\":{\"64\":1}}],[\"++i\",{\"1\":{\"64\":1}}],[\"+=\",{\"1\":{\"32\":1,\"44\":1,\"56\":2,\"58\":1}}],[\"+\",{\"1\":{\"11\":1,\"30\":1,\"33\":1,\"36\":1,\"52\":2,\"56\":1,\"58\":3,\"64\":1,\"82\":1}}],[\"iota\",{\"0\":{\"85\":1},\"1\":{\"85\":8}}],[\"identifier\",{\"1\":{\"83\":1}}],[\"id\",{\"1\":{\"76\":1}}],[\"ignored\",{\"1\":{\"74\":1}}],[\"ignore\",{\"1\":{\"74\":3}}],[\"i++\",{\"1\":{\"44\":1}}],[\"isfalse\",{\"1\":{\"54\":3}}],[\"istrue\",{\"1\":{\"54\":4}}],[\"isgreaterorequal\",{\"1\":{\"53\":1}}],[\"isless\",{\"1\":{\"53\":1}}],[\"isnotequal\",{\"1\":{\"53\":1}}],[\"isequal\",{\"1\":{\"53\":1}}],[\"is\",{\"1\":{\"43\":9,\"48\":3,\"49\":1,\"77\":1}}],[\"if\",{\"0\":{\"42\":1},\"1\":{\"35\":1,\"38\":2,\"42\":11,\"43\":1,\"44\":1,\"48\":1,\"49\":1,\"65\":1,\"74\":2,\"77\":1}}],[\"import\",{\"1\":{\"16\":1,\"44\":4,\"45\":1,\"49\":1,\"50\":1,\"74\":1,\"77\":4,\"78\":2}}],[\"i\",{\"1\":{\"11\":2,\"43\":6,\"44\":3,\"57\":3,\"63\":3,\"64\":3,\"82\":5,\"85\":2}}],[\"include\",{\"1\":{\"64\":1}}],[\"index\",{\"1\":{\"44\":5}}],[\"initialization\",{\"1\":{\"44\":3}}],[\"initializer\",{\"1\":{\"5\":1}}],[\"install\",{\"1\":{\"24\":1}}],[\"in\",{\"1\":{\"5\":1,\"48\":1,\"77\":1}}],[\"int16\",{\"1\":{\"81\":1}}],[\"int8\",{\"1\":{\"81\":1}}],[\"int64\",{\"1\":{\"78\":5,\"81\":1}}],[\"int32\",{\"1\":{\"78\":5,\"81\":1}}],[\"interface\",{\"1\":{\"43\":1,\"49\":1}}],[\"int\",{\"1\":{\"5\":4,\"6\":2,\"9\":1,\"10\":5,\"11\":5,\"12\":8,\"14\":2,\"15\":2,\"16\":3,\"30\":6,\"31\":8,\"32\":2,\"33\":2,\"34\":5,\"35\":2,\"36\":11,\"38\":2,\"39\":22,\"43\":2,\"44\":1,\"47\":2,\"48\":1,\"50\":1,\"57\":4,\"60\":1,\"63\":2,\"64\":4,\"65\":1,\"71\":1,\"73\":2,\"74\":1,\"76\":2,\"81\":1,\"82\":18}}],[\"从高到低排列\",{\"1\":{\"58\":1}}],[\"从而控制\",{\"1\":{\"82\":1}}],[\"从而达到节约内存的作用\",{\"1\":{\"80\":1}}],[\"从而达到流程控制的作用\",{\"1\":{\"45\":1}}],[\"从而提高系统整体的性能\",{\"1\":{\"78\":1}}],[\"从而提高处理器访问内存的效率\",{\"1\":{\"78\":1}}],[\"从而访问指定的数据\",{\"1\":{\"64\":1}}],[\"从而实现需求\",{\"1\":{\"58\":1}}],[\"从而实现对没有权限的数据的访问\",{\"1\":{\"40\":1}}],[\"从而实现了原值的修改\",{\"1\":{\"39\":1}}],[\"从而实现类似子数组的效果\",{\"1\":{\"6\":1}}],[\"从切片的起始位置到底层数组的结尾的元素个数\",{\"1\":{\"12\":1}}],[\"从中间指定下标删除\",{\"1\":{\"11\":1}}],[\"删除所有元素\",{\"1\":{\"11\":1}}],[\"删除前\",{\"1\":{\"11\":1}}],[\"删除后\",{\"1\":{\"11\":1}}],[\"删除\",{\"1\":{\"11\":1,\"48\":1}}],[\"size\",{\"1\":{\"78\":4}}],[\"sizeof\",{\"1\":{\"77\":1,\"78\":2}}],[\"swap\",{\"1\":{\"63\":2}}],[\"switah\",{\"1\":{\"43\":1}}],[\"switch\",{\"0\":{\"43\":1},\"1\":{\"43\":14,\"45\":1}}],[\"sync\",{\"1\":{\"49\":5}}],[\"s\",{\"1\":{\"48\":2,\"49\":2,\"73\":2,\"78\":10}}],[\"sleep\",{\"1\":{\"45\":2,\"77\":1}}],[\"sliceheader\",{\"1\":{\"12\":1}}],[\"slice\",{\"1\":{\"9\":1,\"10\":6,\"11\":39,\"12\":13,\"13\":1,\"15\":2,\"16\":6,\"82\":1}}],[\"server\",{\"1\":{\"77\":5}}],[\"second\",{\"1\":{\"45\":2,\"77\":1}}],[\"select\",{\"0\":{\"45\":1},\"1\":{\"45\":13}}],[\"set\",{\"1\":{\"40\":1,\"77\":1}}],[\"sunday\",{\"1\":{\"43\":1}}],[\"sum\",{\"1\":{\"32\":2,\"44\":5,\"52\":1}}],[\"saturday\",{\"1\":{\"43\":1}}],[\"started\",{\"1\":{\"77\":2}}],[\"store\",{\"1\":{\"49\":2}}],[\"string\",{\"1\":{\"43\":2,\"45\":2,\"47\":2,\"48\":1,\"50\":2,\"57\":1,\"71\":1,\"73\":2,\"74\":4,\"76\":1,\"77\":2,\"81\":1,\"82\":3,\"83\":1}}],[\"structname\",{\"1\":{\"70\":2,\"72\":1}}],[\"struct\",{\"1\":{\"12\":1,\"39\":1,\"57\":1,\"70\":3,\"71\":1,\"73\":2,\"74\":1,\"76\":1,\"77\":9,\"78\":3,\"82\":2}}],[\"stice\",{\"1\":{\"11\":1}}],[\"如参数变量\",{\"1\":{\"80\":1}}],[\"如布尔型\",{\"1\":{\"48\":1}}],[\"如\",{\"1\":{\"21\":1,\"72\":1,\"77\":1,\"80\":1}}],[\"如下所示\",{\"1\":{\"11\":1,\"72\":1}}],[\"如果省略了值则表示和上面一行的值相同\",{\"1\":{\"84\":1}}],[\"如果省略字段名\",{\"1\":{\"71\":1}}],[\"如果有相同类型的字段\",{\"1\":{\"70\":1}}],[\"如果有足够的容量\",{\"1\":{\"11\":1}}],[\"如果它们支持比较操作\",{\"1\":{\"50\":1}}],[\"如果它们的所有字段都是可比较的类型\",{\"1\":{\"50\":1}}],[\"如果你确实需要进行类似于\",{\"1\":{\"64\":1}}],[\"如果你有一个包含\",{\"1\":{\"50\":1}}],[\"如果你定义的数组长度大于你给定的数据列表\",{\"1\":{\"5\":1}}],[\"如果在多个\",{\"1\":{\"49\":1}}],[\"如果将一个\",{\"1\":{\"48\":1}}],[\"如果不存在则插入\",{\"1\":{\"48\":1}}],[\"如果键不存在\",{\"1\":{\"48\":1}}],[\"如果没有任何\",{\"1\":{\"45\":1}}],[\"如果多个\",{\"1\":{\"45\":1}}],[\"如果\",{\"1\":{\"43\":1}}],[\"如果想访问其内部的数据\",{\"1\":{\"40\":1}}],[\"如果要是通过指针调用会如何呢\",{\"1\":{\"39\":1}}],[\"如果完全按照如上步骤进行操作\",{\"1\":{\"24\":1}}],[\"如果您已经配好环境\",{\"1\":{\"23\":1}}],[\"如果切片的容量不足\",{\"1\":{\"11\":1}}],[\"如果所添加的数据超过该容量\",{\"1\":{\"10\":1}}],[\"如果需要获取数组的子数组\",{\"1\":{\"6\":1}}],[\"如果数组长度不确定\",{\"1\":{\"5\":1}}],[\"将结构体序列化为\",{\"1\":{\"74\":1}}],[\"将值接收者变为指针接收者\",{\"1\":{\"39\":1}}],[\"将上述代码进行修改\",{\"1\":{\"39\":1}}],[\"将\",{\"1\":{\"39\":8,\"74\":1}}],[\"将一些逻辑封装成临时使用的函数\",{\"1\":{\"34\":1}}],[\"将字符串添加到\",{\"1\":{\"11\":1}}],[\"将分配一个新的底层阵列\",{\"1\":{\"11\":1}}],[\"emptystruct\",{\"1\":{\"77\":3}}],[\"empty\",{\"1\":{\"77\":1}}],[\"email\",{\"1\":{\"74\":4,\"75\":1}}],[\"encoding\",{\"1\":{\"74\":1}}],[\"exists\",{\"1\":{\"48\":2,\"50\":9,\"77\":2}}],[\"expression\",{\"1\":{\"43\":3}}],[\"exported\",{\"1\":{\"40\":1}}],[\"else\",{\"1\":{\"42\":6,\"43\":1,\"48\":1}}],[\"element\",{\"1\":{\"64\":2}}],[\"elem2\",{\"1\":{\"11\":1}}],[\"elem1\",{\"1\":{\"11\":1}}],[\"elems\",{\"1\":{\"11\":1}}],[\"err\",{\"1\":{\"38\":3,\"74\":6}}],[\"errorf\",{\"1\":{\"38\":1}}],[\"error\",{\"1\":{\"38\":3,\"74\":2}}],[\"echo\",{\"1\":{\"21\":1}}],[\"eappend\",{\"1\":{\"11\":1}}],[\"通知\",{\"1\":{\"77\":1}}],[\"通道的消息\",{\"1\":{\"45\":1}}],[\"通常是更新变量的语句\",{\"1\":{\"44\":1}}],[\"通常是变量声明或赋值\",{\"1\":{\"44\":1}}],[\"通常存储在保存\",{\"1\":{\"11\":1}}],[\"通过变量名来访问变量的值\",{\"1\":{\"83\":1}}],[\"通过变量来访问数据\",{\"1\":{\"83\":1}}],[\"通过指针引用底层哈希表\",{\"1\":{\"82\":1}}],[\"通过指针引用底层数组\",{\"1\":{\"82\":1}}],[\"通过使用结构体标签\",{\"1\":{\"76\":1}}],[\"通过这个地址可以间接访问对应的变量\",{\"1\":{\"59\":1}}],[\"通过选择和处理多个通道中的消息\",{\"1\":{\"45\":1}}],[\"通过首字母大小写\",{\"1\":{\"40\":1}}],[\"通过返回值和内置的\",{\"1\":{\"38\":1}}],[\"通过\",{\"1\":{\"20\":2,\"62\":1}}],[\"通过切片的底层结构不难看出\",{\"1\":{\"12\":1}}],[\"通过索引来访问切片\",{\"1\":{\"11\":1}}],[\"因为字段\",{\"1\":{\"78\":1}}],[\"因为它不包含任何数据字段\",{\"1\":{\"77\":1}}],[\"因为它不占用内存空间\",{\"1\":{\"77\":1}}],[\"因为它会绕过\",{\"1\":{\"64\":1}}],[\"因为\",{\"1\":{\"50\":3,\"71\":1}}],[\"因为你拷贝的只是指针的副本\",{\"1\":{\"12\":1}}],[\"因为使用\",{\"1\":{\"10\":1}}],[\"因此切片是通过地址引用数组元素的\",{\"1\":{\"82\":1}}],[\"因此在表达式\",{\"1\":{\"58\":1}}],[\"因此对\",{\"1\":{\"48\":1}}],[\"因此输出结果会是\",{\"1\":{\"45\":1}}],[\"因此\",{\"1\":{\"11\":1,\"15\":1,\"78\":2}}],[\"tmp\",{\"1\":{\"63\":2}}],[\"this\",{\"1\":{\"74\":1}}],[\"third\",{\"1\":{\"64\":1}}],[\"the\",{\"1\":{\"48\":1,\"77\":1}}],[\"thompson\",{\"1\":{\"19\":1}}],[\"time\",{\"1\":{\"45\":6,\"77\":3}}],[\"t\",{\"1\":{\"43\":1,\"82\":5}}],[\"true\",{\"1\":{\"42\":4,\"43\":1,\"49\":1,\"50\":1,\"53\":2,\"54\":2}}],[\"total\",{\"1\":{\"32\":5}}],[\"too\",{\"1\":{\"5\":1}}],[\"type\",{\"1\":{\"11\":3,\"12\":1,\"39\":3,\"43\":2,\"57\":1,\"70\":3,\"71\":1,\"73\":2,\"74\":1,\"76\":1,\"77\":3,\"78\":3,\"82\":2,\"83\":4}}],[\"found\",{\"1\":{\"86\":1}}],[\"for\",{\"0\":{\"44\":1},\"1\":{\"32\":1,\"44\":17,\"45\":1,\"48\":1,\"64\":1,\"77\":1}}],[\"float32\",{\"1\":{\"81\":1}}],[\"float64\",{\"1\":{\"50\":2,\"81\":1}}],[\"finished\",{\"1\":{\"77\":1}}],[\"fieldname\",{\"1\":{\"72\":1}}],[\"from\",{\"1\":{\"45\":3}}],[\"false\",{\"1\":{\"42\":2,\"44\":1,\"50\":2,\"53\":2,\"54\":3}}],[\"factorial\",{\"1\":{\"35\":3}}],[\"factor\",{\"1\":{\"34\":2}}],[\"fn\",{\"1\":{\"36\":2}}],[\"func\",{\"1\":{\"11\":1,\"12\":3,\"16\":3,\"30\":2,\"31\":3,\"32\":1,\"33\":1,\"34\":3,\"35\":1,\"36\":5,\"37\":1,\"38\":1,\"39\":6,\"44\":4,\"45\":3,\"49\":2,\"50\":1,\"63\":2,\"71\":1,\"73\":6,\"74\":1,\"77\":6,\"78\":2,\"82\":2}}],[\"fmt\",{\"1\":{\"5\":2,\"6\":8,\"11\":13,\"12\":6,\"16\":5,\"37\":2,\"38\":2,\"39\":6,\"43\":11,\"44\":8,\"45\":4,\"48\":3,\"49\":3,\"50\":3,\"62\":2,\"63\":2,\"72\":6,\"73\":2,\"74\":5,\"77\":10,\"78\":10,\"85\":4}}],[\"否则就会产生歧义\",{\"1\":{\"71\":1}}],[\"否则会无限递归\",{\"1\":{\"35\":1}}],[\"否则会直接报错\",{\"1\":{\"5\":1}}],[\"否则\",{\"1\":{\"11\":1}}],[\"会默认给定对应的\",{\"1\":{\"83\":1}}],[\"会得到以下输出\",{\"1\":{\"78\":1}}],[\"会对结构体字段进行对齐\",{\"1\":{\"78\":1}}],[\"会被解析为\",{\"1\":{\"72\":1}}],[\"会返回\",{\"1\":{\"50\":1}}],[\"会随机选择其中之一\",{\"1\":{\"45\":1}}],[\"会修改原值\",{\"1\":{\"39\":1}}],[\"会将接收者的值传入方法中\",{\"1\":{\"39\":1}}],[\"会自动扩容\",{\"1\":{\"11\":1}}],[\"会分配指定大小的内存空间\",{\"1\":{\"10\":1}}],[\"函数类型赋值\",{\"1\":{\"82\":1}}],[\"函数类型声明\",{\"1\":{\"82\":1}}],[\"函数类型\",{\"1\":{\"82\":1}}],[\"函数实例化\",{\"1\":{\"71\":1}}],[\"函数和包含切片的结构体不能作为键\",{\"1\":{\"48\":1}}],[\"函数来获取\",{\"1\":{\"48\":1}}],[\"函数来删除指定的键值对\",{\"1\":{\"48\":1}}],[\"函数来创建\",{\"1\":{\"47\":1}}],[\"函数来完成\",{\"1\":{\"11\":1}}],[\"函数是最高频被使用到的技术点\",{\"1\":{\"40\":1}}],[\"函数的主要特性和用法示例\",{\"1\":{\"40\":1}}],[\"函数的定义\",{\"1\":{\"28\":1}}],[\"函数参数的传递过程中\",{\"1\":{\"39\":1}}],[\"函数作为返回值\",{\"1\":{\"36\":1}}],[\"函数作为参数\",{\"1\":{\"36\":1}}],[\"函数作为参数和返回值\",{\"0\":{\"36\":1}}],[\"函数可以返回另一个函数\",{\"1\":{\"36\":1}}],[\"函数可以返回多个值\",{\"1\":{\"31\":1}}],[\"函数可以作为参数传递给其他函数\",{\"1\":{\"36\":1}}],[\"函数可以调用自身来解决问题\",{\"1\":{\"35\":1}}],[\"函数可以是匿名的\",{\"1\":{\"33\":1}}],[\"函数可以接收变长参数列表\",{\"1\":{\"32\":1}}],[\"函数名称\",{\"1\":{\"30\":1}}],[\"函数调用\",{\"1\":{\"30\":1}}],[\"函数定义\",{\"1\":{\"30\":1}}],[\"函数定义使用\",{\"1\":{\"30\":1}}],[\"函数定义与调用\",{\"0\":{\"30\":1}}],[\"函数方法\",{\"0\":{\"28\":1}}],[\"函数外部切片受影响\",{\"1\":{\"16\":1}}],[\"函数外部数组不受影响\",{\"1\":{\"16\":1}}],[\"函数内部修改切片\",{\"1\":{\"16\":1}}],[\"函数内部修改数组\",{\"1\":{\"16\":1}}],[\"函数等对切片进行操作\",{\"1\":{\"15\":1}}],[\"函数语法如下\",{\"1\":{\"11\":1}}],[\"函数\",{\"0\":{\"29\":1},\"1\":{\"11\":2,\"40\":1,\"71\":2}}],[\"函数中的数据类型参数不难理解\",{\"1\":{\"10\":1}}],[\"age\",{\"1\":{\"48\":5,\"49\":3,\"57\":2,\"71\":5,\"72\":5,\"73\":14,\"74\":6,\"76\":2,\"82\":1,\"83\":1,\"84\":1}}],[\"alice\",{\"1\":{\"47\":1,\"49\":3,\"71\":1,\"74\":2}}],[\"after\",{\"1\":{\"45\":1}}],[\"andresult\",{\"1\":{\"54\":1,\"55\":1}}],[\"another\",{\"1\":{\"50\":2}}],[\"anothernan\",{\"1\":{\"50\":3}}],[\"anotherslice\",{\"1\":{\"11\":1}}],[\"an\",{\"1\":{\"43\":1}}],[\"arithmetic\",{\"1\":{\"64\":1}}],[\"area\",{\"1\":{\"31\":2,\"39\":4}}],[\"arr\",{\"1\":{\"5\":5,\"6\":11,\"13\":1,\"14\":2,\"16\":7,\"64\":3,\"82\":1}}],[\"array\",{\"1\":{\"5\":1}}],[\"arraylength\",{\"1\":{\"4\":1,\"5\":1}}],[\"arrayname\",{\"1\":{\"4\":1,\"5\":1}}],[\"a\",{\"1\":{\"30\":3,\"33\":2,\"36\":2,\"43\":1,\"50\":3,\"52\":6,\"53\":5,\"55\":6,\"56\":4,\"58\":4,\"78\":13,\"82\":3}}],[\"add5\",{\"1\":{\"36\":2}}],[\"add\",{\"1\":{\"30\":3,\"33\":2,\"36\":1,\"82\":2}}],[\"ai\",{\"1\":{\"27\":1}}],[\"apple\",{\"1\":{\"77\":3}}],[\"apply\",{\"1\":{\"36\":2}}],[\"append\",{\"1\":{\"11\":12,\"12\":1,\"15\":1}}],[\"api\",{\"1\":{\"21\":1}}],[\"向切片中添加元素需要使用\",{\"1\":{\"11\":1}}],[\"添加元素\",{\"1\":{\"77\":1}}],[\"添加数据到切片末尾\",{\"1\":{\"11\":1}}],[\"添加\",{\"1\":{\"11\":1}}],[\"修改结构体字段\",{\"1\":{\"72\":2}}],[\"修改形参并不会对原值曹成变化\",{\"1\":{\"39\":1}}],[\"修改操作都是通过该指针来进行的\",{\"1\":{\"12\":1}}],[\"修改切片内的数组\",{\"1\":{\"11\":1}}],[\"修改\",{\"1\":{\"11\":1,\"12\":3}}],[\"修改数据\",{\"1\":{\"6\":1}}],[\"访问数组元素时\",{\"1\":{\"82\":1}}],[\"访问结构体字段\",{\"1\":{\"72\":2}}],[\"访问结构体成员时使用\",{\"1\":{\"72\":1}}],[\"访问结构体成员\",{\"0\":{\"72\":1}}],[\"访问其指定偏移量的数据\",{\"1\":{\"64\":1}}],[\"访问指针的值\",{\"0\":{\"62\":1}}],[\"访问控制一目了然\",{\"1\":{\"40\":1}}],[\"访问控制\",{\"0\":{\"40\":1}}],[\"访问速度较快\",{\"1\":{\"14\":1}}],[\"访问\",{\"1\":{\"11\":1}}],[\"则\",{\"1\":{\"83\":1}}],[\"则在序列化时忽略它\",{\"1\":{\"74\":1,\"75\":1}}],[\"则会执行\",{\"1\":{\"45\":1}}],[\"则会自动扩容\",{\"1\":{\"10\":1}}],[\"则重新许可目的地以容纳新元素\",{\"1\":{\"11\":1}}],[\"则默认会将所有的数组置为\",{\"1\":{\"5\":1}}],[\"那要是我将该指针指向另外一个新切片呢\",{\"1\":{\"12\":1}}],[\"那到底是可以自动扩容呢\",{\"1\":{\"10\":1}}],[\"那么常量即为不变的量\",{\"1\":{\"84\":1}}],[\"那么再来看下面的这个例子\",{\"1\":{\"72\":1}}],[\"那么就必须要初始化所有字段\",{\"1\":{\"71\":1}}],[\"那么不同类型的数据可通过结构体来进行存储和组织\",{\"1\":{\"69\":1}}],[\"那么它将作为一个\",{\"1\":{\"43\":1}}],[\"那么要是减少切片长度呢\",{\"1\":{\"12\":1}}],[\"那么\",{\"1\":{\"5\":1}}],[\"即指针的指针\",{\"1\":{\"66\":1}}],[\"即为\",{\"1\":{\"66\":2}}],[\"即空指针\",{\"1\":{\"65\":2}}],[\"即可访问\",{\"1\":{\"64\":1}}],[\"即函数的归属不同\",{\"1\":{\"39\":1}}],[\"即使它们都是\",{\"1\":{\"50\":1}}],[\"即使在\",{\"1\":{\"50\":1}}],[\"即使在定义时所在的作用域已经不存在\",{\"1\":{\"34\":1}}],[\"即使只有一行代码\",{\"1\":{\"44\":1}}],[\"即使这些变量不在其参数列表中\",{\"1\":{\"34\":1}}],[\"即使将该指针指向其他地址\",{\"1\":{\"12\":1}}],[\"即有多少数据\",{\"1\":{\"10\":1}}],[\"即二维数组\",{\"1\":{\"7\":1}}],[\"指向\",{\"1\":{\"82\":1}}],[\"指向数组的第一个元素\",{\"1\":{\"64\":1}}],[\"指向变量\",{\"1\":{\"57\":1,\"61\":1}}],[\"指向底层数组\",{\"1\":{\"12\":1}}],[\"指向的是\",{\"1\":{\"10\":1}}],[\"指针为\",{\"1\":{\"82\":2}}],[\"指针数组本质上是一个数组\",{\"1\":{\"67\":1}}],[\"指针数组\",{\"0\":{\"67\":1}}],[\"指针的指针\",{\"0\":{\"66\":1}}],[\"指针运算\",{\"0\":{\"64\":1}}],[\"指针运算符\",{\"1\":{\"57\":1}}],[\"指针变量声明后\",{\"1\":{\"65\":1}}],[\"指针变量作为参数进行传递时\",{\"1\":{\"63\":1}}],[\"指针变量指向一个内存地址\",{\"1\":{\"59\":1}}],[\"指针是指向变量内存地址的值\",{\"1\":{\"66\":1}}],[\"指针是一个特殊类型的变量\",{\"1\":{\"59\":1}}],[\"指针是什么\",{\"1\":{\"59\":1}}],[\"指针类型\",{\"1\":{\"50\":1,\"82\":1}}],[\"指针接收者\",{\"1\":{\"39\":2}}],[\"指针\",{\"0\":{\"59\":1},\"1\":{\"12\":1,\"48\":1}}],[\"指定了容量\",{\"1\":{\"10\":1}}],[\"n3\",{\"1\":{\"84\":1}}],[\"n2\",{\"1\":{\"84\":1}}],[\"n1\",{\"1\":{\"84\":1}}],[\"nan\",{\"1\":{\"50\":18}}],[\"name\",{\"1\":{\"48\":2,\"57\":4,\"71\":5,\"72\":11,\"73\":14,\"74\":6,\"75\":2,\"76\":2,\"82\":1,\"83\":4,\"84\":1}}],[\"notes\",{\"1\":{\"71\":1,\"72\":5,\"73\":5}}],[\"notresult\",{\"1\":{\"54\":1}}],[\"not\",{\"1\":{\"48\":1,\"50\":3,\"86\":1}}],[\"no\",{\"1\":{\"45\":1}}],[\"nor\",{\"1\":{\"43\":1}}],[\"neither\",{\"1\":{\"43\":1}}],[\"negative\",{\"1\":{\"43\":1}}],[\"newperson\",{\"1\":{\"71\":1}}],[\"new\",{\"1\":{\"10\":1,\"71\":5,\"72\":1,\"73\":1}}],[\"number\",{\"1\":{\"50\":3}}],[\"numbers\",{\"1\":{\"44\":3}}],[\"num\",{\"1\":{\"32\":2,\"61\":3,\"62\":2,\"66\":3}}],[\"nums\",{\"1\":{\"32\":2}}],[\"n\",{\"1\":{\"11\":6,\"35\":4,\"43\":1,\"44\":1,\"48\":1,\"49\":1,\"50\":2,\"64\":2,\"74\":1,\"78\":8,\"82\":2}}],[\"nil\",{\"1\":{\"10\":1,\"38\":2,\"48\":1,\"65\":3,\"74\":2}}],[\"容量\",{\"1\":{\"10\":1,\"12\":1}}],[\"长度和容量\",{\"1\":{\"82\":1}}],[\"长度\",{\"1\":{\"10\":1,\"12\":1}}],[\"数值类型\",{\"1\":{\"81\":1}}],[\"数字\",{\"1\":{\"48\":1}}],[\"数据都是存在内存中的二进制序列\",{\"1\":{\"83\":1}}],[\"数据库映射\",{\"1\":{\"74\":1}}],[\"数据处理\",{\"1\":{\"21\":1}}],[\"数据类型实际上是为了优化内存空间的占用而提出的概念\",{\"1\":{\"80\":1}}],[\"数据类型用于声明变量\",{\"1\":{\"80\":1}}],[\"数据类型及变量\",{\"0\":{\"79\":1}}],[\"数据类型的小节中\",{\"1\":{\"39\":1}}],[\"数据类型\",{\"0\":{\"80\":1},\"1\":{\"10\":1}}],[\"数组元素直接存储在数组的内存块中\",{\"1\":{\"82\":1}}],[\"数组类型\",{\"1\":{\"82\":1}}],[\"数组在声明时需要指定固定的长度\",{\"1\":{\"14\":1}}],[\"数组作为一种数据类型\",{\"1\":{\"7\":1}}],[\"数组作为参数时\",{\"1\":{\"7\":1}}],[\"数组支持随机访问\",{\"1\":{\"6\":1}}],[\"数组声明的语法如下所示\",{\"1\":{\"4\":1}}],[\"数组是固定大小的连续内存块\",{\"1\":{\"82\":1}}],[\"数组是固定长度\",{\"1\":{\"17\":1}}],[\"数组是固定长度的数据结构\",{\"1\":{\"2\":1}}],[\"数组是在栈上分配内存的\",{\"1\":{\"14\":1}}],[\"数组是一整块连续内存\",{\"1\":{\"3\":1}}],[\"数组\",{\"0\":{\"3\":1},\"1\":{\"13\":1,\"57\":1}}],[\"数组和切片\",{\"0\":{\"2\":1}}],[\"推荐使用\",{\"1\":{\"10\":1}}],[\"切片本身包含了一个指向底层数组的指针\",{\"1\":{\"82\":1}}],[\"切片本身并没有提供直接删除元素的接口\",{\"1\":{\"11\":1}}],[\"切片类型\",{\"1\":{\"82\":1}}],[\"切片索引\",{\"1\":{\"57\":1}}],[\"切片是引用类型\",{\"1\":{\"82\":1}}],[\"切片是一个动态数组\",{\"1\":{\"82\":1}}],[\"切片是动态长度\",{\"1\":{\"17\":1}}],[\"切片是对数组的一层轻量级封装\",{\"1\":{\"15\":1}}],[\"切片是对数组的抽象\",{\"1\":{\"2\":1}}],[\"切片在作为函数参数传递时\",{\"1\":{\"15\":1}}],[\"切片的长度\",{\"1\":{\"12\":2}}],[\"切片的值\",{\"1\":{\"12\":1}}],[\"切片的应用范围更加广泛\",{\"1\":{\"8\":1}}],[\"切片中的元素个数\",{\"1\":{\"12\":1}}],[\"切片不指定长度\",{\"1\":{\"10\":1}}],[\"切片初始化时的长度和容量\",{\"1\":{\"10\":1}}],[\"切片和数组的声明和初始化几乎类似\",{\"1\":{\"10\":1}}],[\"切片\",{\"0\":{\"8\":1},\"1\":{\"44\":1,\"48\":1}}],[\"而是代指默认值\",{\"1\":{\"83\":1}}],[\"而是基于现有数组创建一个切片视图\",{\"1\":{\"6\":1}}],[\"而且可能造成极其危险的后果\",{\"1\":{\"83\":1}}],[\"而且可能会有频繁的插入和删除操作\",{\"1\":{\"8\":1}}],[\"而数组和结构体的操作是对其内存块中实际存储的数据进行操作\",{\"1\":{\"82\":1}}],[\"而不是地址\",{\"1\":{\"82\":2}}],[\"而不需要传递实际数据\",{\"1\":{\"77\":1}}],[\"而函数没有\",{\"1\":{\"39\":1}}],[\"而容量是最大长度\",{\"1\":{\"10\":1}}],[\"而使用\",{\"1\":{\"10\":1}}],[\"而切片是不定长的\",{\"1\":{\"2\":1}}],[\"这样是错误的\",{\"1\":{\"85\":1}}],[\"这样优化后的结构体的总大小可能会减小\",{\"1\":{\"78\":1}}],[\"这意味着在使用切片和映射时\",{\"1\":{\"82\":1}}],[\"这意味着在函数内部对数组的修改不会影响外部的原始数组\",{\"1\":{\"14\":1}}],[\"这表明通过优化字段顺序\",{\"1\":{\"78\":1}}],[\"这会导致结构体在内存中占用的空间比字段本身的大小总和更多\",{\"1\":{\"78\":1}}],[\"这使得它非常适合作为信号或占位符使用\",{\"1\":{\"77\":1}}],[\"这是\",{\"1\":{\"72\":1}}],[\"这是极度危险的\",{\"1\":{\"64\":1}}],[\"这是因为为了能够和接收者类型进行匹配\",{\"1\":{\"39\":1}}],[\"这是因为这里方法的接收者是值\",{\"1\":{\"39\":1}}],[\"这影响了表达式中运算符执行的顺序\",{\"1\":{\"58\":1}}],[\"这个值同样也是存储在内存中\",{\"1\":{\"66\":1}}],[\"这个示例展示了以下几点\",{\"1\":{\"50\":1}}],[\"这个案例中大体上和函数基本类似\",{\"1\":{\"39\":1}}],[\"这几个语句最为重要\",{\"1\":{\"45\":1}}],[\"这段代码会输出数组\",{\"1\":{\"44\":1}}],[\"这些填充字节不存储任何有效数据\",{\"1\":{\"78\":1}}],[\"这些规则有助于编写清晰且按预期执行的表达式\",{\"1\":{\"58\":1}}],[\"这些是\",{\"1\":{\"40\":1}}],[\"这些变量仍然可以被访问和操作\",{\"1\":{\"34\":1}}],[\"这种设计有助于减少访问内存时的性能开销\",{\"1\":{\"78\":1}}],[\"这种方式比使用其他占位符\",{\"1\":{\"77\":1}}],[\"这种方法应谨慎使用\",{\"1\":{\"64\":1}}],[\"这种面向对象的语言不同\",{\"1\":{\"71\":1}}],[\"这种约定适用于\",{\"1\":{\"40\":1}}],[\"这种默认声明方式\",{\"1\":{\"10\":1}}],[\"这也是因为\",{\"1\":{\"39\":1}}],[\"这定义了方法的接收者为\",{\"1\":{\"39\":1}}],[\"这和\",{\"1\":{\"31\":1}}],[\"这两个开发工具\",{\"1\":{\"25\":1}}],[\"这里的零值并非等于\",{\"1\":{\"83\":1}}],[\"这里的容量指的是切片初始化时的容量\",{\"1\":{\"10\":1}}],[\"这里只能使用\",{\"1\":{\"71\":1}}],[\"这里要注意一个特殊情况\",{\"1\":{\"50\":1}}],[\"这里调用了\",{\"1\":{\"39\":1}}],[\"这里可以看做是在函数调用之前就初始化好了返回值变量\",{\"1\":{\"31\":1}}],[\"这里配置时\",{\"1\":{\"27\":1}}],[\"这里我推荐\",{\"1\":{\"25\":1}}],[\"这里不难看出\",{\"1\":{\"10\":1}}],[\"这里值得注意的是\",{\"1\":{\"5\":1}}],[\"这并不会创建一个新的数组\",{\"1\":{\"6\":1}}],[\"查找时依然无法找到它\",{\"1\":{\"50\":1}}],[\"查询\",{\"1\":{\"48\":1}}],[\"查询子切片的值\",{\"1\":{\"11\":1}}],[\"查询子数组的值\",{\"1\":{\"6\":1}}],[\"查询索引\",{\"1\":{\"11\":1}}],[\"查看数据\",{\"1\":{\"6\":1}}],[\"输出可能是\",{\"1\":{\"78\":1}}],[\"输出集合中的元素\",{\"1\":{\"77\":1}}],[\"输出的仍然是上述结果\",{\"1\":{\"39\":1}}],[\"输出\",{\"1\":{\"5\":1,\"6\":8,\"11\":13,\"12\":6,\"16\":4,\"39\":6,\"50\":1,\"62\":2,\"63\":2,\"72\":6,\"73\":4,\"74\":2,\"77\":1}}],[\"代替数组的长度\",{\"1\":{\"5\":1}}],[\"故修改形参后能够对原数据造成改变\",{\"1\":{\"73\":1}}],[\"故修改形参时\",{\"1\":{\"39\":1}}],[\"故有指针的指针\",{\"1\":{\"66\":1}}],[\"故可以使用\",{\"1\":{\"47\":1}}],[\"故会修改原值\",{\"1\":{\"39\":1}}],[\"故在修改形参后\",{\"1\":{\"39\":1}}],[\"故方法的接收者为指针时\",{\"1\":{\"39\":1}}],[\"故这里不必定义可直接使用\",{\"1\":{\"31\":1}}],[\"故不会展现出任何变化\",{\"1\":{\"12\":1}}],[\"故不表现出任何变化\",{\"1\":{\"12\":1}}],[\"故表现出来的是没有做任何修改\",{\"1\":{\"12\":1}}],[\"故对形参修改\",{\"1\":{\"12\":1}}],[\"故操作形参数组\",{\"1\":{\"7\":1}}],[\"故多余的数为零值\",{\"1\":{\"5\":1}}],[\"故支持随机访问\",{\"1\":{\"3\":1}}],[\"0x000c\",{\"1\":{\"82\":1}}],[\"0x0004\",{\"1\":{\"82\":1}}],[\"0x0000\",{\"1\":{\"82\":2}}],[\"0x1400012a0b0\",{\"1\":{\"62\":1}}],[\"001\",{\"1\":{\"55\":1}}],[\"011\",{\"1\":{\"55\":1}}],[\"0\",{\"1\":{\"5\":2,\"6\":3,\"10\":2,\"11\":8,\"16\":2,\"32\":1,\"38\":3,\"43\":2,\"44\":2,\"48\":1,\"64\":2,\"77\":1,\"78\":3,\"83\":1,\"85\":1}}],[\"4b\",{\"1\":{\"82\":1}}],[\"404\",{\"1\":{\"86\":1}}],[\"40\",{\"1\":{\"71\":1}}],[\"4\",{\"0\":{\"33\":1,\"51\":1},\"1\":{\"5\":2,\"6\":3,\"11\":11,\"12\":9,\"14\":1,\"15\":1,\"16\":5,\"32\":1,\"33\":1,\"44\":2,\"45\":1,\"64\":1,\"78\":7}}],[\"32\",{\"1\":{\"82\":1}}],[\"35\",{\"1\":{\"71\":1}}],[\"30\",{\"1\":{\"47\":1,\"49\":1,\"52\":1,\"71\":1,\"74\":2}}],[\"3\",{\"0\":{\"32\":1,\"79\":1},\"1\":{\"5\":6,\"6\":7,\"10\":2,\"11\":16,\"12\":8,\"14\":1,\"15\":1,\"16\":5,\"30\":1,\"31\":2,\"32\":1,\"33\":1,\"36\":1,\"44\":1,\"45\":1,\"52\":2,\"55\":1,\"64\":1,\"78\":3,\"82\":4}}],[\"25\",{\"1\":{\"47\":1,\"49\":1,\"71\":1,\"74\":2}}],[\"20\",{\"1\":{\"39\":2,\"73\":3}}],[\"21\",{\"1\":{\"11\":1}}],[\"2\",{\"0\":{\"23\":1,\"31\":1},\"1\":{\"5\":4,\"6\":8,\"10\":2,\"11\":15,\"12\":11,\"14\":1,\"15\":1,\"16\":5,\"30\":1,\"32\":1,\"34\":1,\"39\":2,\"43\":3,\"44\":3,\"45\":2,\"55\":1,\"64\":2,\"77\":1,\"82\":4,\"83\":2}}],[\"12\",{\"1\":{\"78\":1}}],[\"120\",{\"1\":{\"35\":1}}],[\"16\",{\"1\":{\"78\":3}}],[\"18\",{\"1\":{\"57\":1,\"71\":1,\"72\":5,\"73\":5,\"82\":1,\"83\":1,\"84\":1}}],[\"180\",{\"1\":{\"48\":1}}],[\"13\",{\"1\":{\"52\":1}}],[\"110\",{\"1\":{\"55\":1}}],[\"111\",{\"1\":{\"55\":1}}],[\"11\",{\"1\":{\"36\":1}}],[\"1010\",{\"1\":{\"55\":1}}],[\"101\",{\"1\":{\"55\":1}}],[\"100\",{\"1\":{\"16\":5,\"84\":1}}],[\"10\",{\"0\":{\"46\":1},\"1\":{\"11\":2,\"12\":2,\"31\":1,\"32\":1,\"34\":1,\"38\":1,\"39\":12,\"44\":3,\"52\":1,\"53\":1,\"55\":2,\"56\":1,\"57\":1,\"61\":1,\"62\":2,\"66\":1,\"82\":4}}],[\"1\",{\"0\":{\"18\":1,\"30\":1},\"1\":{\"5\":4,\"6\":5,\"10\":2,\"11\":14,\"12\":9,\"14\":1,\"15\":1,\"16\":2,\"31\":1,\"32\":1,\"35\":3,\"43\":3,\"44\":4,\"45\":2,\"52\":1,\"55\":3,\"64\":1,\"78\":4,\"82\":4,\"83\":2,\"85\":1}}],[\"50\",{\"1\":{\"39\":1}}],[\"5\",{\"0\":{\"34\":1,\"41\":1},\"1\":{\"5\":3,\"6\":2,\"11\":12,\"12\":9,\"14\":3,\"15\":1,\"16\":7,\"30\":1,\"34\":1,\"35\":1,\"36\":2,\"39\":1,\"44\":5,\"45\":1,\"53\":1,\"55\":1,\"56\":1,\"58\":2,\"63\":3,\"64\":2}}],[\"但直接操作内存地址\",{\"1\":{\"83\":1}}],[\"但结构体可以包含指针字段\",{\"1\":{\"82\":1}}],[\"但本质上仍是变量\",{\"1\":{\"80\":1}}],[\"但这也就意味着\",{\"1\":{\"64\":1}}],[\"但用于通信操作\",{\"1\":{\"45\":1}}],[\"但可以通过\",{\"1\":{\"44\":1}}],[\"但可以使用\",{\"1\":{\"44\":1}}],[\"但如果字段实现了某个接口的方法\",{\"1\":{\"40\":1}}],[\"但需要明确出退出条件\",{\"1\":{\"35\":1}}],[\"但需要注意的是\",{\"1\":{\"6\":1}}],[\"但它加入了并发编程和垃圾回收等现代特性\",{\"1\":{\"19\":1}}],[\"但仍然共享相同的底层数组\",{\"1\":{\"15\":1}}],[\"但长度固定\",{\"1\":{\"14\":1}}],[\"但指向的是同一个地址\",{\"1\":{\"12\":1}}],[\"但是在访问结构体时没有进行解引用就可直接访问结构体内容\",{\"1\":{\"72\":1}}],[\"但是在前面说过\",{\"1\":{\"10\":1}}],[\"但是实际上是禁止了大部分指针运算的\",{\"1\":{\"64\":1}}],[\"但是实际的输出是\",{\"1\":{\"39\":1}}],[\"但是可以在这些方法的内部实现中访问包中的函数\",{\"1\":{\"39\":1}}],[\"但是\",{\"1\":{\"39\":1}}],[\"但是由于指针的副本同样指向的是该结构体实例\",{\"1\":{\"73\":1}}],[\"但是由于操作指针的风险较大\",{\"1\":{\"59\":1}}],[\"但是由于两个指针所指向的是同一个地址\",{\"1\":{\"39\":1}}],[\"但是由于切片的元素个数和容量是值传递\",{\"1\":{\"12\":1}}],[\"但是当增加切片的长度时\",{\"1\":{\"12\":1}}],[\"但是长度和容量这两个有什么区别呢\",{\"1\":{\"10\":1}}],[\"但是数据列表的长度不能超过数组的长度\",{\"1\":{\"5\":1}}],[\"但不知道数据量的数据\",{\"1\":{\"8\":1}}],[\"但实际在功能上差距较大\",{\"1\":{\"2\":1}}],[\"就是方法的接收者类型\",{\"1\":{\"39\":1}}],[\"就有多少长度\",{\"1\":{\"10\":1}}],[\"就默认将剩余的数据重置为零值\",{\"1\":{\"5\":1}}],[\"就不能更改其大小\",{\"1\":{\"2\":1}}],[\"==\",{\"1\":{\"30\":1,\"31\":2,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":2,\"38\":1,\"39\":1,\"48\":3,\"53\":2,\"58\":1,\"65\":1}}],[\"=\",{\"1\":{\"5\":4,\"6\":3,\"10\":4,\"11\":14,\"12\":6,\"14\":1,\"15\":1,\"16\":4,\"30\":1,\"31\":2,\"32\":3,\"33\":2,\"34\":2,\"35\":1,\"36\":3,\"38\":2,\"39\":13,\"43\":3,\"44\":6,\"45\":4,\"47\":2,\"48\":6,\"49\":1,\"50\":6,\"52\":7,\"53\":8,\"54\":5,\"55\":7,\"56\":9,\"57\":5,\"58\":9,\"61\":2,\"62\":2,\"63\":5,\"64\":5,\"66\":3,\"71\":9,\"72\":7,\"73\":8,\"74\":6,\"77\":7,\"82\":10,\"83\":4,\"84\":4,\"85\":3}}],[\"列表初始化\",{\"1\":{\"5\":1}}],[\"没有指定数组的数据\",{\"1\":{\"5\":1}}],[\"可使得在不显式声明数据类型时\",{\"1\":{\"83\":1}}],[\"可使用\",{\"1\":{\"82\":1}}],[\"可使用括号来提升表达式中指定运算符的优先级\",{\"1\":{\"58\":1}}],[\"可能导致不可预知的行为\",{\"1\":{\"64\":1}}],[\"可能会导致数据竞态和程序崩溃\",{\"1\":{\"49\":1}}],[\"可选\",{\"1\":{\"43\":1,\"45\":1}}],[\"可借助辅助函数或者接口\",{\"1\":{\"40\":1}}],[\"可变参数\",{\"1\":{\"32\":1}}],[\"可变参数函数\",{\"0\":{\"32\":1}}],[\"可用于控制逻辑执行\",{\"1\":{\"31\":1}}],[\"可直接定义并初始化变量\",{\"1\":{\"83\":1}}],[\"可直接初始化变量\",{\"1\":{\"83\":1}}],[\"可直接通过内存地址进行数据访问\",{\"1\":{\"83\":1}}],[\"可直接隐藏\",{\"1\":{\"31\":1}}],[\"可直接使用下标索引进行修改\",{\"1\":{\"11\":1}}],[\"可视化界面优秀\",{\"1\":{\"27\":1}}],[\"可将切片中的所有数据置为零值\",{\"1\":{\"11\":1}}],[\"可通过索引下标来进行访问\",{\"1\":{\"6\":1}}],[\"可通过下标索引进行操作\",{\"1\":{\"3\":1}}],[\"可以增长和收缩\",{\"1\":{\"82\":1}}],[\"可以重新排列字段的顺序\",{\"1\":{\"78\":1}}],[\"可以更方便地控制序列化和反序列化的行为\",{\"1\":{\"76\":1}}],[\"可以简化声明\",{\"1\":{\"70\":1}}],[\"可以简化并发程序的编写和管理\",{\"1\":{\"45\":1}}],[\"可以有无限指针的循环嵌套\",{\"1\":{\"66\":1}}],[\"可以有效地管理并发通信\",{\"1\":{\"45\":1}}],[\"可以通过一个指针\",{\"1\":{\"64\":1}}],[\"可以访问指针变量所指向的值\",{\"1\":{\"62\":1}}],[\"可以访问其定义时外部作用域中的变量\",{\"1\":{\"34\":1}}],[\"可以利用指针来简化一些任务的执行\",{\"1\":{\"59\":1}}],[\"可以直接操作内存数据\",{\"1\":{\"59\":1}}],[\"可以直接使用我们配置好的环境变量\",{\"1\":{\"26\":1}}],[\"可以作为\",{\"1\":{\"50\":1}}],[\"可以提升代码的可读性和性能\",{\"1\":{\"45\":1}}],[\"可以实现超时控制\",{\"1\":{\"45\":1}}],[\"可以是发送操作\",{\"1\":{\"45\":1}}],[\"可以在多种场景中提高代码的效率和简洁性\",{\"1\":{\"77\":1}}],[\"可以在\",{\"1\":{\"43\":1}}],[\"可以在同一个\",{\"1\":{\"43\":1}}],[\"可以用于条件逻辑\",{\"1\":{\"43\":1}}],[\"可以用于存储相同类型的数据集合\",{\"1\":{\"2\":1}}],[\"可以定义类似于\",{\"1\":{\"40\":1}}],[\"可以定义多个参数\",{\"1\":{\"31\":1}}],[\"可以被编译器修改\",{\"1\":{\"85\":1}}],[\"可以被其他包访问\",{\"1\":{\"40\":1}}],[\"可以被直接调用或者作为值传递给其他函数\",{\"1\":{\"34\":1}}],[\"可以思考切片这种类型做为参数传递\",{\"1\":{\"39\":1}}],[\"可以类似的看为形参\",{\"1\":{\"39\":1}}],[\"可以为返回值命名\",{\"1\":{\"31\":1}}],[\"可以快速构建高性能的\",{\"1\":{\"21\":1}}],[\"可以编译成跨平台的可执行文件\",{\"1\":{\"20\":1}}],[\"可以自动扩容\",{\"1\":{\"10\":1}}],[\"可以理解为长度是实际的数据长度\",{\"1\":{\"10\":1}}],[\"可以使用空的\",{\"1\":{\"44\":1}}],[\"可以使用切片表达式\",{\"1\":{\"15\":1}}],[\"可以使用切片操作符\",{\"1\":{\"6\":1}}],[\"可以使用\",{\"1\":{\"5\":1,\"27\":1,\"49\":1,\"64\":1}}],[\"可以根据数据量来自动扩充\",{\"1\":{\"2\":1}}],[\"中常量和变量类似\",{\"1\":{\"84\":1}}],[\"中变量可通过\",{\"1\":{\"83\":1}}],[\"中函数可像普通变量一样被传递\",{\"1\":{\"82\":1}}],[\"中函数是对代码封装和重用的基本形式\",{\"1\":{\"28\":1}}],[\"中结构体在内存中的存储是按其字段在结构体中声明的顺序来排列的\",{\"1\":{\"78\":1}}],[\"中结构体标签是一种元数据\",{\"1\":{\"74\":1}}],[\"中是一个非常有用的工具\",{\"1\":{\"77\":1}}],[\"中是通过引用传递数组的\",{\"1\":{\"39\":1}}],[\"中创建结构体实例的几种方式\",{\"1\":{\"71\":1}}],[\"中抛弃了类与继承\",{\"1\":{\"69\":1}}],[\"中相同类型的数据可以使用数组或者切片来存储\",{\"1\":{\"69\":1}}],[\"中支持指针运算\",{\"1\":{\"64\":1}}],[\"中声明一个指针变量需要使用\",{\"1\":{\"60\":1}}],[\"中也提供了指针\",{\"1\":{\"59\":1,\"64\":1}}],[\"中提供了指针这种类型\",{\"1\":{\"59\":1}}],[\"中提供了数组类型的数据结构\",{\"1\":{\"2\":1}}],[\"中插入了一个键\",{\"1\":{\"50\":1}}],[\"中\",{\"1\":{\"50\":2,\"58\":1,\"77\":1}}],[\"中同时读写同一个\",{\"1\":{\"49\":1}}],[\"中每个元素的索引和值\",{\"1\":{\"44\":1}}],[\"中没有构造方法\",{\"1\":{\"71\":1}}],[\"中没有构造方法的概念\",{\"1\":{\"71\":1}}],[\"中没有\",{\"1\":{\"44\":1}}],[\"中没有提供\",{\"1\":{\"44\":1}}],[\"中那样显式使用\",{\"1\":{\"43\":1}}],[\"中接收者不能直接调用属于包的函数\",{\"1\":{\"39\":1}}],[\"中的常量计数器\",{\"1\":{\"85\":1}}],[\"中的一个特殊常量\",{\"1\":{\"85\":1}}],[\"中的数据类型分为\",{\"1\":{\"80\":1}}],[\"中的数组是直接存储在内存中的值\",{\"1\":{\"39\":1}}],[\"中的键值对是无序的\",{\"1\":{\"48\":1}}],[\"中的详细解释和用法说明\",{\"1\":{\"45\":1}}],[\"中的访问控制是通过其名称的第一个首字母进行区分的\",{\"1\":{\"40\":1}}],[\"中的\",{\"1\":{\"39\":1,\"44\":2,\"45\":1,\"49\":1}}],[\"中的函数功能似乎更加强大\",{\"1\":{\"28\":1}}],[\"中不同的是\",{\"1\":{\"39\":1}}],[\"中方法与函数的区别在于\",{\"1\":{\"39\":1}}],[\"中新添加了\",{\"1\":{\"11\":1}}],[\"中还提供了一个切片类型\",{\"1\":{\"2\":1}}],[\"在第一次使用\",{\"1\":{\"85\":1}}],[\"在计算机中\",{\"1\":{\"83\":1}}],[\"在使用\",{\"1\":{\"77\":1}}],[\"在使用上\",{\"1\":{\"2\":1}}],[\"在编译后会自动进行解引用\",{\"1\":{\"72\":1}}],[\"在某些应用场景下非常实用\",{\"1\":{\"59\":1}}],[\"在go语言中是合法的\",{\"1\":{\"58\":1}}],[\"在获取\",{\"1\":{\"48\":1}}],[\"在这个示例中\",{\"1\":{\"45\":1}}],[\"在这个例子中\",{\"1\":{\"43\":1,\"72\":1}}],[\"在实际的开发中\",{\"1\":{\"40\":1}}],[\"在前面\",{\"1\":{\"39\":1}}],[\"在方法内修改形参的值\",{\"1\":{\"39\":1}}],[\"在方法被调用时\",{\"1\":{\"39\":1}}],[\"在多个领域得到了广泛应用\",{\"1\":{\"21\":1}}],[\"在函数内部对切片的修改会影响外部的原始切片\",{\"1\":{\"15\":1}}],[\"在声明结构体内部的字段时\",{\"1\":{\"70\":1}}],[\"在声明数组后\",{\"1\":{\"5\":1}}],[\"在声明阶段就需要指定数组长度和数组的数据类型\",{\"1\":{\"4\":1}}],[\"在\",{\"1\":{\"2\":1,\"10\":1,\"11\":1,\"13\":1,\"28\":1,\"39\":2,\"45\":1,\"46\":1,\"50\":1,\"59\":1,\"60\":1,\"64\":2,\"69\":1,\"74\":1,\"77\":1,\"78\":1,\"82\":4,\"83\":1}}],[\"7\",{\"0\":{\"2\":1,\"36\":1},\"1\":{\"12\":1,\"33\":1,\"52\":1,\"55\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
