const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":244,\"nextId\":244,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"3\",\"3\":\"4\",\"4\":\"5\",\"5\":\"5#简介\",\"6\":\"5#安装\",\"7\":\"5#基本用法\",\"8\":\"5#客户端\",\"9\":\"5#服务器\",\"10\":\"5#主要功能\",\"11\":\"5#参考资料\",\"12\":\"6\",\"13\":\"6#基础模块\",\"14\":\"6#数据结构和算法\",\"15\":\"6#并发编程\",\"16\":\"6#网络和io\",\"17\":\"6#数据序列化和编码\",\"18\":\"6#其他常用模块\",\"19\":\"6#实用工具\",\"20\":\"6#总结\",\"21\":\"7\",\"22\":\"7#_1-切片-slice\",\"23\":\"7#_2-队列-queue\",\"24\":\"7#_3-堆-heap\",\"25\":\"7#_4-链表-list\",\"26\":\"7#解释示例代码\",\"27\":\"7#_5-环形链表-ring\",\"28\":\"7#解释示例代码-1\",\"29\":\"8\",\"30\":\"8#_1-解析命令行参数\",\"31\":\"8#_2-默认值和帮助信息\",\"32\":\"8#_3-非命令行参数\",\"33\":\"8#_4-自定义使用说明\",\"34\":\"8#总结\",\"35\":\"9\",\"36\":\"9#_1-格式化输出\",\"37\":\"9#_2-格式化占位符\",\"38\":\"9#_3-输入\",\"39\":\"9#_4-自定义格式化输出\",\"40\":\"9#_5-错误输出\",\"41\":\"9#_6-更多高级用法\",\"42\":\"9#总结\",\"43\":\"10\",\"44\":\"10#文件和目录操作\",\"45\":\"10#环境变量\",\"46\":\"10#进程操作\",\"47\":\"10#其他常用功能\",\"48\":\"11\",\"49\":\"11#_1-排序函数\",\"50\":\"11#_2-自定义排序\",\"51\":\"11#_3-排序稳定性\",\"52\":\"11#_4-其他排序函数\",\"53\":\"12\",\"54\":\"12#_1-将字符串转换为基本数据类型\",\"55\":\"12#_2-将基本数据类型转换为字符串\",\"56\":\"12#_3-其他常用功能\",\"57\":\"12#总结\",\"58\":\"13\",\"59\":\"13#数组\",\"60\":\"13#声明数组\",\"61\":\"13#初始化数组\",\"62\":\"13#访问数组\",\"63\":\"13#作为参数\",\"64\":\"13#切片\",\"65\":\"13#声明切片\",\"66\":\"13#初始化切片\",\"67\":\"13#访问切片\",\"68\":\"13#作为参数-1\",\"69\":\"13#区别\",\"70\":\"13#数组-arr\",\"71\":\"13#切片-slice\",\"72\":\"13#示例比较\",\"73\":\"13#结论\",\"74\":\"14\",\"75\":\"14#背景\",\"76\":\"14#介绍\",\"77\":\"14#应用\",\"78\":\"14#结论\",\"79\":\"15\",\"80\":\"15#golang环境\",\"81\":\"15#开发工具\",\"82\":\"15#vscode\",\"83\":\"15#goland\",\"84\":\"16\",\"85\":\"16#错误接口\",\"86\":\"16#标准库中的错误处理\",\"87\":\"16#创建自定义错误\",\"88\":\"16#处理错误\",\"89\":\"16#错误链\",\"90\":\"17\",\"91\":\"17#函数\",\"92\":\"17#_1-函数定义与调用\",\"93\":\"17#_2-参数与返回值\",\"94\":\"17#_3-可变参数函数\",\"95\":\"17#_4-匿名函数\",\"96\":\"17#_5-闭包\",\"97\":\"17#_6-递归函数\",\"98\":\"17#_7-函数作为参数和返回值\",\"99\":\"17#_8-延迟执行-defer\",\"100\":\"17#_9-错误处理\",\"101\":\"17#方法\",\"102\":\"17#访问控制\",\"103\":\"18\",\"104\":\"18#开始之前\",\"105\":\"18#泛型函数\",\"106\":\"18#泛型类型\",\"107\":\"18#类型约束\",\"108\":\"18#多个类型参数\",\"109\":\"18#使用约束定义接口\",\"110\":\"18#泛型的优势\",\"111\":\"19\",\"112\":\"19#接口定义\",\"113\":\"19#接口实现\",\"114\":\"19#接口变量\",\"115\":\"19#空接口\",\"116\":\"19#接口断言\",\"117\":\"19#接口组合\",\"118\":\"20\",\"119\":\"20#if-语句\",\"120\":\"20#switch-语句\",\"121\":\"20#for-语句\",\"122\":\"20#range-关键字\",\"123\":\"20#select-语句\",\"124\":\"21\",\"125\":\"21#声明和初始化\",\"126\":\"21#操作map\",\"127\":\"21#并发安全\",\"128\":\"21#特殊情况nan\",\"129\":\"22\",\"130\":\"22#算术运算符\",\"131\":\"22#关系运算符\",\"132\":\"22#逻辑运算符\",\"133\":\"22#位运算符\",\"134\":\"22#赋值运算符\",\"135\":\"22#其他运算符\",\"136\":\"22#运算符的优先级\",\"137\":\"23\",\"138\":\"23#声明指针\",\"139\":\"23#获取变量地址\",\"140\":\"23#访问指针的值\",\"141\":\"23#作为参数\",\"142\":\"23#指针运算\",\"143\":\"23#空指针\",\"144\":\"23#指针的指针\",\"145\":\"23#指针数组\",\"146\":\"24\",\"147\":\"25\",\"148\":\"25#声明结构体\",\"149\":\"25#创建结构体实例\",\"150\":\"25#访问结构体成员\",\"151\":\"25#结构体作为参数\",\"152\":\"25#结构体标签\",\"153\":\"25#结构体标签解释\",\"154\":\"25#其他常见标签\",\"155\":\"25#空结构体\",\"156\":\"25#结构体的存储\",\"157\":\"26\",\"158\":\"26#数据类型\",\"159\":\"26#基本数据类型\",\"160\":\"26#复合数据类型\",\"161\":\"26#变量\",\"162\":\"26#常量\",\"163\":\"26#iota\",\"164\":\"27\",\"165\":\"27#并发安全-concurrency-safety\",\"166\":\"27#常见的并发安全技术\",\"167\":\"27#竞态条件-race-condition\",\"168\":\"27#解决竞态条件\",\"169\":\"27#使用原子操作\",\"170\":\"27#使用通道\",\"171\":\"27#总结\",\"172\":\"28\",\"173\":\"28#特性和概念\",\"174\":\"28#通道的创建\",\"175\":\"28#发送和接收数据\",\"176\":\"28#无缓冲通道-vs-带缓冲通道\",\"177\":\"28#无缓冲通道\",\"178\":\"28#带缓冲通道\",\"179\":\"28#关闭通道\",\"180\":\"28#使用通道的示例\",\"181\":\"28#select-语句\",\"182\":\"28#通道的使用场景\",\"183\":\"29\",\"184\":\"29#_1-工作池-worker-pool\",\"185\":\"29#_2-扇入-fan-in\",\"186\":\"29#_3-扇出-fan-out\",\"187\":\"29#_4-管道-pipeline\",\"188\":\"29#_5-多路复用-multiplexing\",\"189\":\"29#_6-生产者-消费者-producer-consumer\",\"190\":\"30\",\"191\":\"30#基本用法\",\"192\":\"30#创建上下文\",\"193\":\"30#传递上下文\",\"194\":\"30#取消上下文\",\"195\":\"30#超时上下文\",\"196\":\"30#截止时间上下文\",\"197\":\"30#带值上下文\",\"198\":\"30#总结\",\"199\":\"31\",\"200\":\"31#启动-goroutine\",\"201\":\"31#goroutine-的特性\",\"202\":\"31#同步和通信\",\"203\":\"31#创建通道\",\"204\":\"31#发送和接收\",\"205\":\"31#带缓冲的通道\",\"206\":\"31#示例代码\",\"207\":\"31#goroutines-和主程序\",\"208\":\"31#协程、线程、进程\",\"209\":\"31#进程-process\",\"210\":\"31#线程-thread\",\"211\":\"31#协程-coroutine\",\"212\":\"31#总结\",\"213\":\"32\",\"214\":\"32#go-内存模型概述\",\"215\":\"32#关键概念\",\"216\":\"32#happens-before\",\"217\":\"32#内存屏障\",\"218\":\"32#同步原语\",\"219\":\"32#互斥锁-mutex\",\"220\":\"32#读写锁-rwmutex\",\"221\":\"32#原子操作\",\"222\":\"32#通道-channels\",\"223\":\"32#内存模型规则\",\"224\":\"32#总结\",\"225\":\"33\",\"226\":\"34\",\"227\":\"34#select-语句的基本用法\",\"228\":\"34#示例代码\",\"229\":\"34#示例-1-从多个通道接收数据\",\"230\":\"34#示例-2-实现超时机制\",\"231\":\"34#示例-3-非阻塞的通道操作\",\"232\":\"34#select-语句的注意事项\",\"233\":\"34#高级用法\",\"234\":\"35\",\"235\":\"35#_1-锁-locks\",\"236\":\"35#_2-条件变量-condition-variables\",\"237\":\"35#_3-信号量-semaphores\",\"238\":\"35#_4-事件-events\",\"239\":\"35#_5-栅栏-barriers\",\"240\":\"35#_6-原子操作-atomic-operations\",\"241\":\"36\",\"242\":\"37\",\"243\":\"38\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[1],\"3\":[1],\"4\":[5],\"5\":[1,16],\"6\":[1,10],\"7\":[1],\"8\":[1,54],\"9\":[1,103],\"10\":[1,15],\"11\":[1,14],\"12\":[1,8],\"13\":[1,18],\"14\":[1,15],\"15\":[1,20],\"16\":[1,23],\"17\":[1,10],\"18\":[1,20],\"19\":[1,17],\"20\":[1,9],\"21\":[1,7],\"22\":[4,10],\"23\":[4,35],\"24\":[4,69],\"25\":[4,47],\"26\":[2,44],\"27\":[4,47],\"28\":[2,45],\"29\":[1,7],\"30\":[2,43],\"31\":[2,18],\"32\":[2,25],\"33\":[2,32],\"34\":[1,10],\"35\":[1,9],\"36\":[2,24],\"37\":[2,33],\"38\":[2,15],\"39\":[2,25],\"40\":[2,20],\"41\":[2,12],\"42\":[1,7],\"43\":[1,10],\"44\":[1,51],\"45\":[1,31],\"46\":[1,23],\"47\":[1,33],\"48\":[1,15],\"49\":[2,24],\"50\":[2,52],\"51\":[2,4],\"52\":[2,65],\"53\":[1,13],\"54\":[2,33],\"55\":[2,26],\"56\":[2,40],\"57\":[1,9],\"58\":[2,16],\"59\":[1,5],\"60\":[1,6],\"61\":[1,52],\"62\":[1,25],\"63\":[1,9],\"64\":[1,5],\"65\":[1,3],\"66\":[1,52],\"67\":[1,78],\"68\":[1,76],\"69\":[1,10],\"70\":[1,23],\"71\":[1,26],\"72\":[1,27],\"73\":[1,8],\"74\":[3],\"75\":[1,24],\"76\":[1,32],\"77\":[1,29],\"78\":[1,15],\"79\":[2,7],\"80\":[1,16],\"81\":[1,10],\"82\":[1,13],\"83\":[1,51],\"84\":[2,10],\"85\":[1,13],\"86\":[1,27],\"87\":[1,17],\"88\":[1,23],\"89\":[1,39],\"90\":[2,20],\"91\":[1],\"92\":[2,21],\"93\":[2,34],\"94\":[2,20],\"95\":[2,16],\"96\":[2,30],\"97\":[2,18],\"98\":[2,25],\"99\":[3,15],\"100\":[2,26],\"101\":[1,130],\"102\":[1,54],\"103\":[2,7],\"104\":[1,41],\"105\":[1,28],\"106\":[1,32],\"107\":[1,26],\"108\":[1,32],\"109\":[1,38],\"110\":[1,16],\"111\":[2,14],\"112\":[1,16],\"113\":[1,30],\"114\":[1,13],\"115\":[1,23],\"116\":[1,25],\"117\":[1,18],\"118\":[2],\"119\":[2,17],\"120\":[2,100],\"121\":[2,107],\"122\":[2,74],\"123\":[2,113],\"124\":[3,16],\"125\":[1,24],\"126\":[1,91],\"127\":[1,55],\"128\":[1,82],\"129\":[2],\"130\":[1,21],\"131\":[1,22],\"132\":[1,13],\"133\":[1,32],\"134\":[1,23],\"135\":[1,26],\"136\":[1,80],\"137\":[2,20],\"138\":[1,10],\"139\":[1,11],\"140\":[1,11],\"141\":[1,24],\"142\":[1,71],\"143\":[1,14],\"144\":[1,16],\"145\":[1,4],\"146\":[1],\"147\":[2,8],\"148\":[1,25],\"149\":[1,56],\"150\":[1,38],\"151\":[1,38],\"152\":[1,72],\"153\":[1,15],\"154\":[1,40],\"155\":[1,100],\"156\":[1,113],\"157\":[2],\"158\":[1,18],\"159\":[1,29],\"160\":[1,132],\"161\":[1,61],\"162\":[1,27],\"163\":[1,26],\"164\":[2,10],\"165\":[4,6],\"166\":[1,21],\"167\":[4,45],\"168\":[1,43],\"169\":[1,33],\"170\":[1,47],\"171\":[1,15],\"172\":[3,15],\"173\":[1,29],\"174\":[1,10],\"175\":[1,9],\"176\":[3],\"177\":[1,15],\"178\":[1,14],\"179\":[1,19],\"180\":[1,35],\"181\":[2,36],\"182\":[1,14],\"183\":[2,7],\"184\":[5,68],\"185\":[5,54],\"186\":[5,54],\"187\":[4,44],\"188\":[4,43],\"189\":[6,65],\"190\":[3,16],\"191\":[1],\"192\":[1,13],\"193\":[1,11],\"194\":[1,38],\"195\":[1,39],\"196\":[1,43],\"197\":[1,72],\"198\":[1,13],\"199\":[3,27],\"200\":[2,10],\"201\":[2,20],\"202\":[1,9],\"203\":[1,8],\"204\":[1,9],\"205\":[1,11],\"206\":[1,35],\"207\":[2,56],\"208\":[3,5],\"209\":[3,22],\"210\":[3,21],\"211\":[3,28],\"212\":[1,20],\"213\":[2,9],\"214\":[2,27],\"215\":[1],\"216\":[2,10],\"217\":[1,8],\"218\":[1,3],\"219\":[3,36],\"220\":[3,41],\"221\":[1,32],\"222\":[3,24],\"223\":[1,52],\"224\":[1,14],\"225\":[1],\"226\":[3,17],\"227\":[1,21],\"228\":[1,5],\"229\":[3,36],\"230\":[3,30],\"231\":[3,27],\"232\":[1,16],\"233\":[1,13],\"234\":[2,7],\"235\":[4,66],\"236\":[5,57],\"237\":[4,58],\"238\":[4,32],\"239\":[4,58],\"240\":[5,48],\"241\":[1],\"242\":[1,3],\"243\":[1]},\"averageFieldLength\":[1.6434426229508197,29.18025429997935],\"storedFields\":{\"0\":{\"h\":\"Golang\"},\"1\":{\"h\":\"网络编程\"},\"2\":{\"h\":\"语法核心\"},\"3\":{\"h\":\"开源库\"},\"4\":{\"h\":\"golang.org/x/crypto/ssh\"},\"5\":{\"h\":\"简介\",\"t\":[\"golang.org/x/crypto/ssh 是一个用于 Go 语言的 SSH 客户端和服务器的包。它提供了处理 SSH 连接的所有必要功能，包括认证、会话管理、通道和流的处理。\"]},\"6\":{\"h\":\"安装\",\"t\":[\"要安装 golang.org/x/crypto/ssh，您可以使用 go get 命令：\",\"go get golang.org/x/crypto/ssh\"]},\"7\":{\"h\":\"基本用法\"},\"8\":{\"h\":\"客户端\",\"t\":[\"下面是一个简单的 SSH 客户端示例，展示了如何连接到 SSH 服务器并执行命令：\",\"package main import ( \\\"golang.org/x/crypto/ssh\\\" \\\"log\\\" \\\"os\\\" ) func main() { config := &ssh.ClientConfig{ User: \\\"your-username\\\", Auth: []ssh.AuthMethod{ ssh.Password(\\\"your-password\\\"), }, HostKeyCallback: ssh.InsecureIgnoreHostKey(), // 仅用于测试 } client, err := ssh.Dial(\\\"tcp\\\", \\\"your-ssh-server:22\\\", config) if err != nil { log.Fatalf(\\\"Failed to dial: %v\\\", err) } session, err := client.NewSession() if err != nil { log.Fatalf(\\\"Failed to create session: %v\\\", err) } defer session.Close() session.Stdout = os.Stdout session.Stderr = os.Stderr if err := session.Run(\\\"ls -l\\\"); err != nil { log.Fatalf(\\\"Failed to run: %v\\\", err) } }\"]},\"9\":{\"h\":\"服务器\",\"t\":[\"下面是一个简单的 SSH 服务器示例，展示了如何设置一个 SSH 服务器并处理连接：\",\"package main import ( \\\"golang.org/x/crypto/ssh\\\" \\\"io\\\" \\\"log\\\" \\\"net\\\" ) func main() { config := &ssh.ServerConfig{ NoClientAuth: true, } privateBytes, err := os.ReadFile(\\\"path/to/private/key\\\") if err != nil { log.Fatalf(\\\"Failed to load private key: %v\\\", err) } private, err := ssh.ParsePrivateKey(privateBytes) if err != nil { log.Fatalf(\\\"Failed to parse private key: %v\\\", err) } config.AddHostKey(private) listener, err := net.Listen(\\\"tcp\\\", \\\"0.0.0.0:22\\\") if err != nil { log.Fatalf(\\\"Failed to listen for connection: %v\\\", err) } log.Print(\\\"Listening on 0.0.0.0:22...\\\") for { conn, err := listener.Accept() if err != nil { log.Printf(\\\"Failed to accept incoming connection: %v\\\", err) continue } go handleConn(conn, config) } } func handleConn(conn net.Conn, config *ssh.ServerConfig) { sshConn, chans, reqs, err := ssh.NewServerConn(conn, config) if err != nil { log.Printf(\\\"Failed to handshake: %v\\\", err) return } defer sshConn.Close() log.Printf(\\\"New SSH connection from %s (%s)\\\", sshConn.RemoteAddr(), sshConn.ClientVersion()) go ssh.DiscardRequests(reqs) for newChannel := range chans { if newChannel.ChannelType() != \\\"session\\\" { newChannel.Reject(ssh.UnknownChannelType, \\\"unknown channel type\\\") continue } channel, requests, err := newChannel.Accept() if err != nil { log.Printf(\\\"Could not accept channel: %v\\\", err) return } go handleChannel(channel, requests) } } func handleChannel(channel ssh.Channel, requests <-chan *ssh.Request) { defer channel.Close() for req := range requests { switch req.Type { case \\\"shell\\\": if len(req.Payload) == 0 { req.Reply(true, nil) go io.Copy(channel, channel) } else { req.Reply(false, nil) } } } }\"]},\"10\":{\"h\":\"主要功能\",\"t\":[\"认证：支持多种认证方法，包括密码认证、公钥认证等。\",\"会话管理：创建和管理 SSH 会话。\",\"通道和流：处理 SSH 通道和数据流，支持多种数据传输方式。\",\"端口转发：支持本地和远程端口转发。\"]},\"11\":{\"h\":\"参考资料\",\"t\":[\"官方文档\",\"GitHub 仓库\",\"以上是 golang.org/x/crypto/ssh 的一个概述和基本用法示例。如果需要更详细的信息，请参考官方文档和代码示例。希望这些内容对您创建中文站点有所帮助！\"]},\"12\":{\"h\":\"标准库\",\"t\":[\"Go 语言标准库是 Go 开发者日常编程的重要资源，它包含了丰富的功能模块，涵盖了从基本数据类型到高级网络和并发编程的各个方面。以下是一些主要的 Go 标准库模块及其功能的概述：\"]},\"13\":{\"h\":\"基础模块\",\"t\":[\"fmt：格式化输入输出，例如 fmt.Printf、fmt.Println。\",\"os：操作系统功能，例如文件操作、环境变量获取等，如 os.Open、os.Getenv。\",\"flag：命令行参数解析，用于处理命令行输入参数，例如 flag.StringVar、flag.Parse。\"]},\"14\":{\"h\":\"数据结构和算法\",\"t\":[\"container：各种数据结构，包括 list、heap 等。\",\"sort：排序算法，支持对切片的排序。\",\"strconv：字符串和基本数据类型之间的转换，例如 strconv.Atoi、strconv.FormatInt。\"]},\"15\":{\"h\":\"并发编程\",\"t\":[\"sync：同步原语，提供了基本的同步操作，如 sync.Mutex、sync.WaitGroup。\",\"atomic：原子操作，支持原子性的内存访问，如 atomic.AddInt32。\",\"context：上下文管理，用于处理跨 API 边界和 goroutine 的取消、超时、截止时间等。\"]},\"16\":{\"h\":\"网络和IO\",\"t\":[\"net：网络编程，提供了 TCP、UDP、HTTP 等协议的支持，如 net.Dial、net.Listen。\",\"http：HTTP 客户端和服务器实现，例如 http.Get、http.HandleFunc。\",\"io：输入输出工具，包括文件操作、数据流处理等，如 io.Copy、io.Reader、io.Writer。\"]},\"17\":{\"h\":\"数据序列化和编码\",\"t\":[\"encoding/json：JSON 数据的编码和解码。\",\"encoding/xml：XML 数据的编码和解码。\",\"encoding/csv：CSV 格式文件的读写。\"]},\"18\":{\"h\":\"其他常用模块\",\"t\":[\"time：时间处理，包括时间的格式化、解析以及定时器的使用，如 time.Now、time.Parse。\",\"math：数学运算，提供了基本的数学函数和常量，如 math.Sin、math.Pi。\",\"crypto：加密算法，包括 MD5、SHA256 等哈希算法和对称/非对称加密算法。\"]},\"19\":{\"h\":\"实用工具\",\"t\":[\"bufio：缓冲 IO 操作，提高 IO 性能，如 bufio.NewReader、bufio.NewWriter。\",\"log：日志记录，用于生成日志消息，支持级别和格式化输出。\",\"flag：命令行参数解析，用于处理命令行输入参数。\"]},\"20\":{\"h\":\"总结\",\"t\":[\"Go 语言的标准库提供了丰富的功能模块，覆盖了从基础操作到高级功能的多个领域。这些模块被广泛使用，不仅能帮助开发者快速构建应用程序，还能提供高效和可靠的解决方案。深入了解和熟练使用标准库可以极大地提升 Go 语言开发的效率和质量。\"]},\"21\":{\"h\":\"container\",\"t\":[\"在Go语言标准库中，container 包提供了几种常用的数据结构实现，这些数据结构对于高效地管理和操作数据非常有用。以下是 container 包中主要的数据结构：\"]},\"22\":{\"h\":\"1. 切片（slice）\",\"t\":[\"Go语言中的切片是一个动态数组，是非常常用和灵活的数据结构。切片在 container 包中并不单独提供，但在Go语言中广泛用于处理列表和集合数据。\",\"「Golang - 基础知识 - 数组和切片」\"]},\"23\":{\"h\":\"2. 队列（Queue）\",\"t\":[\"container 包提供了一个基于双链表实现的队列：\",\"list.List: 双向链表实现的列表，可以用作队列或者栈。\",\"package main import ( \\\"container/list\\\" \\\"fmt\\\" ) func main() { // 创建一个新的链表 myQueue := list.New() // 入队操作 myQueue.PushBack(\\\"Alice\\\") myQueue.PushBack(\\\"Bob\\\") // 出队操作 front := myQueue.Front() if front != nil { fmt.Println(\\\"Front:\\\", front.Value) // 输出: Front: Alice myQueue.Remove(front) } // 遍历队列 fmt.Println(\\\"Queue contents:\\\") for e := myQueue.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } }\"]},\"24\":{\"h\":\"3. 堆（Heap）\",\"t\":[\"container/heap 包提供了堆操作的接口，但没有直接提供堆的实现，需要通过实现 heap.Interface 接口来使用。堆是一种优先队列，可以高效地提取最小或最大元素。\",\"package main import ( \\\"container/heap\\\" \\\"fmt\\\" ) // 示例结构体 type Item struct { value string // 值 priority int // 优先级 index int // 在堆中的索引 } // 实现 heap.Interface 接口 type PriorityQueue []*Item func (pq PriorityQueue) Len() int { return len(pq) } func (pq PriorityQueue) Less(i, j int) bool { return pq[i].priority < pq[j].priority } func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] pq[i].index = i pq[j].index = j } func (pq *PriorityQueue) Push(x interface{}) { item := x.(*Item) item.index = len(*pq) *pq = append(*pq, item) } func (pq *PriorityQueue) Pop() interface{} { old := *pq n := len(old) item := old[n-1] item.index = -1 *pq = old[0 : n-1] return item } func main() { // 创建优先队列 pq := make(PriorityQueue, 0) heap.Init(&pq) // 插入元素 items := []*Item{ {value: \\\"foo\\\", priority: 3}, {value: \\\"bar\\\", priority: 1}, {value: \\\"baz\\\", priority: 2}, } for _, item := range items { heap.Push(&pq, item) } // 弹出最小元素 for pq.Len() > 0 { item := heap.Pop(&pq).(*Item) fmt.Printf(\\\"(%s, %d) \\\", item.value, item.priority) } // 输出: (bar, 1) (baz, 2) (foo, 3) }\"]},\"25\":{\"h\":\"4. 链表（List）\",\"t\":[\"container/list 是Go语言标准库中提供的双向链表的实现，它支持高效的插入、删除和遍历操作。下面是一个简单的示例，演示了如何使用 container/list 包来操作双向链表：\",\"package main import ( \\\"container/list\\\" \\\"fmt\\\" ) func main() { // 创建一个新的双向链表 mylist := list.New() // 在链表尾部添加元素 mylist.PushBack(\\\"Alice\\\") mylist.PushBack(\\\"Bob\\\") mylist.PushBack(\\\"Charlie\\\") // 在链表头部添加元素 mylist.PushFront(\\\"David\\\") // 遍历链表并打印元素 fmt.Println(\\\"List contents (forward):\\\") for e := mylist.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } // 访问链表尾部元素 fmt.Println(\\\"Last element:\\\", mylist.Back().Value) // 删除链表中的一个元素 secondElement := mylist.Front().Next() mylist.Remove(secondElement) // 再次遍历链表并打印元素 fmt.Println(\\\"List contents after removal:\\\") for e := mylist.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } }\"]},\"26\":{\"h\":\"解释示例代码：\",\"t\":[\"创建链表和插入操作:\",\"list.New(): 创建一个新的空链表。\",\"PushBack(value interface{}): 将元素添加到链表的末尾。\",\"PushFront(value interface{}): 将元素添加到链表的头部。\",\"遍历链表:\",\"Front(): 获取链表的第一个元素。\",\"Back(): 获取链表的最后一个元素。\",\"Next(): 获取下一个节点。\",\"使用 for 循环遍历链表，从头到尾访问每个元素。\",\"删除操作:\",\"Remove(e *Element): 从链表中移除指定的元素。\",\"在上述示例中，我们首先创建了一个双向链表 mylist，然后向其中添加了几个元素。我们展示了如何从头部和尾部插入元素，以及如何遍历链表并打印每个元素。最后，我们演示了如何从链表中移除一个元素，并再次遍历链表来验证删除操作的效果。\",\"通过 container/list 包，你可以方便地实现和操作双向链表，适用于需要频繁插入、删除或者遍历操作的场景，例如实现队列、栈或者其他需要动态管理元素顺序的数据结构。\"]},\"27\":{\"h\":\"5. 环形链表（ring）\",\"t\":[\"container/ring 包提供了环形链表的实现，它可以方便地进行环形数据结构的操作。环形链表是一种特殊的链表，其中最后一个元素指向第一个元素，形成一个闭环。这种数据结构在循环遍历和轮转操作中非常有用。下面是一个简单的示例，演示了如何使用 container/ring 包来操作环形链表：\",\"package main import ( \\\"container/ring\\\" \\\"fmt\\\" ) func main() { // 创建一个环形链表，初始长度为 3 myring := ring.New(3) // 初始化环形链表的值 for i := 1; i <= myring.Len(); i++ { myring.Value = fmt.Sprintf(\\\"Node %d\\\", i) myring = myring.Next() } // 打印环形链表的所有值 fmt.Println(\\\"Ring contents:\\\") myring.Do(func(value interface{}) { fmt.Println(value) }) // 在环形链表中轮转一次 myring = myring.Move(1) // 打印轮转后的环形链表的所有值 fmt.Println(\\\"\\\\nAfter rotation:\\\") myring.Do(func(value interface{}) { fmt.Println(value) }) }\"]},\"28\":{\"h\":\"解释示例代码：\",\"t\":[\"创建环形链表和初始化:\",\"ring.New(n int): 创建一个包含 n 个元素的环形链表。\",\"使用 for 循环初始化环形链表的每个节点的值。\",\"遍历环形链表:\",\"Do(func(value interface{})): 遍历环形链表的所有节点，并对每个节点执行指定的函数。\",\"轮转操作:\",\"Move(n int) *Ring: 将环形链表向前（正数）或向后（负数）轮转 n 个位置。\",\"在示例中，我们首先创建了一个包含三个元素的环形链表 myring。然后，我们使用 for 循环为每个节点赋值，然后打印环形链表的所有值。接下来，我们对环形链表进行一次轮转操作，将链表向前移动一个位置，再次打印轮转后的环形链表的所有值。\",\"通过 container/ring 包，你可以方便地实现和操作环形链表，这种数据结构在需要循环遍历或轮转操作的场景中非常有用，例如实现循环队列、任务调度等。\"]},\"29\":{\"h\":\"flag\",\"t\":[\"在Go语言中，flag 包是用于处理命令行参数的标准库，它提供了一种简单而直接的方式来解析和使用命令行参数。下面是关于 flag 包的一些基本介绍和常用功能：\"]},\"30\":{\"h\":\"1. 解析命令行参数\",\"t\":[\"使用 flag 包可以轻松地解析命令行参数，并将它们赋值给相应的变量。\",\"基本用法\",\"package main import ( \\\"flag\\\" \\\"fmt\\\" ) func main() { // 定义命令行参数 var name string var age int // 解析命令行参数 flag.StringVar(&name, \\\"name\\\", \\\"Guest\\\", \\\"Your name\\\") flag.IntVar(&age, \\\"age\\\", 20, \\\"Your age\\\") // 必须调用 Parse 函数 flag.Parse() // 输出解析后的参数 fmt.Println(\\\"Name:\\\", name) fmt.Println(\\\"Age:\\\", age) }\",\"在上述例子中，flag.StringVar 和 flag.IntVar 分别用于定义一个字符串类型和整数类型的命令行参数。flag.Parse() 函数用于解析命令行参数，并将其赋值给相应的变量。通过命令行运行程序时，可以使用 -name 和 -age 参数指定对应的值。\",\"例如，运行程序时可以这样使用：\",\"go run main.go -name Alice -age 30\"]},\"31\":{\"h\":\"2. 默认值和帮助信息\",\"t\":[\"在使用 flag.StringVar 和 flag.IntVar 定义命令行参数时，可以指定默认值和参数的帮助信息。\",\"flag.StringVar(&name, \\\"name\\\", \\\"Guest\\\", \\\"Your name\\\") flag.IntVar(&age, \\\"age\\\", 20, \\\"Your age\\\")\",\"这里 \\\"name\\\" 和 \\\"age\\\" 是命令行参数的名称，\\\"Guest\\\" 和 20 是默认值，帮助信息 \\\"Your name\\\" 和 \\\"Your age\\\" 会在用户请求帮助时显示出来。\"]},\"32\":{\"h\":\"3. 非命令行参数\",\"t\":[\"除了使用 -name 和 -age 这种形式的命令行参数外，flag 包还支持解析非命令行参数（位置参数）。这些参数可以通过 flag.Args() 函数来获取。\",\"package main import ( \\\"flag\\\" \\\"fmt\\\" ) func main() { // 解析命令行参数 flag.Parse() // 获取非命令行参数 args := flag.Args() fmt.Println(\\\"Non-flag arguments:\\\", args) }\"]},\"33\":{\"h\":\"4. 自定义使用说明\",\"t\":[\"使用 flag.Usage 函数可以自定义程序的使用说明。默认情况下，当用户提供无效的参数或者请求帮助时，会输出默认的使用说明信息。\",\"flag.Usage = func() { fmt.Fprintf(os.Stderr, \\\"Usage of %s:\\\\n\\\", os.Args[0]) fmt.Fprintf(os.Stderr, \\\" -name string\\\\n\\\") fmt.Fprintf(os.Stderr, \\\" Your name (default \\\\\\\"Guest\\\\\\\")\\\\n\\\") fmt.Fprintf(os.Stderr, \\\" -age int\\\\n\\\") fmt.Fprintf(os.Stderr, \\\" Your age (default 20)\\\\n\\\") }\",\"这样定义后，当用户使用 -h 或者提供无效参数时，会显示自定义的使用说明信息。\"]},\"34\":{\"h\":\"总结\",\"t\":[\"flag 包提供了一个简单而强大的方法来处理命令行参数，它使得你可以轻松定义、解析和使用命令行参数，包括可选参数、必选参数、默认值和帮助信息等。这使得编写命令行工具或者控制台程序时，处理用户输入变得非常方便和直观。\"]},\"35\":{\"h\":\"fmt\",\"t\":[\"在 Go 语言的标准库中，fmt 包是非常重要的，它提供了处理格式化输入和输出的基本工具。以下是一些 fmt 包内常用的API：\"]},\"36\":{\"h\":\"1. 格式化输出\",\"t\":[\"Go语言中最基本的输出函数是 fmt.Print、fmt.Println 和 fmt.Printf。它们用于将数据输出到控制台或其他输出设备。\",\"fmt.Print: 输出参数，不添加换行符。\",\"fmt.Print(\\\"Hello, \\\") fmt.Print(\\\"World!\\\") // 输出: Hello, World!\",\"fmt.Println: 输出参数并添加换行符。\",\"fmt.Println(\\\"Hello,\\\") fmt.Println(\\\"World!\\\") // 输出: // Hello, // World!\",\"fmt.Printf: 根据指定格式输出参数。\",\"name := \\\"Alice\\\" age := 30 fmt.Printf(\\\"Name: %s, Age: %d\\\\n\\\", name, age) // 输出: Name: Alice, Age: 30\"]},\"37\":{\"h\":\"2. 格式化占位符\",\"t\":[\"在 Printf 函数中，可以使用各种格式化占位符来指定输出的格式。\",\"%v: 默认格式。\",\"%+v: 对结构体输出字段名。\",\"%#v: 输出 Go 语法表示。\",\"%T: 输出变量类型。\",\"%d, %f, %s, %t, %p 等: 分别用于整数、浮点数、字符串、布尔值、指针等类型的格式化输出。\",\"name := \\\"Bob\\\" age := 25 fmt.Printf(\\\"Name: %s, Age: %d\\\\n\\\", name, age) // 输出: Name: Bob, Age: 25\"]},\"38\":{\"h\":\"3. 输入\",\"t\":[\"使用 fmt.Scan 可以从标准输入中读取数据。\",\"var name string fmt.Print(\\\"Enter your name: \\\") fmt.Scan(&name) fmt.Printf(\\\"Hello, %s!\\\\n\\\", name)\"]},\"39\":{\"h\":\"4. 自定义格式化输出\",\"t\":[\"通过实现 String() 方法可以自定义类型的字符串表示方式。\",\"type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(\\\"%s (%d years)\\\", p.Name, p.Age) } func main() { p := Person{\\\"Alice\\\", 30} fmt.Println(p) // 输出: Alice (30 years) }\"]},\"40\":{\"h\":\"5. 错误输出\",\"t\":[\"使用 fmt.Errorf 可以生成格式化的错误信息。\",\"import \\\"fmt\\\" func someFunction() error { return fmt.Errorf(\\\"Something went wrong\\\") } func main() { err := someFunction() if err != nil { fmt.Println(\\\"Error:\\\", err) } }\"]},\"41\":{\"h\":\"6. 更多高级用法\",\"t\":[\"格式化输出的宽度和精度控制。\",\"fmt.Sprintf 函数用于返回格式化后的字符串。\",\"fmt.Fprint, fmt.Fprintf, fmt.Fprintln 用于格式化输出到文件或其他 io.Writer 接口。\"]},\"42\":{\"h\":\"总结\",\"t\":[\"fmt 包提供了丰富的工具来处理格式化的输入和输出，是Go语言中常用的标准库之一。通过掌握这些基本的函数和格式化占位符，可以很好地满足大部分的格式化输出需求，并能够处理简单的输入操作和错误信息的格式化输出。\"]},\"43\":{\"h\":\"os\",\"t\":[\"在Go语言中，os 包是一个非常重要且常用的标准库，它提供了与操作系统交互的功能，包括文件操作、环境变量管理、进程管理等。下面是一些 os 包中常用的功能和API：\"]},\"44\":{\"h\":\"文件和目录操作\",\"t\":[\"文件操作\",\"func Create(name string) (*File, error): 创建一个文件。\",\"func Open(name string) (*File, error): 打开一个文件。\",\"func Remove(name string) error: 删除一个文件。\",\"func Rename(oldpath, newpath string) error: 重命名一个文件。\",\"package main import ( \\\"os\\\" \\\"log\\\" ) func main() { // 创建文件 file, err := os.Create(\\\"test.txt\\\") if err != nil { log.Fatal(err) } defer file.Close() // 打开文件 file, err = os.Open(\\\"test.txt\\\") if err != nil { log.Fatal(err) } defer file.Close() // 删除文件 err = os.Remove(\\\"test.txt\\\") if err != nil { log.Fatal(err) } }\",\"目录操作\",\"func Mkdir(name string, perm FileMode) error: 创建一个目录。\",\"func MkdirAll(path string, perm FileMode) error: 递归创建多层目录。\",\"func RemoveAll(path string) error: 递归删除一个目录及其子目录。\",\"// 创建目录 err := os.Mkdir(\\\"mydir\\\", 0755) if err != nil { log.Fatal(err) } // 递归创建目录 err = os.MkdirAll(\\\"path/to/mydir\\\", 0755) if err != nil { log.Fatal(err) } // 递归删除目录 err = os.RemoveAll(\\\"path/to/mydir\\\") if err != nil { log.Fatal(err) }\"]},\"45\":{\"h\":\"环境变量\",\"t\":[\"func Getenv(key string) string: 获取环境变量的值。\",\"func Setenv(key, value string) error: 设置环境变量的值。\",\"func Unsetenv(key string) error: 删除指定的环境变量。\",\"// 获取环境变量 value := os.Getenv(\\\"HOME\\\") fmt.Println(\\\"Home directory:\\\", value) // 设置环境变量 err := os.Setenv(\\\"MYAPP_DB_URL\\\", \\\"localhost:5432\\\") if err != nil { log.Fatal(err) }\"]},\"46\":{\"h\":\"进程操作\",\"t\":[\"func Exit(code int): 终止当前进程并返回指定的状态码。\",\"func Getpid() int: 获取当前进程的ID。\",\"func Getppid() int: 获取当前进程的父进程ID。\",\"// 获取当前进程ID和父进程ID pid := os.Getpid() ppid := os.Getppid() fmt.Printf(\\\"PID: %d, PPID: %d\\\\n\\\", pid, ppid) // 终止当前进程 os.Exit(1)\"]},\"47\":{\"h\":\"其他常用功能\",\"t\":[\"func Chdir(dir string) error: 改变当前工作目录。\",\"func Hostname() (name string, err error): 获取主机名。\",\"func Getwd() (dir string, err error): 获取当前工作目录。\",\"// 改变当前工作目录 err := os.Chdir(\\\"/tmp\\\") if err != nil { log.Fatal(err) } // 获取主机名 hostname, err := os.Hostname() if err != nil { log.Fatal(err) } fmt.Println(\\\"Hostname:\\\", hostname) // 获取当前工作目录 wd, err := os.Getwd() if err != nil { log.Fatal(err) } fmt.Println(\\\"Current working directory:\\\", wd)\",\"通过学习和使用 os 包，你可以很方便地管理文件、目录、环境变量以及进程等操作系统相关的资源和信息。这使得Go语言在系统级编程和文件处理方面非常强大和灵活。\"]},\"48\":{\"h\":\"order\",\"t\":[\"在 Go 语言中，sort 包提供了对切片和用户定义的集合进行排序的函数。它实现了常见的排序算法，如快速排序（Quicksort）和堆排序（Heapsort），并且为自定义集合提供了接口，使得用户可以根据特定的需求进行排序。\",\"以下是 sort 包中常用的函数和接口：\"]},\"49\":{\"h\":\"1. 排序函数\",\"t\":[\"sort.Ints: 对整数类型的切片进行升序排序。\",\"import \\\"sort\\\" func main() { ints := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5} sort.Ints(ints) fmt.Println(ints) // 输出: [1 1 2 3 3 4 5 5 5 6 9] }\",\"sort.Float64s: 对浮点数类型的切片进行升序排序。\",\"sort.Strings: 对字符串类型的切片进行升序排序。\"]},\"50\":{\"h\":\"2. 自定义排序\",\"t\":[\"通过实现 sort.Interface 接口，可以对用户定义的集合进行排序。该接口包括 Len()、Less(i, j int) 和 Swap(i, j int) 方法，用于描述集合的长度、比较元素大小的规则以及交换元素的位置。\",\"type Person struct { Name string Age int } type ByAge []Person func (a ByAge) Len() int { return len(a) } func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age } func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func main() { people := []Person{ {\\\"Alice\\\", 25}, {\\\"Bob\\\", 30}, {\\\"Charlie\\\", 20}, } sort.Sort(ByAge(people)) fmt.Println(\\\"Sorted by age:\\\") for _, p := range people { fmt.Printf(\\\"%s (%d)\\\\n\\\", p.Name, p.Age) } }\"]},\"51\":{\"h\":\"3. 排序稳定性\",\"t\":[\"Go 语言的排序函数是稳定的，即相等元素的相对顺序在排序后保持不变。\"]},\"52\":{\"h\":\"4. 其他排序函数\",\"t\":[\"sort.Sort: 对实现了 sort.Interface 接口的集合进行排序。\",\"sort.Search: 在已排序的集合中搜索元素。\",\"示例\",\"以下是一个结合了自定义排序和使用 sort.Sort 的例子：\",\"package main import ( \\\"fmt\\\" \\\"sort\\\" ) type Person struct { Name string Age int } type ByName []Person func (a ByName) Len() int { return len(a) } func (a ByName) Less(i, j int) bool { return a[i].Name < a[j].Name } func (a ByName) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func main() { people := []Person{ {\\\"Alice\\\", 25}, {\\\"Bob\\\", 30}, {\\\"Charlie\\\", 20}, } sort.Sort(ByName(people)) fmt.Println(\\\"Sorted by name:\\\") for _, p := range people { fmt.Printf(\\\"%s (%d)\\\\n\\\", p.Name, p.Age) } }\",\"在这个示例中，我们定义了 Person 结构体和 ByName 类型来实现按照姓名排序的需求。通过 sort.Sort(ByName(people)) 对 people 切片按照姓名进行排序，然后打印出排序后的结果。\",\"通过 sort 包，Go 语言提供了强大且简洁的排序功能，可以方便地对各种类型的数据进行排序操作。\"]},\"53\":{\"h\":\"strconv\",\"t\":[\"在 Go 语言中，strconv 包提供了字符串和基本数据类型之间的转换函数，例如将整数转换为字符串、字符串转换为整数，以及其他类型之间的转换。这些功能非常有用，特别是在处理用户输入或从外部数据源读取数据时。\",\"以下是 strconv 包中常用的函数和用法示例：\"]},\"54\":{\"h\":\"1. 将字符串转换为基本数据类型\",\"t\":[\"Atoi: 将字符串转换为整数类型。\",\"package main import ( \\\"fmt\\\" \\\"strconv\\\" ) func main() { str := \\\"123\\\" num, err := strconv.Atoi(str) if err != nil { fmt.Println(\\\"Error:\\\", err) return } fmt.Printf(\\\"Converted integer: %d\\\\n\\\", num) // 输出: Converted integer: 123 }\",\"ParseFloat: 将字符串转换为浮点数类型。\",\"package main import ( \\\"fmt\\\" \\\"strconv\\\" ) func main() { str := \\\"3.14\\\" num, err := strconv.ParseFloat(str, 64) if err != nil { fmt.Println(\\\"Error:\\\", err) return } fmt.Printf(\\\"Converted float: %f\\\\n\\\", num) // 输出: Converted float: 3.140000 }\"]},\"55\":{\"h\":\"2. 将基本数据类型转换为字符串\",\"t\":[\"Itoa: 将整数转换为字符串类型。\",\"package main import ( \\\"fmt\\\" \\\"strconv\\\" ) func main() { num := 42 str := strconv.Itoa(num) fmt.Printf(\\\"Converted string: %s\\\\n\\\", str) // 输出: Converted string: 42 }\",\"FormatFloat: 将浮点数转换为字符串类型。\",\"package main import ( \\\"fmt\\\" \\\"strconv\\\" ) func main() { num := 3.14 str := strconv.FormatFloat(num, 'f', -1, 64) fmt.Printf(\\\"Converted string: %s\\\\n\\\", str) // 输出: Converted string: 3.14 }\"]},\"56\":{\"h\":\"3. 其他常用功能\",\"t\":[\"错误处理: 在使用 Atoi、ParseFloat 等函数时，如果转换失败会返回一个错误。\",\"package main import ( \\\"fmt\\\" \\\"strconv\\\" ) func main() { str := \\\"hello\\\" _, err := strconv.Atoi(str) if err != nil { fmt.Println(\\\"Error:\\\", err) // 输出: Error: strconv.Atoi: parsing \\\"hello\\\": invalid syntax } }\",\"基数转换: 可以指定进制进行字符串和整数之间的转换。\",\"package main import ( \\\"fmt\\\" \\\"strconv\\\" ) func main() { str := \\\"1A\\\" num, err := strconv.ParseInt(str, 16, 32) if err != nil { fmt.Println(\\\"Error:\\\", err) return } fmt.Printf(\\\"Converted integer (base 16): %d\\\\n\\\", num) // 输出: Converted integer (base 16): 26 }\"]},\"57\":{\"h\":\"总结\",\"t\":[\"strconv 包是处理字符串和基本数据类型之间转换的重要工具，它提供了丰富的功能和灵活的选项，能够满足各种类型转换的需求。在编写需要处理用户输入、配置文件解析或者网络通信的程序时，经常会用到 strconv 包来处理数据类型的转换和格式化。\"]},\"58\":{\"h\":\"7. 数组和切片\",\"t\":[\"在 Golang 中提供了数组类型的数据结构，可以用于存储相同类型的数据集合。除此之外，Golang 中还提供了一个切片类型，切片是对数组的抽象。在使用上，两者几乎类似，但实际在功能上差距较大。\",\"数组是固定长度的数据结构，一旦初始化，就不能更改其大小，而切片是不定长的，可以根据数据量来自动扩充。\"]},\"59\":{\"h\":\"数组\",\"t\":[\"数组是一整块连续内存，且存储的数据类型相同，故支持随机访问。可通过下标索引进行操作。\"]},\"60\":{\"h\":\"\",\"t\":[\"数组声明的语法如下所示，在声明阶段就需要指定数组长度和数组的数据类型。\",\"var arrayName [arrayLength]dataType\"]},\"61\":{\"h\":\"\",\"t\":[\"仅声明\",\"在声明数组后，没有指定数组的数据，则默认会将所有的数组置为 dataType 类型的零值。\",\"列表初始化\",\"var arrayName = [arrayLength]dataType{data1, data2, data3 ...}\",\"这里值得注意的是，如果你定义的数组长度大于你给定的数据列表，那么 Golang 就默认将剩余的数据重置为零值。但是数据列表的长度不能超过数组的长度，否则会直接报错。\",\"var arr = [5]int{1, 2, 3} fmt.Println(arr) var arr [3]int = [3]int{1, 2, 3, 4} // 编译错误: 初始化列表中的元素个数超过数组声明的长度 // too many values in array initializer\",\"遍历输出这个数组，结果为 [1, 2, 3, 0, 0]\",\"实际上这里是分两个步骤，首先进行数组定义，然后初始化，故多余的数为零值。\",\"未知数组长度\",\"如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度：\",\"var arr = [...]int{ 1, 2, 3, 4, 5} fmt.Println(len(arr)) // 输出 5\"]},\"62\":{\"h\":\"\",\"t\":[\"数组支持随机访问，可通过索引下标来进行访问\",\"查看数据\",\"var arr = [5]int{ 1, 2, 3 } fmt.Println(arr[0]) // 输出 1 fmt.Println(arr[1]) // 输出 2 fmt.Println(arr[2]) // 输出 3 fmt.Println(arr[3]) // 输出 0 fmt.Println(arr[4]) // 输出 0 // 查询子数组的值 fmt.Println(arr[1:3]) // 输出 [2,3]\",\"如果需要获取数组的子数组，可以使用切片操作符 [:] 来创建一个切片，从而实现类似子数组的效果。但需要注意的是，这并不会创建一个新的数组，而是基于现有数组创建一个切片视图。\",\"修改数据\",\"var arr = [5]int{ 1, 2, 3 } fmt.Println(arr[2]) // 输出 3 arr[2] = 4 fmt.Println(arr[2]) // 输出 4\"]},\"63\":{\"h\":\"\",\"t\":[\"数组作为参数时，传递的是数组值的拷贝，故操作形参数组，不会改变原有的数组值。\",\"数组作为一种数据类型，其本身也可作为数组的数据类型，即二维数组，同理即可支持多维数组。\"]},\"64\":{\"h\":\"切片\",\"t\":[\"切片的应用范围更加广泛，用于存储相同类型，但不知道数据量的数据，而且可能会有频繁的插入和删除操作。\"]},\"65\":{\"h\":\"\",\"t\":[\"var slice []int\"]},\"66\":{\"h\":\"\",\"t\":[\"var slice = []int{ 1, 2, 3 } slice := []int{ 1, 2, 3 } slice := make([]int, 0, 0) slice := new([]int)\",\"这里不难看出，切片和数组的声明和初始化几乎类似，只是切片中没有初始化长度。推荐使用 make 方法来创建切片，make 方法的三个参数依次为：数据类型，长度，容量。\",\"因为使用 var slice []int 这种默认声明方式，并不会开辟内存，实际上此时的 slice 指向的是 nil 空指针，而使用 make 方法进行初始化时，指定了容量，会分配指定大小的内存空间。\",\"切片初始化时的长度和容量\",\"在 make 函数中的数据类型参数不难理解，但是长度和容量这两个有什么区别呢？可以理解为长度是实际的数据长度，即有多少数据，就有多少长度，而容量是最大长度。\",\"但是在前面说过，切片不指定长度，可以自动扩容，那到底是可以自动扩容呢？还是根据这个容量来限制呢？答案是自动扩容的，这里的容量指的是切片初始化时的容量，如果所添加的数据超过该容量，则会自动扩容，默认是扩容为当前容量的两倍。\",\"由于扩容的性能消耗，所以在声明阶段就尽可能的给定一个可能会用到的容量，以避免因为数据的添加而导致的不断扩容。\"]},\"67\":{\"h\":\"\",\"t\":[\"访问\",\"通过索引来访问切片，使用的方法和数组完全相同，具体如下：\",\"slice := []int{1, 2, 3, 4, 5} // 查询索引 2 的元素 fmt.Println(slice[2]) // 输出: 3 // 查询子切片的值 fmt.Println(slice[1:3]) // 输出 [2,3]\",\"修改\",\"修改切片内的数组，可直接使用下标索引进行修改。\",\"slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) // 输出: [1, 2, 3, 4, 5] slice[3] = 10 fmt.Println(slice) // 输出: [1, 2, 3, 10, 5]\",\"在 Go 1.21 中新添加了 clear 方法，可将切片中的所有数据置为零值。\",\"slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) // 输出: [1, 2, 3, 4, 5] clear(slice) fmt.Println(slice) // 输出: [0, 0, 0, 0, 0]\",\"添加\",\"向切片中添加元素需要使用 append 函数，添加数据到切片末尾，如果切片的容量不足，append 会自动扩容。\",\"slice := make([]int,0,0) fmt.Println(slice) // 输出 [] slice = append(slice,1,2,3,4,5) fmt.Println(slice) // 输出 [1,2,3,4,5]\",\"append 函数\",\"append 内置函数将元素附加到切片的末尾。如果有足够的容量，则重新许可目的地以容纳新元素。否则，将分配一个新的底层阵列。append 函数语法如下:\",\"func append(slice []Type, elems ...Type) []Type\",\"append 返回更新的切片。因此，有必要存储append的结果，通常存储在保存 slice 本身的变量中：\",\"slice = append(slice, elem1, elem2) slice = eappend(slice, anotherSlice ...)\",\"作为特殊情况，将字符串添加到 byte slice 是合法的，如下所示：\",\"stice = append([]byte(\\\"hello \\\")，\\\"world\\\" ...)\",\"删除\",\"切片本身并没有提供直接删除元素的接口，需要借助 append 函数来完成\",\"slice := []int{1, 2, 3, 4, 5} fmt.Println(slice) // 输出 [1,2,3,4,5] // 删除后 n 个元素 slice = slice[:len(slice) - n] fmt.Println(slice) // 输出 [1,2,3 ...] // 删除前 n 个元素 slice = slice[n:]; fmt.Println(slice) // 输出 [... 3,4,5] // 从中间指定下标删除 n 个元素 slice = append(slice[:i], slice[i + n:]...) fmt.Println(slice) // 输出 [1,2 ... 4,5] // 删除所有元素 slice = slice[:0] fmt.Println(slice) // 输出 []\"]},\"68\":{\"h\":\"\",\"t\":[\"要了解切片作为参数时，首先需要了解切片的底层结构。\",\"type SliceHeader struct { Data uintptr // 指针：指向底层数组。 Len int // 长度：切片中的元素个数。 Cap int // 容量：从切片的起始位置到底层数组的结尾的元素个数。 }\",\"当将切片作为参数传递给函数时，传递的是这个切片的副本，通过切片的底层结构不难看出，实际上切片不存储数据，存储的是一个指向底层数组的指针，传递给函数的是该指针的副本，但指向的是同一个地址，故对形参修改，也会反应在原切片上。\",\"// 改变 slice 的值 func changeSliceValue(slice []int) { slice[len(slice) / 2] = 10 } dataSlice := []int{1,2,3,4,5} fmt.Println(dataSlice) // 输出 [1,2,3,4,5] // 修改 切片的值 changeSliceValue(dataSlice) fmt.Println(dataSlice) // 输出 [1,2,10,4,5]\",\"但是当增加切片的长度时，此时虽然通过实际的数组指针修改了底层数组，但是由于切片的元素个数和容量是值传递，并不会对原值产生影响，故表现出来的是没有做任何修改。\",\"// 改变 slice 的长度 func changeSliceLength(slice []int) { slice = append(slice,6,7,8,9) } dataSlice := []int{1,2,3,4,5} fmt.Println(dataSlice) // 输出 [1,2,3,4,5] // 修改 切片的长度 changeSliceLength(dataSlice) fmt.Println(dataSlice) // 输出 [1,2,3,4,5]\",\"那么要是减少切片长度呢？\",\"// 改变 slice 的长度 func changeSliceLength(slice []int) { slice = slice[:len(slice) / 2] } dataSlice := []int{1,2,3,4,5} fmt.Println(dataSlice) // 输出 [1,2,3,4,5] // 修改 切片的长度 changeSliceLength(dataSlice) fmt.Println(dataSlice) // 输出 [1,2,3,4,5]\",\"结果是依然没有变化，实际上这里只是重新定义了切片的范围，原切片底层的存储数组没有发生变化，故不表现出任何变化。\",\"那要是我将该指针指向另外一个新切片呢？答案依然是不会变化，因为你拷贝的只是指针的副本，修改操作都是通过该指针来进行的，即使将该指针指向其他地址，原切片中的指针指向的还是原来的底层数组，还是不会展现出任何变化。\",\"总结：只有在修改切片内元素的时候，操作到了底层数组，才会展现出修改原切片的效果，其他操作都没有操作到底层数组，故不会展现出任何变化。\"]},\"69\":{\"h\":\"\",\"t\":[\"在 Go 语言中，数组（arr）和切片（slice）有一些重要的区别，特别是在使用和传递时的行为有所不同。\"]},\"70\":{\"h\":\"\",\"t\":[\"固定长度：\",\"数组在声明时需要指定固定的长度，并且长度在整个生命周期中都是不可变的。\",\"声明方式：var arr [5]int 或 arr := [5]int{1, 2, 3, 4, 5}。\",\"值传递：\",\"当将数组作为参数传递给函数时，传递的是数组的副本而不是引用。这意味着在函数内部对数组的修改不会影响外部的原始数组。\",\"性能优化：\",\"数组是在栈上分配内存的，访问速度较快，但长度固定。\"]},\"71\":{\"h\":\"\",\"t\":[\"动态长度：\",\"切片是对数组的一层轻量级封装，它的长度和容量可以动态改变。\",\"声明方式：var slice []int 或 slice := []int{1, 2, 3, 4, 5}。\",\"引用传递：\",\"切片在作为函数参数传递时，传递的是切片结构的副本，但仍然共享相同的底层数组。因此，在函数内部对切片的修改会影响外部的原始切片。\",\"灵活性：\",\"可以使用切片表达式、append 函数等对切片进行操作，支持动态增删元素。\"]},\"72\":{\"h\":\"\",\"t\":[\"下面是一个简单的示例，说明数组和切片在传递和使用时的区别：\",\"package main import \\\"fmt\\\" func modifyArray(arr [5]int) { arr[0] = 100 fmt.Println(\\\"函数内部修改数组:\\\", arr) // 输出: [100 2 3 4 5] } func modifySlice(slice []int) { slice[0] = 100 fmt.Println(\\\"函数内部修改切片:\\\", slice) // 输出: [100 2 3 4 5] } func main() { arr := [5]int{1, 2, 3, 4, 5} slice := arr[:] modifyArray(arr) fmt.Println(\\\"函数外部数组不受影响:\\\", arr) // 输出: [1 2 3 4 5] modifySlice(slice) fmt.Println(\\\"函数外部切片受影响:\\\", slice) // 输出: [100 2 3 4 5] }\"]},\"73\":{\"h\":\"\",\"t\":[\"数组是固定长度、值传递的数据结构，适合用于需要静态长度的场景。\",\"切片是动态长度、引用传递的数据结构，更加灵活，适合处理动态增删元素的需求。\"]},\"74\":{\"h\":\"1. Golang 介绍\"},\"75\":{\"h\":\"背景\",\"t\":[\"Golang（或称 Go 语言）是由 Google 开发的一种开源编程语言，首次发布于2009年。它由 Robert Griesemer、Rob Pike 和 Ken Thompson 设计，旨在提高编程效率，解决软件工程中的常见问题。Golang 的设计灵感来自 C 语言，但它加入了并发编程和垃圾回收等现代特性，适用于构建高性能的服务器端应用。\"]},\"76\":{\"h\":\"介绍\",\"t\":[\"Golang 是一门静态类型的编程语言，以其简洁的语法和高效的编译速度而闻名。它支持并发编程，通过 goroutines 和 channels 提供了强大的并发处理能力。Golang 的主要特点包括：\",\"简单易读：Golang 的语法简洁明了，减少了学习和使用的难度。\",\"高性能：Golang 编译后的二进制文件执行速度快，适合构建高性能应用。\",\"并发性：通过 goroutines 和 channels 支持并发编程，轻松处理大量并发任务。\",\"跨平台：Golang 可以编译成跨平台的可执行文件，支持 Windows、macOS 和 Linux 等操作系统。\",\"丰富的标准库：Golang 提供了丰富的标准库，涵盖网络、文件系统、编码解码等常见功能。\"]},\"77\":{\"h\":\"应用\",\"t\":[\"Golang 由于其高性能和简洁性，在多个领域得到了广泛应用，主要包括：\",\"Web 开发：使用流行的框架如 Gin、Echo 和 Beego，可以快速构建高性能的 Web 应用和 API 服务。\",\"微服务架构：Golang 由于其高并发处理能力和小内存占用，成为微服务架构的首选语言之一。\",\"云计算：Golang 被广泛应用于云计算平台和工具的开发，如 Docker 和 Kubernetes。\",\"系统编程：Golang 的性能和效率使其适合用于系统级编程和网络服务器开发。\",\"数据处理：Golang 的并发特性使其在数据处理和流处理领域表现出色，适用于实时数据分析和处理。\"]},\"78\":{\"h\":\"结论\",\"t\":[\"Golang 以其简洁、高效和强大的并发处理能力，成为现代软件开发中的一颗新星。无论是 Web 开发、微服务架构、云计算，还是系统编程和数据处理，Golang 都能提供强大的支持。对于希望构建高性能、高并发应用的开发者来说，Golang 是一门值得学习和掌握的编程语言。\"]},\"79\":{\"h\":\"2. 环境配置\",\"t\":[\"正式学习 Golang 之前首先需要安装配置好 Golang 环境，如果您已经配好环境，跳过即可。\"]},\"80\":{\"h\":\"Golang环境\",\"t\":[\"下载地址：https://golang.google.cn/dl/\",\"选择适合自己的版本进行下载即可\",\"https://golang.google.cn/doc/install\",\"配置变量\",\"如果完全按照如上步骤进行操作，仍无法通过 go 环境检查，请重启电脑使得环境变量生效即可。\"]},\"81\":{\"h\":\"开发工具\",\"t\":[\"工欲善其事，必先利其器。一个好的开发工具能让你事半功倍，大大提高开发效率，这里我推荐 VsCode 和 Goland 这两个开发工具。\"]},\"82\":{\"h\":\"VSCode\",\"t\":[\"下载安装：https://code.visualstudio.com/\",\"下载好后安装即可。\",\"配置 Golang 插件\",\"使用 VSCode 可以直接使用我们配置好的环境变量。\"]},\"83\":{\"h\":\"Goland\",\"t\":[\"下载安装：https://www.jetbrains.com/go/\",\"下载后安装即可。\",\"配置 Golang\",\"配置 GOROOT、GOPATH、GOModuls 为你自己下载安装的对应目录即可。\",\"这里配置时，可以使用 Goland 自带的 Go 下载，也可以配置我们自己下载的 Golang。\",\"优缺点对比：\",\"VSCode 轻量级，还可开发其他任意语言。Goland 仅对 Golang 有较好支持。\",\"VSCode 免费开源，有强大的生态支持，Goland Unlimited 版本收费，且价格较高。\",\"Goland 可视化界面优秀，对于调试开发更为优雅舒适，VSCode 需要配置插件，较为麻烦。\",\"Goland 内置了许多功能，且有 AI 功能，无需其他配置，开箱即用，非常方便。VSCode 功能全靠插件，需要自己配置安装。\",\"总结：VSCode 和 Goland 各有优缺，选择合适自己的开发工具即可，两者也可同时兼备，无需精神内耗。\"]},\"84\":{\"h\":\"13. 错误\",\"t\":[\"在Go语言中，错误（errors）是一个非常重要的概念，它们用于指示函数调用或操作是否成功以及发生了什么问题。Go语言通过内置的 error 接口类型来表示错误，这使得错误处理变得非常简洁和统一。\"]},\"85\":{\"h\":\"错误接口\",\"t\":[\"在Go中，error 接口是一个只包含一个方法的接口：\",\"type error interface { Error() string }\",\"任何实现了 Error() string 方法的类型都可以被视为一个错误。这意味着，如果你想要定义自己的错误类型，只需实现这个方法即可。\"]},\"86\":{\"h\":\"标准库中的错误处理\",\"t\":[\"标准库中的许多函数都会返回一个结果值和一个错误值。通常，错误值被用来指示函数执行过程中是否出现了问题，如果有问题，则返回一个非 nil 的错误值，并且结果值可能是一个默认值或者无效值。\",\"例如，os.Open 函数用于打开文件，它的签名是：\",\"func Open(name string) (*File, error)\",\"在调用这个函数后，你需要检查第二个返回值，即错误值，来判断文件是否成功打开。如果错误值为 nil，则表示打开文件操作成功；否则，你可以根据错误值判断发生了什么问题。\"]},\"87\":{\"h\":\"创建自定义错误\",\"t\":[\"在Go中创建自定义错误通常很简单，可以使用 errors.New 函数来创建一个新的错误。例如：\",\"import \\\"errors\\\" func someFunction() error { return errors.New(\\\"something went wrong\\\") }\",\"这样就创建了一个简单的错误，其错误消息为 \\\"something went wrong\\\"。\"]},\"88\":{\"h\":\"处理错误\",\"t\":[\"在Go中，通常使用 if err != nil 的方式来检查错误。这是因为在函数调用失败时，它会返回一个非 nil 的错误值。例如：\",\"result, err := someFunction() if err != nil { // 处理错误，例如打印错误信息或者进行其他操作 fmt.Println(\\\"Error:\\\", err) return } // 如果没有错误，继续处理结果 fmt.Println(\\\"Result:\\\", result)\"]},\"89\":{\"h\":\"错误链\",\"t\":[\"有时候一个操作会调用另一个可能出错的操作，这时候可能需要将多个错误链接在一起。Go语言通过 errors.Wrap 和 errors.Wrapf 函数来实现错误链，这些函数允许将当前的错误包装起来并添加上下文信息。\",\"import \\\"github.com/pkg/errors\\\" func main() { err := doSomething() if err != nil { // 在错误链上包装更多信息 wrappedErr := errors.Wrap(err, \\\"failed to do something\\\") fmt.Println(wrappedErr) } } func doSomething() error { return errors.New(\\\"something went wrong\\\") }\",\"这样就创建了一个包含更多上下文信息的错误。\",\"总结来说，Go语言的错误处理机制非常简单且灵活，使得开发者可以清晰地处理和传播错误信息，确保程序在面对异常情况时能够安全和可靠地执行。\"]},\"90\":{\"h\":\"6. 函数方法\",\"t\":[\"在 Golang 中函数是对代码封装和重用的基本形式，与 Java 、C/C++ 不同的是，Golang 中的函数功能似乎更加强大，不仅可以当做代码的封装，还可以当做变量，也可以作为参数进行传递。\",\"以下是 Golang 函数的定义、调用、参数、返回值、匿名函数、闭包等方面的详细说明：\"]},\"91\":{\"h\":\"函数\"},\"92\":{\"h\":\"1. 函数定义与调用\",\"t\":[\"函数定义使用 func 关键字，具体如下：\",\"// 函数定义 func add(a int, b int) int { return a + b } // 函数调用 result := add(2, 3) // result == 5\",\"add : 函数名称\",\"(a int, b int )：参数列表\",\"int : 返回值类型\"]},\"93\":{\"h\":\"2. 参数与返回值\",\"t\":[\"多参数函数：可以定义多个参数，参数类型可以相同或不同。\",\"func multiply(x int, y int) int { return x * y }\",\"多返回值函数：函数可以返回多个值。\",\"func divide(x, y int) (int, int) { return x / y, x % y } quotient, remainder := divide(10, 3) // quotient == 3, remainder == 1\",\"这和 Java 等语言中函数只能返回一个值不同。\",\"命名返回值：可以为返回值命名，使得返回值在函数体内被赋值时无需显示 return。\",\"func rectangleArea(width, height int) (area int) { area = width * height return // 可直接隐藏，可用于控制逻辑执行 }\",\"这里可以看做是在函数调用之前就初始化好了返回值变量，故这里不必定义可直接使用。\"]},\"94\":{\"h\":\"3. 可变参数函数\",\"t\":[\"可变参数：函数可以接收变长参数列表。\",\"func sum(nums ...int) int { total := 0 for _, num := range nums { total += num } return total } total := sum(1, 2, 3, 4) // total == 10\"]},\"95\":{\"h\":\"4. 匿名函数\",\"t\":[\"匿名函数：函数可以是匿名的，并且可以赋值给变量或作为参数传递。\",\"add := func(a, b int) int { return a + b } result := add(3, 4) // result == 7\"]},\"96\":{\"h\":\"5. 闭包\",\"t\":[\"闭包：匿名函数可以访问其外层作用域中的变量，即使这些变量不在其参数列表中。\",\"func makeMultiplier(factor int) func(int) int { return func(x int) int { return x * factor } } double := makeMultiplier(2) result := double(5) // result == 10\",\"匿名函数和闭包有啥区别？\",\"区别\",\"匿名函数是指没有名称的函数，可以被直接调用或者作为值传递给其他函数。\",\"闭包是指一个函数值，可以访问其定义时外部作用域中的变量，即使在定义时所在的作用域已经不存在，这些变量仍然可以被访问和操作。\",\"使用场景\",\"使用匿名函数可以简化代码结构，将一些逻辑封装成临时使用的函数。\",\"使用闭包可以实现状态的保持和管理，特别适合需要持久化状态或者捕获动态变化的场景。\"]},\"97\":{\"h\":\"6. 递归函数\",\"t\":[\"递归：函数可以调用自身来解决问题。但需要明确出退出条件，否则会无限递归，导致栈溢出。\",\"func factorial(n int) int { if n <= 1 { return 1 } return n * factorial(n-1) } result := factorial(5) // result == 120\"]},\"98\":{\"h\":\"7. 函数作为参数和返回值\",\"t\":[\"函数作为参数：函数可以作为参数传递给其他函数。\",\"func apply(fn func(int, int) int, a int, b int) int { return fn(a, b) } result := apply(add, 5, 6) // result == 11\",\"函数作为返回值：函数可以返回另一个函数。\",\"func makeAdder(x int) func(int) int { return func(y int) int { return x + y } } add5 := makeAdder(5) result := add5(3) // result == 8\"]},\"99\":{\"h\":\"8. 延迟执行 ( )\",\"t\":[\"延迟执行：defer 语句可以延迟函数或方法的执行直到封闭函数返回。\",\"func main() { defer fmt.Println(\\\"World\\\") fmt.Println(\\\"Hello\\\") } // Output: // Hello // World\",\"多个 Defer 调用根据后进先出的顺序执行，类似于栈。\"]},\"100\":{\"h\":\"9. 错误处理\",\"t\":[\"错误处理：通过返回值和内置的 error 类型进行错误处理。\",\"func divide(x, y int) (int, error) { if y == 0 { return 0, fmt.Errorf(\\\"division by zero\\\") } return x / y, nil } result, err := divide(10, 0) if err != nil { fmt.Println(\\\"Error:\\\", err) }\"]},\"101\":{\"h\":\"方法\",\"t\":[\"方法是定义在类型上的函数，在 Golang 中方法与函数的区别在于，方法拥有接收者，而函数没有，且只有自定义类型能够拥有方法。\",\"type Rectangle struct { width, height int } func (r Rectangle) Area() int { return r.width * r.height } rect := Rectangle{10, 5} area := rect.Area() // area == 50\",\"这个案例中大体上和函数基本类似，只在函数名前面多了 (r Rectangle)，这定义了方法的接收者为 r，Rectangle 就是方法的接收者类型，说明方法属于该接收者，调用时需要使用到该接收者。\",\"方法的接收者分为 值接收者 和 指针接收者 两种类型\",\"值接收者\",\"type MyInt int func (m MyInt) Double() { m = m * 2 } func main() { var x MyInt = 10 var y int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"初始 x 的值为: \\\", y) // 输出: 初始 x 的值为: 10 x.Double() var z int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"成倍后 x 的值为: \\\", z) // 输出: 成倍后 x 的值为: 10 }\",\"这里调用了 Double 方法，是将 MyInt 类型的 x 变成两倍，但是实际的输出是：\",\"初始 x 的值为: 10 成倍后 x 的值为: 10\",\"并没有达到成倍的效果，这是因为这里方法的接收者是值，在方法被调用时，会将接收者的值传入方法中，可以类似的看为形参，在方法内修改形参的值，并不会对方法外面的值进行改变。\",\"如果要是通过指针调用会如何呢？\",\"func main() { var x MyInt = 10 var y int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"初始 x 的值为: \\\", y) // 输出: 初始 x 的值为: 10 (&x).Double() var z int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"成倍后 x 的值为: \\\", z) // 输出: 成倍后 x 的值为: 10 }\",\"事实上，输出的仍然是上述结果，这是因为为了能够和接收者类型进行匹配，Golang 自行进行进行了解引用操作，将 (&x).Double() 解析为(*(&x)).Double() ，以便于匹配 (m MyInt) 的接收者类型。\",\"指针接收者\",\"将上述代码进行修改，将值接收者变为指针接收者\",\"type MyInt int func (m *MyInt) Double() { *m = *m * 2 } func main() { var x MyInt = 10 var y int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"初始 x 的值为: \\\", y) // 输出: 初始 x 的值为: 10 x.Double() var z int = int(x) // 将 MyInt 的值转换为 int fmt.Println(\\\"成倍后 x 的值为: \\\", z) // 输出: 成倍后 x 的值为: 20 }\",\"执行后的结果为：\",\"初始 x 的值为: 10 成倍后 x 的值为: 20\",\"此时成功的修改了 x 的值，此时即便我们没有使用指针调用，依然能够修改成功，这也是因为 Golang 为了成功匹配接收者的类型，帮我们做了引用，将 x.Double() 转换为了 (&x).Double()，故方法的接收者为指针时，不管调用者是不是指针，都可以修改内部的值。\",\"函数参数的传递过程中，是值拷贝，也就是将原来的值复制一份传递，故修改形参时，不会影响原有的值。传递指针时，也是将指针的内容复制一份传递，但是由于两个指针所指向的是同一个地址，此时再通过该指针来修改形参，也会造成原值的变化，从而实现了原值的修改。\",\"了解到这些之后，可以思考切片这种类型做为参数传递，是否会修改原值？\",\"答案是：会修改原值。原因如下：在前面 数据类型的小节中，说明了切片这种数据类型底层实际上存储了指向切片的指针，对切片的操作是通过该指针来进行的，故在修改形参后，对应的也会造成原值的改变。\",\"和 Java 中不同的是，Golang 中的数组是直接存储在内存中的值，作为参数传递时会传递数组的副本，修改形参并不会对原值曹成变化，但是 Java 中是通过引用传递数组的，故会修改原值。\",\"方法和函数的区别\",\"方法和函数的却别，类似于 Java 中的 类方法 和 对象方法，即函数的归属不同。\",\"在 Golang 中接收者不能直接调用属于包的函数，只能直接调用自身绑定的方法，但是可以在这些方法的内部实现中访问包中的函数。\"]},\"102\":{\"h\":\"访问控制\",\"t\":[\"Golang 中的访问控制是通过其名称的第一个首字母进行区分的：\",\"大写字母开头：导出（exported），可以被其他包访问。\",\"小写字母开头：未导出（unexported），仅在包内可见。\",\"这种约定适用于 Go 的所有标识符，包括变量、常量、函数、类型（结构体、接口等）、字段和方法。\",\"Golang 的访问控制机制简化了代码结构，主要关注于包级别的访问限制。设计理念主要有以下几个方面：\",\"明确性：通过首字母大小写，访问控制一目了然。\",\"简洁性：避免了复杂的访问控制规则。\",\"包为单位：所有访问控制以包为基本单位，有助于实现良好的包封装\",\"如果想访问其内部的数据，可借助辅助函数或者接口\",\"辅助函数：可以定义类似于 Get、Set 类似的辅助函数，从而实现对没有权限的数据的访问。\",\"接口：虽然结构体字段可以是未导出的，但如果字段实现了某个接口的方法，并且该接口是导出的，依然可以通过接口访问其功能。\",\"这些是 Golang 函数的主要特性和用法示例，每个特性提供了强大的工具来处理函数的定义、调用、参数传递、返回值以及高级用法。在实际的开发中，函数是最高频被使用到的技术点，需要熟练掌握。\"]},\"103\":{\"h\":\"12. 泛型\",\"t\":[\"Go语言在1.18版本引入了泛型，使得函数和数据结构可以处理任意类型的数据，而不需要为每种类型编写单独的代码。泛型通过类型参数和类型约束实现，这大大增强了Go语言的灵活性和可重用性。\"]},\"104\":{\"h\":\"开始之前\",\"t\":[\"在正式了解泛型之前先看一个经常在开发中遇到的问题，求两数之和\",\"func sum(a int,b int) int{ return a + b }\",\"该函数可以求两个整数的和，那么要是求两个浮点数的和呢？很简单，再写一个函数不就行了吗？\",\"func sum(a float32,b float32) float32{ return a + b }\",\"没错，再写一个函数确实可以实现这个需求，那么再加一些需求，要求 int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64 这些类型的和呢？也对每一个类型都写一个求和函数吗？\",\"确实，这样是可以实现，但是不难发现，实际上的实现逻辑都是相同的，只是数据类型不同，要是能将数据类型变成一个变量传进来，根据传进来的变量动态的控制数据类型，不就可以了吗？\",\"很好，这个传进来的数据类型的变量，就是泛型。\"]},\"105\":{\"h\":\"泛型函数\",\"t\":[\"一个简单的泛型函数定义如下：\",\"func Print[T any](s []T) { for _, v := range s { fmt.Println(v) } }\",\"这里的 T 是一个类型参数，any 是一个预定义的接口，表示任意类型。这个函数可以接受任何类型的切片作为参数：\",\"ints := []int{1, 2, 3} strings := []string{\\\"a\\\", \\\"b\\\", \\\"c\\\"} Print(ints) Print(strings)\"]},\"106\":{\"h\":\"泛型类型\",\"t\":[\"泛型不仅可以用于函数，还可以用于定义数据结构，例如泛型列表：\",\"type List[T any] struct { items []T } func (l *List[T]) Add(item T) { l.items = append(l.items, item) } func (l *List[T]) Get(index int) T { return l.items[index] }\",\"这样就可以创建不同类型的列表，而不需要重复代码：\",\"intList := List[int]{} intList.Add(1) intList.Add(2) fmt.Println(intList.Get(0)) // 输出 1 stringList := List[string]{} stringList.Add(\\\"a\\\") stringList.Add(\\\"b\\\") fmt.Println(stringList.Get(0)) // 输出 a\"]},\"107\":{\"h\":\"类型约束\",\"t\":[\"类型参数可以有约束条件，使得泛型函数或类型只能接受特定类型。例如，只接受可比较的类型：\",\"type Comparable interface { comparable } func Max[T Comparable](a, b T) T { if a > b { return a } return b }\",\"使用 comparable 约束，Max 函数只能用于可比较的类型（即实现了==和!=操作的类型）：\",\"fmt.Println(Max(3, 5)) // 输出 5 fmt.Println(Max(\\\"a\\\", \\\"b\\\")) // 输出 b\"]},\"108\":{\"h\":\"多个类型参数\",\"t\":[\"泛型函数和类型可以有多个类型参数：\",\"func Map[K comparable, V any](m map[K]V) []K { keys := make([]K, 0, len(m)) for k := range m { keys = append(keys, k) } return keys } m := map[string]int{\\\"one\\\": 1, \\\"two\\\": 2, \\\"three\\\": 3} keys := Map(m) fmt.Println(keys) // 输出 [one two three]（顺序可能不同）\"]},\"109\":{\"h\":\"使用约束定义接口\",\"t\":[\"你可以使用类型约束来定义接口，以便限制泛型类型的使用范围。例如，定义一个接口Number，它限制类型参数必须是数值类型：\",\"type Number interface { int | int32 | int64 | float32 | float64 } func Sum[T Number](s []T) T { var sum T for _, v := range s { sum += v } return sum } ints := []int{1, 2, 3, 4, 5} floats := []float64{1.1, 2.2, 3.3} fmt.Println(Sum(ints)) // 输出 15 fmt.Println(Sum(floats)) // 输出 6.6\"]},\"110\":{\"h\":\"泛型的优势\",\"t\":[\"代码复用：泛型允许编写通用函数和数据结构，而无需针对每种类型编写特定的实现。\",\"类型安全：相比于使用空接口（interface{}），泛型提供了编译时的类型检查，减少了运行时错误。\",\"简化代码：减少了重复代码，使代码更简洁、更易读。\",\"通过泛型，Go语言可以更灵活地处理各种数据类型，进一步增强了代码的可重用性和可维护性。\"]},\"111\":{\"h\":\"11. 接口\",\"t\":[\"在 Golang 中，接口（interface）是一种定义对象行为的方式，它是方法集合的抽象表示。接口定义了对象可以响应的方法集合，而不关心具体实现，以及实现接口的类型。这种特性使得接口在 Golang 中非常强大和灵活，有助于实现面向对象编程的抽象和多态。\"]},\"112\":{\"h\":\"接口定义\",\"t\":[\"接口定义使用 type 关键字和 interface 关键字，例如：\",\"type Shape interface { Area() float64 Perimeter() float64 }\",\"上面的例子定义了一个Shape接口，它要求实现该接口的类型必须实现Area()和Perimeter()方法，这两个方法返回浮点数类型。\"]},\"113\":{\"h\":\"接口实现\",\"t\":[\"任何类型只要实现了接口定义的所有方法，就隐式地实现了该接口。例如，定义一个Rectangle结构体实现Shape接口：\",\"type Rectangle struct { width, height float64 } func (r Rectangle) Area() float64 { return r.width * r.height } func (r Rectangle) Perimeter() float64 { return 2 * (r.width + r.height) }\",\"这里，Rectangle结构体实现了Shape接口的Area()和Perimeter()方法，因此Rectangle类型就可以被赋值给Shape接口变量。\",\"在 Golang 中没有明确的继承和实现，只要你实现了接口中定义的所有方法，就相当于你实现了该接口，即可使用多态，将该类型的值赋值给接口类型的变量。\"]},\"114\":{\"h\":\"接口变量\",\"t\":[\"接口变量可以存储任何实现了接口的类型的值。例如，可以将Rectangle类型的变量赋值给Shape接口变量：\",\"var s Shape s = Rectangle{width: 3, height: 4}\"]},\"115\":{\"h\":\"空接口\",\"t\":[\"在Go语言中，空接口 interface{} 不包含任何方法，因此所有类型都实现了空接口，类似与 Java 中的一切对象继承自 Object。空接口对于需要处理未知类型的数据非常有用，例如函数参数或者存储任意类型的数据：\",\"func describe(i interface{}) { fmt.Printf(\\\"(%v, %T)\\\\n\\\", i, i) } describe(42) describe(\\\"hello\\\") describe(true)\"]},\"116\":{\"h\":\"接口断言\",\"t\":[\"接口变量可以通过类型断言来获取其底层具体类型的值。例如：\",\"r := s.(Rectangle) fmt.Println(\\\"Width:\\\", r.width, \\\"Height:\\\", r.height)\",\"需要注意的是，如果类型断言失败，会引发运行时恐慌。因此，为了安全地检查接口变量是否可以转换为特定类型，可以使用带有两个返回值的类型断言，如：\",\"r, ok := s.(Rectangle) if ok { fmt.Println(\\\"Width:\\\", r.width, \\\"Height:\\\", r.height) } else { fmt.Println(\\\"Assertion failed\\\") }\"]},\"117\":{\"h\":\"接口组合\",\"t\":[\"接口可以通过组合多个接口来定义新的接口：\",\"type Writer interface { Write([]byte) (int, error) } type Closer interface { Close() error } type ReadWriteCloser interface { Reader Writer Closer }\",\"这种方式可以创建更加具体的接口，以便在不同的场景中使用。\",\"接口是Go语言中实现多态和抽象的关键机制之一，通过接口，可以实现更加灵活和可扩展的代码结构。\"]},\"118\":{\"h\":\"5. 逻辑控制语句\"},\"119\":{\"h\":\"If 语句\",\"t\":[\"if 语句是编程语言中最为基础也是最重要的一个逻辑控制语句，以下是几种 if 语句的具体用法。\",\"if 语句\",\"if condition { // condition 为 true 时执行的语句 }\",\"if ... else 语句\",\"if condition { // condition 为 true 时执行的语句 } else { // condition 为 false 时执行的语句 }\",\"if ... else if ... else 语句\",\"if condition1 { // condition1 为 true 时执行的语句 } else if condition2 { // condition2 为 true 时执行的语句 } else { // condition1 和 condition2 都为 false 时执行的语句 }\",\"if 语句可以嵌套使用，以满足实际需求\"]},\"120\":{\"h\":\"Switch 语句\",\"t\":[\"Switah 语句用于进行多分支条件判断，替代多个 if ... else 结构，使代码更加简洁和易读。\",\"switch expression { case value1: // 当 expression 等于 value1 时执行的代码块 case value2: // 当 expression 等于 value2 时执行的代码块 default: // 当所有 case 都不匹配时执行的代码块（可选） }\",\"特点与注意事项\",\"无需使用 break 语句：Go 的 switch 语句在匹配到某个 case 后会自动跳出 switch 块，不需要像 C/C++ 或者 Java 中那样显式使用 break 来终止 case。\",\"多个匹配条件：可以在同一个 case 分支中指定多个匹配条件，用逗号分隔：\",\"switch day { case \\\"Saturday\\\", \\\"Sunday\\\": fmt.Println(\\\"Weekend\\\") default: fmt.Println(\\\"Weekday\\\") }\",\"空 switch 语句：如果 switch 关键字后没有表达式，那么它将作为一个 true 开关，可以用于条件逻辑：\",\"switch { case x > 0: fmt.Println(\\\"x is positive\\\") case x < 0: fmt.Println(\\\"x is negative\\\") default: fmt.Println(\\\"x is zero\\\") }\",\"带初始化语句的 switch：可以在 switch 语句中初始化一个变量，该变量的作用域仅限于 switch 内部：\",\"switch x := getValue(); x { case 1: fmt.Println(\\\"x is 1\\\") case 2: fmt.Println(\\\"x is 2\\\") default: fmt.Println(\\\"x is neither 1 nor 2\\\") }\",\"类型开关：switch 语句还可以用于类型断言，以便处理接口类型的不同实现：\",\"var i interface{} = \\\"hello\\\" switch v := i.(type) { case int: fmt.Println(\\\"i is an int\\\") case string: fmt.Println(\\\"i is a string\\\") default: fmt.Printf(\\\"i is of unknown type %T\\\\n\\\", v) }\",\"在这个例子中，v 被分配为 i 的类型断言结果，并根据 v 的类型选择不同的 case。\",\"Switch 适用于同一变量的多种条件，能够使得代码逻辑更加清晰，方便维护。\"]},\"121\":{\"h\":\"For 语句\",\"t\":[\"For 循环是一种常见的控制流结构，用于重复执行一段代码块，直到指定的条件不再满足为止。与其他编程语言不同，Golang 中没有提供 While 语句，但可以使用 Golang 来实现同样的效果。\",\"基本语法\",\"Go 中的 for 循环有三种基本形式：\",\"基本的 for 循环：\",\"for initialization; condition; post { // 循环体 }\",\"initialization：循环开始前执行的初始化语句，通常是变量声明或赋值。\",\"condition：循环的条件判断表达式，当条件为 false 时退出循环。\",\"post：每次循环迭代后执行的操作，通常是更新变量的语句。\",\"示例：\",\"package main import \\\"fmt\\\" func main() { for i := 1; i <= 5; i++ { fmt.Println(i) } }\",\"上述代码将输出从 1 到 5 的数字。\",\"类似于 while 的循环：\",\"Go 中没有 while 循环，但可以通过 for 循环模拟 while 循环：\",\"for condition { // 循环体 }\",\"示例：\",\"package main import \\\"fmt\\\" func main() { sum := 0 for sum < 10 { sum += 2 fmt.Println(sum) } }\",\"上述代码会输出 2、4、6、8、10，直到 sum 的值不再小于 10。\",\"无限循环：\",\"可以使用空的 for 循环来实现无限循环：\",\"for { // 无限循环体 }\",\"示例：\",\"package main import \\\"fmt\\\" func main() { count := 0 for { count++ if count > 5 { break } fmt.Println(\\\"Count:\\\", count) } }\",\"上述代码将输出 Count: 1 到 Count: 5，然后退出循环。\",\"for range 循环\",\"Go 还提供了一种特殊的 for range 循环，用于迭代数组、切片、字符串、映射等数据结构：\",\"for index, value := range collection { // 使用 index 和 value 进行操作 }\",\"示例：\",\"package main import \\\"fmt\\\" func main() { numbers := []int{1, 2, 3, 4, 5} for index, value := range numbers { fmt.Printf(\\\"Index: %d, Value: %d\\\\n\\\", index, value) } }\",\"这段代码会输出数组 numbers 中每个元素的索引和值。\",\"注意事项\",\"Go 中的 for 循环的三个部分 initialization、condition 和 post 都是可选的。\",\"for 循环没有括号 {} 之外的条件表达式，循环体必须用大括号 {} 括起来，即使只有一行代码。\"]},\"122\":{\"h\":\"range 关键字\",\"t\":[\"在Go语言中，range关键字用于迭代数组（array）、切片（slice）、字符串（string）、映射（map）以及通道（channel）等数据结构的元素。它的语法形式有所不同，取决于所迭代的数据结构。应该放\",\"迭代数组和切片\",\"对于数组和切片，range返回两个值：索引和元素值。例如：\",\"nums := []int{2, 3, 4} for index, value := range nums { fmt.Printf(\\\"Index: %d, Value: %d\\\\n\\\", index, value) }\",\"迭代字符串\",\"对于字符串，range返回两个值：索引和Unicode码点（对应的rune值）。例如：\",\"str := \\\"Hello\\\" for index, char := range str { fmt.Printf(\\\"Index: %d, Character: %c\\\\n\\\", index, char) }\",\"迭代映射（map）\",\"对于映射，range返回两个值：键和值。注意，映射的迭代顺序是随机的。例如：\",\"mymap := map[string]int{\\\"a\\\": 1, \\\"b\\\": 2, \\\"c\\\": 3} for key, value := range mymap { fmt.Printf(\\\"Key: %s, Value: %d\\\\n\\\", key, value) }\",\"迭代通道（channel）\",\"对于通道，range会迭代通道接收的数据，直到通道关闭。例如：\",\"ch := make(chan int) go func() { ch <- 1 ch <- 2 ch <- 3 close(ch) }() for num := range ch { fmt.Println(num) }\",\"在所有这些情况下，range提供了一种方便的方法来迭代数据结构的元素，它简化了对数据的遍历操作。\"]},\"123\":{\"h\":\"Select 语句\",\"t\":[\"在 Go 语言中，select 语句用于处理并发操作，特别是用于从多个通信通道中选择和执行不同的 case。以下是关于 select 语句在 Go 中的详细解释和用法说明：\",\"1. 基本语法\",\"select 语句类似于 switch 语句，但用于通信操作：\",\"select { case communicationCase1: // 处理通信1的逻辑 case communicationCase2: // 处理通信2的逻辑 default: // 当没有任何通信情况发生时执行的逻辑（可选） }\",\"case communicationCase1:：每个 case 都描述了一个通信操作，它可以是 channel 的发送或接收操作。\",\"default:：default 分支在所有 case 都不满足时执行，它是可选的。\",\"2. 示例\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) func main() { ch1 := make(chan string) ch2 := make(chan string) go func() { time.Sleep(2 * time.Second) ch1 <- \\\"message from ch1\\\" }() go func() { time.Sleep(1 * time.Second) ch2 <- \\\"message from ch2\\\" }() select { case msg1 := <-ch1: fmt.Println(\\\"Received\\\", msg1) case msg2 := <-ch2: fmt.Println(\\\"Received\\\", msg2) default: fmt.Println(\\\"No communication\\\") } }\",\"在这个示例中，select 语句会等待并接收来自 ch1 和 ch2 通道的消息，并打印出第一个准备好的消息。由于 ch2 的消息比 ch1 的消息先准备好，因此输出结果会是 \\\"Received message from ch2\\\"。\",\"3. 特点与注意事项\",\"select 语句在每次执行时，都会随机选择一个满足条件的 case 执行。如果多个 case 同时准备好，Go 会随机选择其中之一。\",\"如果没有任何 case 准备好，并且存在 default 分支，则会执行 default 分支的代码。\",\"select 语句可以和 for 循环结合使用，实现不断地监听多个通道的消息。\",\"select 中的 case 可以是发送操作、接收操作或者仅仅是用于阻塞当前 goroutine 的操作。\",\"4. 使用场景\",\"多路复用通信：当需要从多个通道中接收消息时，select 是一个非常有用的工具，可以有效地管理并发通信。\",\"超时控制：结合 time.After() 和 select 可以实现超时控制，例如在一定时间内等待某个操作完成或者超时返回默认结果。\",\"5. 总结\",\"select 语句是 Go 语言中处理并发编程的重要工具之一，通过选择和处理多个通道中的消息，可以简化并发程序的编写和管理。了解并熟练使用 select 可以提升代码的可读性和性能。\",\"上述的所有逻辑控制语句均可嵌套使用，从而达到流程控制的作用。这几个语句最为重要，也必须熟练掌握。\"]},\"124\":{\"h\":\"10. Map 集合\",\"t\":[\"在 Go 语言中，map 是一种内置的数据结构，用于存储键值对。它是一种无序集合，提供了非常高效的查找、插入和删除操作。所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，遍历 Map 时返回的键值对的顺序是不确定的。\"]},\"125\":{\"h\":\"声明和初始化\",\"t\":[\"Map 的声明语法如下所示\",\"var map [key]value\",\"由于 Map 是 Golang 内置的数据结构，故可以使用 make 函数来创建 map 实例\",\"m := make(map[string]int) // 也可使用字面量进行初始化 m := map[string]int{ \\\"Alice\\\": 25, \\\"Bob\\\": 30, }\"]},\"126\":{\"h\":\"操作map\",\"t\":[\"查询\",\"仅获取对应键的值\",\"bob := m[\\\"Bob\\\"]\",\"获取对应键的值，并且判断键是否存在\",\"age, exists := m[\\\"David\\\"] if exists { fmt.Println(\\\"David's age is\\\", age) } else { fmt.Println(\\\"David is not in the map\\\") }\",\"在获取 Map 的值时，如果键不存在，返回该类型的零值，例如 int 类型的零值是 0，string 类型的零值是 \\\"\\\"。\",\"插入或更新\",\"插入和更新操作是相同的，它首先会去更新，如果不存在则插入。\",\"m[\\\"height\\\"] = 180\",\"删除\",\"使用 delete 函数来删除指定的键值对\",\"delete(m, \\\"Bob\\\")\",\"获取map长度\",\"使用 len 函数来获取 map 集合的长度，该长度为键值对的个数\",\"mapLen := len(m)\",\"遍历\",\"for name, age := range m { fmt.Printf(\\\"%s is %d years old\\\\n\\\", name, age) }\",\"作为参数传递\",\"Map 是引用类型，如果将一个 Map 传递给一个函数或赋值给另一个变量，它们都指向同一个底层数据结构，因此对 Map 的修改会影响到所有引用它的变量。\",\"map 的特性\",\"无序：map 中的键值对是无序的，遍历时的顺序不一定与插入顺序相同。\",\"键的类型：map 的键可以是任何支持 == 和 != 操作的类型，如布尔型、数字、字符串、指针、接口类型（只要动态类型支持 ==）、结构体（只要所有字段支持 ==）等。切片、函数和包含切片的结构体不能作为键。\",\"值的类型：map 的值可以是任何类型。\",\"零值：map 的零值是 nil，未初始化的 map 不能直接存储键值对。\"]},\"127\":{\"h\":\"并发安全\",\"t\":[\"Go 中的 map 本身不是并发安全的。如果在多个 goroutine 中同时读写同一个 map，可能会导致数据竞态和程序崩溃。可以使用 sync.Mutex 或 sync.RWMutex 来保护 map 的并发访问，或者使用 sync.Map，它是一个并发安全的 map 实现：\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) func main() { var m sync.Map // 存储值 m.Store(\\\"Alice\\\", 25) m.Store(\\\"Bob\\\", 30) // 加载值 age, ok := m.Load(\\\"Alice\\\") if ok { fmt.Println(\\\"Alice's age:\\\", age) } // 遍历 m.Range(func(key, value interface{}) bool { fmt.Printf(\\\"%s is %d years old\\\\n\\\", key, value) return true }) }\"]},\"128\":{\"h\":\"特殊情况NaN\",\"t\":[\"这里要注意一个特殊情况，math.NaN() 并不是一个可比较的值，当其作为 key 时，因为 NaN（Not-a-Number） 与任何值（包括它自己）比较都不相等。\",\"使用 math.NaN() 作为 map 的键会导致不可预测的行为，或者编译时错误。以下是一个示例，展示为什么不能使用 math.NaN() 作为 map 的键：\",\"示例\",\"package main import ( \\\"fmt\\\" \\\"math\\\" ) func main() { m := make(map[float64]string) // 尝试使用 NaN 作为键 nan := math.NaN() m[nan] = \\\"Not-a-Number\\\" // 检查 NaN 是否在 map 中 val, exists := m[nan] fmt.Printf(\\\"Key exists: %v, Value: %v\\\\n\\\", exists, val) // 尝试使用另外一个 NaN 作为键来获取值 anotherNaN := math.NaN() val, exists = m[anotherNaN] fmt.Printf(\\\"Another key exists: %v, Value: %v\\\\n\\\", exists, val) }\",\"输出\",\"Key exists: true, Value: Not-a-Number Another key exists: false, Value:\",\"这个示例展示了以下几点：\",\"即使在 map 中插入了一个键 nan，查找时依然无法找到它，因为 NaN 不等于任何值（包括它自己）。\",\"exists 会返回 false，因为 anotherNaN 不等于 nan，即使它们都是 NaN。\",\"解决方案\",\"为了避免这种情况，不要使用 NaN 作为 map 的键。如果你有一个包含 NaN 的数据集，需要对其进行查找操作，考虑使用其他数据结构或转换策略来处理这些值。\",\"其他可比较类型的键\",\"在 Go 中，可以作为 map 键的类型包括：\",\"基本类型：int, float64, string, bool\",\"结构体类型（如果它们的所有字段都是可比较的类型）\",\"指针类型\",\"自定义类型（如果它们支持比较操作）\"]},\"129\":{\"h\":\"4. 运算符\"},\"130\":{\"h\":\"算术运算符\",\"t\":[\"+ 加法\",\"- 减法\",\"* 乘法\",\"/ 除法\",\"% 取模（求余）\",\"a := 10 b := 3 sum := a + b // 13 diff := a - b // 7 product := a * b // 30 quotient := a / b // 3 remainder := a % b // 1\"]},\"131\":{\"h\":\"关系运算符\",\"t\":[\"== 等于\",\"!= 不等于\",\"< 小于\",\"> 大于\",\"<= 小于等于\",\">= 大于等于\",\"a := 10 b := 5 isEqual := (a == b) // false isNotEqual := (a != b) // true isLess := (a < b) // false isGreaterOrEqual := (a >= b) // true\"]},\"132\":{\"h\":\"逻辑运算符\",\"t\":[\"&& 与\",\"|| 或\",\"! 非\",\"isTrue := true isFalse := false andResult := isTrue && isFalse // false orResult := isTrue || isFalse // true notResult := !isTrue // false\"]},\"133\":{\"h\":\"位运算符\",\"t\":[\"& 按位与\",\"| 按位或\",\"^ 按位异或\",\"<< 左移\",\">> 右移\",\"a := 5 // 二进制: 101 b := 3 // 二进制: 011 andResult := a & b // 1 (二进制: 001) orResult := a | b // 7 (二进制: 111) xorResult := a ^ b // 6 (二进制: 110) leftShift := a << 1 // 10 (二进制: 1010) rightShift := a >> 1 // 2 (二进制: 10)\"]},\"134\":{\"h\":\"赋值运算符\",\"t\":[\"= 简单赋值\",\"+= 加法赋值\",\"-= 减法赋值\",\"*= 乘法赋值\",\"/= 除法赋值\",\"%= 求余赋值\",\"<<= 左移赋值\",\">>= 右移赋值\",\"&= 按位与赋值\",\"|= 按位或赋值\",\"^= 按位异或赋值\",\"a := 10 b := 5 a += b // 等同于 a = a + b\"]},\"135\":{\"h\":\"其他运算符\",\"t\":[\"& 取址运算符\",\"* 指针运算符\",\". 结构体成员访问\",\"[] 数组、切片索引\",\"var i int = 10 var ptr *int ptr = &i // ptr 指向变量 i 的地址 var j int = *ptr // 取出指针并获取值 type Person struct{ name string age int } var person Person = Person{ name : \\\"CoderMast\\\", age : 18, } var name = person.name var personArr []Person;\"]},\"136\":{\"h\":\"运算符的优先级\",\"t\":[\"和数学中类似，Go语言中，运算符有不同的优先级，这影响了表达式中运算符执行的顺序。以下是Go语言中常见运算符的优先级，从高到低排列：\",\"一元运算符：\",\"+（正号）\",\"-（负号）\",\"!（逻辑非）\",\"^（按位取反）\",\"乘性运算符：\",\"*（乘法）\",\"/（除法）\",\"%（取模）\",\"加性运算符：\",\"+（加法）\",\"-（减法）\",\"位移运算符：\",\"<<（左移）\",\">>（右移）\",\"位运算符：\",\"&（按位与）\",\"|（按位或）\",\"^（按位异或）\",\"比较运算符：\",\"==（等于）\",\"!=（不等于）\",\"<（小于）\",\"<=（小于等于）\",\">（大于）\",\">=（大于等于）\",\"逻辑运算符：\",\"&&（逻辑与）\",\"逻辑运算符：\",\"||（逻辑或）\",\"赋值运算符：\",\"=（简单赋值）\",\"+=、-=、*=、/=、%=、<<=、>>=、&=、|=、^=（复合赋值运算符）\",\"运算符的优先级决定了表达式中各部分的计算顺序。例如，乘法运算符*的优先级高于加法运算符+，因此在表达式 a + b * c 中，先计算 b * c，然后再加上 a。\",\"除了优先级外，还有一些运算符是右结合的，例如赋值运算符=，意味着它从右向左结合。例如，a = b = 5 在Go语言中是合法的，先将 5 赋给 b，然后将 b 的值再赋给 a。\",\"这些规则有助于编写清晰且按预期执行的表达式。\",\"可使用括号来提升表达式中指定运算符的优先级，从而实现需求。\"]},\"137\":{\"h\":\"8. 指针\",\"t\":[\"在 C/C++ 中提供了指针这种类型，可以直接操作内存数据，在某些应用场景下非常实用。Golang 中也提供了指针，可以利用指针来简化一些任务的执行。虽然 Golang 提供了指针，但是由于操作指针的风险较大，考虑到这一点，Golang 同时也限制了指针的使用。\",\"指针是什么？\",\"指针是一个特殊类型的变量，用来存储其他变量的内存地址。指针变量指向一个内存地址，通过这个地址可以间接访问对应的变量。\"]},\"138\":{\"h\":\"声明指针\",\"t\":[\"在 Golang 中声明一个指针变量需要使用 * 符号，放在变量名前，表示这是一个指针类型的变量。\",\"var pointer *int // 一个指向整数类型的指针变量\"]},\"139\":{\"h\":\"获取变量地址\",\"t\":[\"获取变量的地址需要使用 & 符号，放在变量名前，表示取该变量的地址。\",\"var num = 10 pointer := &num // pointer 指向变量 num 的内存地址\"]},\"140\":{\"h\":\"访问指针的值\",\"t\":[\"通过 * 操作符，可以访问指针变量所指向的值。\",\"num := 10 ptr := &num fmt.Println(ptr) // 输出 0x1400012a0b0 fmt.Println(*ptr) // 输出 10\"]},\"141\":{\"h\":\"作为参数\",\"t\":[\"指针变量作为参数进行传递时，本质上还是传递的是指针的副本，只不过该副本中的内容和原指针变量的内容相同，所以通过地址来操作数据时，原数据也会发生改变。\",\"// 交换两个数的值 func swap(i *int, j *int) { var tmp = *i *i = *j *j = tmp } func main() { x := 5 y := 8 fmt.Printf(\\\"x : %d, y : %d\\\", x, y) // 输出 x : 5, y : 8 swap(&x, &y) fmt.Printf(\\\"x : %d, y : %d\\\", x, y) // 输出 x : 8, y : 5 }\"]},\"142\":{\"h\":\"指针运算\",\"t\":[\"在 C/C++ 中支持指针运算，可以通过一个指针，访问其指定偏移量的数据，自由度较高。虽然在 Golang 中也提供了指针，但是实际上是禁止了大部分指针运算的，原因是指针运算比较危险，很容易造成系统崩溃。\",\"下面是一段 C语言 的指针运算案例：\",\"#include <stdio.h> int main() { int arr[] = {1, 2, 3, 4, 5}; int* p = arr; // 指向数组的第一个元素 // 使用指针遍历数组 for (int i = 0; i < 5; ++i) { printf(\\\"Element %d: %d\\\\n\\\", i, *p); ++p; // 移动指针到下一个元素 } // 重置指针回到数组的第一个元素 p = arr; // 使用指针算术运算访问数组的特定元素 p = p + 2; printf(\\\"Third element (using pointer arithmetic): %d\\\\n\\\", *p); return 0; }\",\"在 C 语言中可以直接进行指针的运算，从而访问指定的数据，但这也就意味着，只要能够拿到对应的数据地址，即可访问，这是极度危险的。\",\"使用 unsafe 包进行指针运算\",\"如果你确实需要进行类似于 C/C++ 的指针算术运算，可以使用 unsafe 包。不过，这种方法应谨慎使用，因为它会绕过 Go 语言的内存安全检查，可能导致不可预知的行为。\"]},\"143\":{\"h\":\"空指针\",\"t\":[\"当一个指针被定义后没有分配到任何变量的时候，它的值为 nil，即空指针\",\"var pointer *int\",\"指针变量声明后，默认零值为 nil，即空指针。\",\"空指针判断\",\"if pointer == nil { // 空指针时执行 }\"]},\"144\":{\"h\":\"指针的指针\",\"t\":[\"指针是指向变量内存地址的值，这个值同样也是存储在内存中，存储到内存中的值也必然会占用内存，也会有地址。故有指针的指针。\",\"num := 10 var pointer1 = &num var pointer2 = &pointer1\",\"pointer1 即为 num 的指针\",\"pointer2 即为 pointer1 的指针，即指针的指针\",\"依次类推，可以有无限指针的循环嵌套\"]},\"145\":{\"h\":\"指针数组\",\"t\":[\"指针数组本质上是一个数组，只不过数据类型从基本类型变成了指针类型，存储的内容都是指针。\"]},\"146\":{\"h\":\"基础知识\"},\"147\":{\"h\":\"9. 结构体\",\"t\":[\"在 Golang 中相同类型的数据可以使用数组或者切片来存储，Golang 中抛弃了类与继承，保留了结构体，那么不同类型的数据可通过结构体来进行存储和组织。\",\"结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。\"]},\"148\":{\"h\":\"声明结构体\",\"t\":[\"结构体定义需要使用 type 和 struct 关键字。结构体中不仅可以使用 Golang 内置的数据类型，也可以使用结构体类型。\",\"type StructName struct { variableName1 dataType1 variableName2 dataType2 variableName3 dataType3 variableName4 dataType4 ...... }\",\"如果有相同类型的字段，可以简化声明\",\"type StructName struct { variableName1,variableName2,variableName3 ... dataType variableName4 dataType1 }\",\"结构体内部的字段名也遵循首字母大小写命名暴露的方式，在声明结构体内部的字段时，应避免其与方法名重复。\"]},\"149\":{\"h\":\"创建结构体实例\",\"t\":[\"与 Java 这种面向对象的语言不同，Golang 中没有构造方法的概念，以下是 Golang 中创建结构体实例的几种方式。\",\"// 定义一个结构体 type Person struct { Name string Age int }\",\"字面量直接实例化\",\"p1 := Person{ Name: \\\"Alice\\\", Age: 30 }\",\"字面量简写形式实例化\",\"p2 := Person{ \\\"Bob\\\", 25 }\",\"如果省略字段名，那么就必须要初始化所有字段，且必须按照声明的顺序初始化。否则就会产生歧义，语法简化的目的是为了在保证语义唯一的情况下尽可能简化。\",\"使用 new 函数实例化\",\"p3 := new(Person) p3.Name = \\\"Charlie\\\" p3.Age = 35\",\"这里只能使用 new 函数，不能使用 make 函数，两者的区别请参考 「new 和 make 详解」\",\"使用取地址符号实例化\",\"p4 := &Person{ Name: \\\"Dave\\\", Age: 40 }\",\"因为 Golang 中没有构造方法，所以可以定义一个工厂函数来创建对象。\",\"func NewPerson() Person { person := new(Person) person.Name = \\\"Golang Notes\\\" person.Age = 18 return person }\"]},\"150\":{\"h\":\"访问结构体成员\",\"t\":[\"访问结构体成员时使用 . 操作符，语法如下：\",\"structName.fieldName\",\"以本节中的 Person 结构体为例，如下所示：\",\"person := Person{ Name: \\\"Golang Notes\\\", Age: 18 } // 访问结构体字段 fmt.Println(person.Name) // 输出 ： Golang Notes fmt.Println(person.Age) // 输出 ： 18 // 修改结构体字段 person.Name = \\\"Coder Mast\\\" fmt.Println(person.Name) // 输出 ： Coder Mast\",\"那么再来看下面的这个例子\",\"person := new(Person) person.Name = \\\"Golang Notes\\\" person.Age = 18 // 或者下面这种形式 person := &Person{ Name: \\\"Golang Notes\\\", Age: 18 } // 访问结构体字段 fmt.Println(person.Name) // 输出 ： Golang Notes fmt.Println(person.Age) // 输出 ： 18 // 修改结构体字段 person.Name = \\\"Coder Mast\\\" fmt.Println(person.Name) // 输出 ： Coder Mast\",\"在这个例子中，person 实际上是结构体指针，但是在访问结构体时没有进行解引用就可直接访问结构体内容，这是 Golang 提供的语法糖，在编译后会自动进行解引用，如 person.Name 会被解析为 (*person).Name，本质还是解引用，只不过是在编译阶段，不必我们手动实现。\"]},\"151\":{\"h\":\"结构体作为参数\",\"t\":[\"和 Golang 内置的数据类型一样，结构体类型也能作为参数传递给函数。\",\"结构体值做参数\",\"type Person struct { Name string Age int } func readPerson(person Person) { fmt.Printf(\\\"Name : %s，Age : %d\\\", person.Name, person.Age) } func changePerson(person Person) { person.Name = \\\"Coder Mast\\\" person.Age = 20 } func main() { var person Person = Person{ Name: \\\"Golang Notes\\\", Age: 18 } readPerson(person) // 输出：Name : Golang Notes，Age : 18 changePerson() readPerson(person) // 输出：Name : Golang Notes，Age : 18 }\",\"结构体指针做参数\",\"type Person struct { Name string Age int } func readPerson(person *Person) { fmt.Printf(\\\"Name : %s，Age : %d\\\", person.Name, person.Age) } func changePerson(person *Person) { person.Name = \\\"Coder Mast\\\" person.Age = 20 } func main() { person := new(Person) person.Name = \\\"Golang Notes\\\" person.Age = 18 readPerson(person) // 输出：Name : Golang Notes，Age : 18 changePerson() readPerson(person) // 输出：Name : Coder Mast，Age : 20 }\",\"结构体做参数时，无论是传递指针结构体还是值结构体，都是传递对应的副本，但是由于指针的副本同样指向的是该结构体实例，故修改形参后能够对原数据造成改变，值结构体不能。\"]},\"152\":{\"h\":\"结构体标签\",\"t\":[\"在 Golang 中结构体标签是一种元数据，用于提供给反射等工具以获取结构体字段的额外信息。常见的包括 JSON序列化、数据库映射、XML映射等。\",\"结构体标签的具体使用如下：\",\"结构体标签使用案例\",\"package main import ( \\\"encoding/json\\\" \\\"fmt\\\" ) // 定义一个结构体，并使用 JSON 标签 type Person struct { Name string `json:\\\"name\\\"` Age int `json:\\\"age\\\"` Email string `json:\\\"email,omitempty\\\"` // omitempty 表示如果该字段为空，则在序列化时忽略它 Ignore string `json:\\\"-\\\"` // - 表示在序列化和反序列化时忽略该字段 } func main() { p := Person{ Name: \\\"Alice\\\", Age: 30, Email: \\\"\\\", Ignore: \\\"This will be ignored\\\", } // 将结构体序列化为 JSON jsonData, err := json.Marshal(p) if err != nil { fmt.Println(\\\"Error marshalling JSON:\\\", err) return } fmt.Println(string(jsonData)) // 输出: {\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30} // 将 JSON 反序列化为结构体 jsonStr := `{\\\"name\\\":\\\"Bob\\\",\\\"age\\\":25}` var p2 Person err = json.Unmarshal([]byte(jsonStr), &p2) if err != nil { fmt.Println(\\\"Error unmarshalling JSON:\\\", err) return } fmt.Printf(\\\"%+v\\\\n\\\", p2) // 输出: {Name:Bob Age:25 Email: Ignore:} }\"]},\"153\":{\"h\":\"结构体标签解释\",\"t\":[\"json:\\\"name\\\"：表示在进行 JSON 序列化和反序列化时，使用 name 作为 JSON 键名。\",\"json:\\\"email,omitempty\\\"：omitempty 表示如果该字段的值为空（零值），则在序列化时忽略它。\",\"json:\\\"-\\\"：表示在进行 JSON 序列化和反序列化时忽略该字段。\"]},\"154\":{\"h\":\"其他常见标签\",\"t\":[\"除了 JSON 标签外，还有其他常见的标签，例如：\",\"bson：用于 MongoDB 的 BSON 序列化。\",\"gorm：用于 GORM ORM 工具的数据库字段映射。\",\"yaml：用于 YAML 序列化和反序列化。\",\"type User struct { ID int `gorm:\\\"primary_key\\\"` // GORM 标签 Name string `bson:\\\"name\\\"` // BSON 标签 Age int `yaml:\\\"age\\\"` // YAML 标签 }\",\"通过使用结构体标签，可以更方便地控制序列化和反序列化的行为，以及与数据库、YAML 等数据格式的映射。\"]},\"155\":{\"h\":\"空结构体\",\"t\":[\"在 Golang 中，空结构体（empty struct）是一个没有任何字段的结构体。空结构体的声明如下：\",\"type EmptyStruct struct{}\",\"空结构体通常用于以下几种场景：\",\"作为信号传递的占位符：空结构体在信号传递、通知、标记等场景中使用，因为它不占用内存空间。\",\"集合数据结构中的占位符：空结构体可以用作 map 的值，以节省内存。\",\"嵌入其他结构体中：空结构体可以用于将方法注入到其他结构体中。\",\"使用空结构体作为信号传递的占位符\",\"在使用 channel 进行信号传递时，空结构体可以作为一种占位符，表示一个事件的发生，而不需要传递实际数据。\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) func main() { done := make(chan struct{}) // 创建一个空结构体的 channel go func() { fmt.Println(\\\"Goroutine started\\\") time.Sleep(2 * time.Second) close(done) // 发送信号 }() <-done // 接收信号 fmt.Println(\\\"Goroutine finished\\\") }\",\"使用空结构体作为 map 的值\",\"空结构体可以用作 map 的值，用于构建集合数据结构。这种方式比使用其他占位符（如 bool）更节省内存。\",\"package main import \\\"fmt\\\" func main() { // 使用空结构体作为 map 的值 mySet := make(map[string]struct{}) // 添加元素 mySet[\\\"apple\\\"] = struct{}{} mySet[\\\"banana\\\"] = struct{}{} // 检查元素是否存在 if _, exists := mySet[\\\"apple\\\"]; exists { fmt.Println(\\\"apple is in the set\\\") } // 输出集合中的元素 for key := range mySet { fmt.Println(key) } }\",\"使用空结构体嵌入其他结构体中\",\"空结构体可以嵌入到其他结构体中，以便为其他结构体提供方法集合。\",\"package main import \\\"fmt\\\" type Logger struct{} func (Logger) Log(message string) { fmt.Println(\\\"Log:\\\", message) } type Server struct { Logger } func main() { server := Server{} server.Log(\\\"Server started\\\") // 调用嵌入的 Logger 方法 }\",\"内存消耗\",\"空结构体不消耗任何内存空间，因为它不包含任何数据字段。这使得它非常适合作为信号或占位符使用。\",\"package main import ( \\\"fmt\\\" \\\"unsafe\\\" ) func main() { var emptyStruct struct{} fmt.Println(unsafe.Sizeof(emptyStruct)) // 输出 0 }\",\"综上所述，空结构体在 Golang 中是一个非常有用的工具，可以在多种场景中提高代码的效率和简洁性。\"]},\"156\":{\"h\":\"结构体的存储\",\"t\":[\"在 Golang 中结构体在内存中的存储是按其字段在结构体中声明的顺序来排列的，每个字段都以适当的内存对齐方式存储，以确保内存访问的效率。具体来说：\",\"内存对齐：为了提高内存访问效率，Go 会对结构体字段进行对齐。对齐意味着字段的起始地址必须是其类型大小的倍数。例如，int32 类型的字段必须对齐到 4 字节的边界，int64 类型的字段必须对齐到 8 字节的边界。\",\"填充和空洞：为了满足对齐要求，Go 编译器可能会在字段之间插入一些填充字节。这些填充字节不存储任何有效数据，只是为了使下一个字段的起始地址满足对齐要求。这会导致结构体在内存中占用的空间比字段本身的大小总和更多。\",\"内存对齐实际上是一种用空间换时间的设计。它通过将内存划分成大小均匀的小块，从而提高处理器访问内存的效率。这种设计有助于减少访问内存时的性能开销，从而提高系统整体的性能。\",\"示例和内存布局\",\"考虑以下结构体：\",\"package main import ( \\\"fmt\\\" \\\"unsafe\\\" ) type MyStruct struct { a bool // 1 byte b int32 // 4 bytes c int64 // 8 bytes } func main() { var s MyStruct fmt.Printf(\\\"Size of MyStruct: %d bytes\\\\n\\\", unsafe.Sizeof(s)) fmt.Printf(\\\"Offset of a: %d\\\\n\\\", unsafe.Offsetof(s.a)) fmt.Printf(\\\"Offset of b: %d\\\\n\\\", unsafe.Offsetof(s.b)) fmt.Printf(\\\"Offset of c: %d\\\\n\\\", unsafe.Offsetof(s.c)) }\",\"运行上述代码，会得到以下输出（具体数值可能会因编译器和平台而异）：\",\"Size of MyStruct: 16 bytes Offset of a: 0 Offset of b: 4 Offset of c: 8\",\"内存布局解释\",\"a 是一个 bool 类型，占用 1 个字节，位于偏移量 0。\",\"为了对齐 b（int32），需要在 a 后面插入 3 个填充字节，因此 b 的偏移量是 4。\",\"c 是 int64 类型，需要对齐到 8 字节的边界，b 的大小正好是 4 字节且在 a 之后填充了 3 个字节，使得 b 的末尾与 c 的起始位置对齐在 8 字节边界，因此 c 的偏移量是 8。\",\"总的来说，MyStruct 的总大小是 16 个字节，包含了字段和填充字节。\",\"内存优化\",\"为了减少结构体的内存占用，可以重新排列字段的顺序，尽量减少填充字节。例如：\",\"type OptimizedStruct struct { c int64 // 8 bytes b int32 // 4 bytes a bool // 1 byte }\",\"重新排列后的结构体可能占用更少的内存，因为字段 c 和 b 已经按对齐要求排列，只有在 b 和 a 之间需要 3 个填充字节。这样优化后的结构体的总大小可能会减小（依旧取决于具体平台和编译器）。\",\"内存布局优化\",\"package main import ( \\\"fmt\\\" \\\"unsafe\\\" ) type OptimizedStruct struct { c int64 // 8 bytes b int32 // 4 bytes a bool // 1 byte } func main() { var s OptimizedStruct fmt.Printf(\\\"Size of OptimizedStruct: %d bytes\\\\n\\\", unsafe.Sizeof(s)) fmt.Printf(\\\"Offset of c: %d\\\\n\\\", unsafe.Offsetof(s.c)) fmt.Printf(\\\"Offset of b: %d\\\\n\\\", unsafe.Offsetof(s.b)) fmt.Printf(\\\"Offset of a: %d\\\\n\\\", unsafe.Offsetof(s.a)) }\",\"运行上述优化后的代码，输出可能是：\",\"Size of OptimizedStruct: 16 bytes Offset of c: 0 Offset of b: 8 Offset of a: 12\",\"这表明通过优化字段顺序，结构体的大小可能会更小，同时保证内存对齐。\",\"总结\",\"了解结构体在内存中的存储方式和对齐规则，有助于编写更高效的代码，尤其是在处理大量结构体或需要高性能内存访问的场景中。合理地排列结构体字段可以减少内存占用和提高访问效率。\"]},\"157\":{\"h\":\"3. 数据类型及变量\"},\"158\":{\"h\":\"数据类型\",\"t\":[\"数据类型用于声明变量，虽然在函数中也有所涉及，如 参数、返回值等，但本质上仍是变量，如参数变量，返回值变量。\",\"数据类型实际上是为了优化内存空间的占用而提出的概念，根据实际的数据需求，分配不同的数据类型，从而达到节约内存的作用。\",\"Golang 中的数据类型分为：基本数据类型 和 复合数据类型。\"]},\"159\":{\"h\":\"基本数据类型\",\"t\":[\"数值类型：整数类型 (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64) 和浮点数类型 (float32, float64)、实数和虚数类型 （complex64、complex128）\",\"布尔类型：bool，Go 语言中不允许将布尔值类型强制转换为整型，也无法直接参与数值运算，也无法与其他类型转换。\",\"字符串类型：string\",\"基本类型的值，直接存在变量中。\"]},\"160\":{\"h\":\"复合数据类型\",\"t\":[\"数组类型：[n]T，表示拥有 n 个类型为 T 的元素的数组。数组是固定大小的连续内存块，其元素是存储在数组内存中的值，而不是地址。访问数组元素时，是直接访问内存中的数据。\",\"var arr [3]int = [3]int{1, 2, 3}\",\"切片类型：[]T，动态数组，可以增长和收缩。切片是一个动态数组，其底层结构包含一个指向数组的指针、长度和容量。切片本身包含了一个指向底层数组的指针，因此切片是通过地址引用数组元素的\",\"var slice []int = []int{1, 2, 3}\",\"映射类型：map[K]V，键值对集合。映射是一个哈希表，它是引用类型。映射中的键值对存储在内存中的某个位置，映射变量本身是一个指向哈希表的指针。\",\"var m map[string]int = map[string]int{\\\"a\\\": 1, \\\"b\\\": 2}\",\"结构体类型：struct，用于组织不同类型的字段。结构体是一个聚合数据类型，其字段是存储在结构体内存中的值，而不是地址。不过，结构体可以包含指针字段。\",\"type Person struct { Age int Name string } var p person = Person{ 18, \\\"CoderMast\\\" }\",\"指针类型：*T，用于声明一个指向类型 T 的指针。可使用 & 取地址符来获取指定变量的地址，使用 * 来取出指针所指向的地址的值。在 32 位系统上，指针为 4B，在 64 位系统上，指针为 8B。\",\"var i int = 10 var p *int = &i var j int = *p\",\"具体的变量信息如下：\",\"内存地址: 变量: 值: 0x0000 i 10 0x0004 p 0x0000(指向 i 的地址) 0x000C j 10\",\"Channel 类型，管道类型，用于在 goroutine 之间进行通信，从而控制 goroutine 的执行。操作符为 <-。var ch chan ChannelType 用于声明一个 channel 类型的变量 ch，且仅接受 ChannelType 类型的数据。\",\"ch := make(chan int) // 定义一个仅接受 int 类型的管道变量 ch ch <- 10 // 写入管道 i := <- ch // 读出管道\",\"管道中的值，读出即失效。 \",\"函数类型，在 Golang 中函数可像普通变量一样被传递、赋值和作为参数或者返回值。\",\"// 1. 函数类型声明 type Operator func(int, int) int // 2. 函数类型赋值 func add(a int,b int) int { return a + b } var operator Operator operator = add\",\"综上所述，在 Go 语言中\",\"数组元素直接存储在数组的内存块中。\",\"切片是引用类型，通过指针引用底层数组。\",\"映射是引用类型，通过指针引用底层哈希表。\",\"结构体字段直接存储在结构体内存块中，但结构体可以包含指针字段。\",\"这意味着在使用切片和映射时，实际操作的是底层数据的地址，而数组和结构体的操作是对其内存块中实际存储的数据进行操作。\"]},\"161\":{\"h\":\"变量\",\"t\":[\"在计算机中，数据都是存在内存中的二进制序列，可直接通过内存地址进行数据访问，但直接操作内存地址，不仅难度高、效率低，而且可能造成极其危险的后果，为了解决这个问题，引入了变量的概念，通过变量来访问数据。实际上变量的定义来源于数学，意思为可变化的量，通过变量名来访问变量的值。\",\"在 Golang 中变量可通过 var 关键字来声明，具体语法如下：\",\"变量的声明\",\"// 1. 声明单个变量 var variableName type // 2. 同时声明多个变量 var variableName1,variableName2 type\",\"该示例定义了一个数据类型为 type ，变量名为 identifier 的变量。\",\"该示例定义了两个数据类型为 type，变量名为 variableName1 和 variableName2 的变量。\",\"变量的初始化\",\"// 1. 初始化单个变量 var name string = \\\"友人\\\" // 2. 一次性初始化多个变量 var name, age = \\\"CoderMast\\\", 18\",\"Golang 提供了类型推导，可使得在不显式声明数据类型时，可直接初始化变量。\",\"var name = \\\"GolangNotes\\\"\",\"另外，Golang 还提供了一种简化变量声明和初始化的语法糖，可直接定义并初始化变量，已经被定义的变量无法使用该语法糖。\",\"name := \\\"CoderMast\\\"\",\"变量声明后如果没有给定初始值，则 Go 会默认给定对应的 零值，这里的零值并非等于 0，而是代指默认值。\"]},\"162\":{\"h\":\"常量\",\"t\":[\"变量是变化的量，那么常量即为不变的量，实际上就是这样。Golang 中常量和变量类似，只需要使用 const 关键字即可。\",\"// 单个变量 const url = \\\"https://www.golangnotes.com/\\\" // 多个变量 const ( name = \\\"CoderMast\\\" age = 18 ) // 同时声明多个常量时，如果省略了值则表示和上面一行的值相同 const ( n1 = 100 n2 n3 )\"]},\"163\":{\"h\":\"iota\",\"t\":[\"iota 是 Golang 中的一个特殊常量，可以被编译器修改。是 golang 中的常量计数器，在第一次使用 const 声明常量时初始化为 0，之后每声明一个常量则将 iota 加 1，也可将 iota 看做是常量的索引。\",\"const ( i = iota j = iota k = iota ) // fmt.Println(iota) 这样是错误的，不能直接把 iota 当做变量或常量使用 fmt.Println(i) fmt.Println(j) fmt.Println(k)\"]},\"164\":{\"h\":\"7. 并发安全和竞态条件\",\"t\":[\"在并发编程中，并发安全（Concurrency Safety）和竞态条件（Race Condition）是两个重要的概念。理解并解决这些问题对于编写高效和可靠的并发程序至关重要。\"]},\"165\":{\"h\":\"并发安全（Concurrency Safety）\",\"t\":[\"并发安全指的是程序在并发环境中运行时，能够正确地管理多个线程或 Goroutine 对共享资源的访问，确保程序的正确性和一致性。\"]},\"166\":{\"h\":\"常见的并发安全技术\",\"t\":[\"互斥锁（Mutex）：用于确保同一时刻只有一个 Goroutine 访问共享资源。\",\"读写锁（RWMutex）：允许多个 Goroutine 同时读取，但写操作是互斥的。\",\"原子操作（Atomic Operations）：提供一种无锁机制，用于对基本数据类型进行原子操作。\",\"通道（Channels）：Go 语言特有的用于在 Goroutine 之间安全地传递数据。\"]},\"167\":{\"h\":\"竞态条件（Race Condition）\",\"t\":[\"竞态条件指的是多个 Goroutine 并发访问和修改共享资源时，程序的运行结果依赖于 Goroutine 的执行顺序。这种情况下，程序可能产生不可预期的错误或不一致的数据。\",\"竞态条件发生在多个 Goroutine 并发写入共享变量而没有适当同步时。例如：\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) var count int func increment(wg *sync.WaitGroup) { defer wg.Done() for i := 0; i < 1000; i++ { count++ } } func main() { var wg sync.WaitGroup for i := 0; i < 10; i++ { wg.Add(1) go increment(&wg) } wg.Wait() fmt.Println(\\\"Final count:\\\", count) }\",\"在这个示例中，count 变量被多个 Goroutine 并发访问和修改，导致竞态条件，最终结果是不确定的。\"]},\"168\":{\"h\":\"解决竞态条件\",\"t\":[\"可以使用互斥锁（Mutex）来确保对共享变量的访问是安全的：\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) var ( count int mu sync.Mutex ) func increment(wg *sync.WaitGroup) { defer wg.Done() for i := 0; i < 1000; i++ { mu.Lock() count++ mu.Unlock() } } func main() { var wg sync.WaitGroup for i := 0; i < 10; i++ { wg.Add(1) go increment(&wg) } wg.Wait() fmt.Println(\\\"Final count:\\\", count) }\",\"通过使用互斥锁（mu.Lock() 和 mu.Unlock()），确保在同一时刻只有一个 Goroutine 能修改 count 变量，从而避免竞态条件。\"]},\"169\":{\"h\":\"使用原子操作\",\"t\":[\"对于简单的计数操作，可以使用原子操作来避免竞态条件：\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" \\\"sync/atomic\\\" ) var count int32 func increment(wg *sync.WaitGroup) { defer wg.Done() for i := 0; i < 1000; i++ { atomic.AddInt32(&count, 1) } } func main() { var wg sync.WaitGroup for i := 0; i < 10; i++ { wg.Add(1) go increment(&wg) } wg.Wait() fmt.Println(\\\"Final count:\\\", count) }\"]},\"170\":{\"h\":\"使用通道\",\"t\":[\"使用 Go 的通道可以实现无锁并发编程，确保数据在 Goroutine 之间安全传递：\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) func increment(wg *sync.WaitGroup, ch chan int) { defer wg.Done() for i := 0; i < 1000; i++ { ch <- 1 } } func main() { var wg sync.WaitGroup ch := make(chan int, 1000) go func() { wg.Wait() close(ch) }() for i := 0; i < 10; i++ { wg.Add(1) go increment(&wg, ch) } count := 0 for n := range ch { count += n } fmt.Println(\\\"Final count:\\\", count) }\",\"在这个示例中，通道 ch 用于在 Goroutine 之间传递数据，确保计数操作是并发安全的。\"]},\"171\":{\"h\":\"总结\",\"t\":[\"并发安全 是确保多个 Goroutine 并发访问共享资源时程序的正确性和一致性。\",\"竞态条件 是指程序的行为依赖于 Goroutine 的执行顺序，导致不可预期的结果。\",\"解决竞态条件 的方法包括使用互斥锁、原子操作和通道。\",\"通过理解和应用这些技术，可以编写出高效、安全的并发程序。\"]},\"172\":{\"h\":\"2. Channel 通道\",\"t\":[\"在Go语言中，通道（Channel）是一种数据类型，用于在多个 goroutine 之间进行通信和同步。通道提供了一种安全、高效的方式，用于传递 数据 和 控制信息 。以下是关于通道的一些重要特性和使用方法：\"]},\"173\":{\"h\":\"特性和概念\",\"t\":[\"并发安全性：\",\"通道本质上是并发安全的，多个goroutine可以安全地向通道发送（send）和接收（receive）数据，无需额外的显式同步操作。\",\"阻塞特性：\",\"发送和接收操作可以是阻塞的，这意味着当没有数据可发送或接收时，goroutine可能会暂时阻塞在发送或接收操作上，直到数据可用或者通道就绪。\",\"通信顺序：\",\"通道保证发送和接收操作的顺序是一致的，即发送的数据会按照发送的顺序被接收。\",\"关闭通道：\",\"可以通过 close() 函数关闭通道，关闭后的通道不再允许发送数据，但仍可以接收已有数据。关闭的通道可以用来通知接收方没有更多的数据。\",\"容量：\",\"通道可以是有限容量的，即在创建时可以指定通道能够缓存的元素数量。有容量的通道在缓存未满时允许发送操作立即完成，而无需等待接收方接收。\"]},\"174\":{\"h\":\"通道的创建\",\"t\":[\"通道可以使用 make 函数创建：\",\"ch := make(chan int)\",\"这个例子创建了一个可以传递 int 类型数据的无缓冲通道。\"]},\"175\":{\"h\":\"发送和接收数据\",\"t\":[\"通道使用 <- 操作符进行数据的发送和接收：\",\"// 发送数据到通道 ch <- 42 // 从通道接收数据 value := <-ch\"]},\"176\":{\"h\":\"无缓冲通道 vs. 带缓冲通道\"},\"177\":{\"h\":\"无缓冲通道\",\"t\":[\"无缓冲通道在没有接收者准备好接收数据时会阻塞发送操作，同样没有发送者时也会阻塞接收操作。这种方式确保了发送和接收的同步。\",\"ch := make(chan int) go func() { ch <- 42 // 发送者阻塞直到有接收者 }() value := <-ch // 接收者阻塞直到有发送者\"]},\"178\":{\"h\":\"带缓冲通道\",\"t\":[\"带缓冲通道可以容纳一定数量的元素，不会立即阻塞发送操作，直到缓冲区满。\",\"ch := make(chan int, 2) ch <- 42 ch <- 43 // 此时缓冲区已满，再次发送会阻塞\"]},\"179\":{\"h\":\"关闭通道\",\"t\":[\"通道可以被显式关闭，以通知接收者没有更多的数据将被发送：\",\"close(ch)\",\"关闭通道后，再发送数据会引发 panic，但接收操作会继续接收已存在的数据，直到缓冲区为空。可以使用以下方式检测通道是否关闭：\",\"value, ok := <-ch if !ok { fmt.Println(\\\"通道已关闭\\\") }\"]},\"180\":{\"h\":\"使用通道的示例\",\"t\":[\"以下是一个简单的使用通道在 Goroutines 之间传递数据的示例：\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) func worker(ch chan int) { for i := 0; i < 5; i++ { ch <- i time.Sleep(time.Second) } close(ch) } func main() { ch := make(chan int) go worker(ch) for val := range ch { fmt.Println(val) } }\",\"在这个例子中，worker 函数向通道 ch 发送数据，然后 main 函数从通道 ch 接收数据并打印。\"]},\"181\":{\"h\":\"Select 语句\",\"t\":[\"select 语句使得一个 Goroutine 能够等待多个通道操作。它类似于 switch 语句，但用于通道通信。\",\"func main() { ch1 := make(chan int) ch2 := make(chan int) go func() { time.Sleep(time.Second) ch1 <- 1 }() go func() { time.Sleep(2 * time.Second) ch2 <- 2 }() for i := 0; i < 2; i++ { select { case msg1 := <-ch1: fmt.Println(\\\"Received\\\", msg1) case msg2 := <-ch2: fmt.Println(\\\"Received\\\", msg2) } } }\",\"这个例子展示了如何使用 select 语句从多个通道接收数据。\"]},\"182\":{\"h\":\"通道的使用场景\",\"t\":[\"数据传递：在 Goroutines 之间传递数据。\",\"同步：确保 Goroutines 按预期顺序执行。\",\"通信：在并发任务之间进行协调。\",\"通道是 Go 语言中强大且灵活的并发编程工具，能够帮助开发者编写高效且易于维护的并发程序。\"]},\"183\":{\"h\":\"5. 并发模式\",\"t\":[\"并发模式是指在并发编程中常用的设计模式和方法，用于有效地管理和协调多个并发任务。以下是一些常见的并发模式，结合 Go 语言的示例代码来介绍它们的应用。\"]},\"184\":{\"h\":\"1. 工作池（Worker Pool）\",\"t\":[\"工作池模式通过一组固定数量的工作 Goroutine 来处理大量的任务，避免因为过多的 Goroutine 而导致资源的过度消耗。\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" \\\"time\\\" ) // Worker 函数，模拟处理任务 func worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) { defer wg.Done() for j := range jobs { fmt.Printf(\\\"Worker %d started job %d\\\\n\\\", id, j) time.Sleep(time.Second) // 模拟工作 fmt.Printf(\\\"Worker %d finished job %d\\\\n\\\", id, j) results <- j * 2 // 返回结果 } } func main() { const numJobs = 5 const numWorkers = 3 jobs := make(chan int, numJobs) results := make(chan int, numJobs) var wg sync.WaitGroup // 启动 worker Goroutine for w := 1; w <= numWorkers; w++ { wg.Add(1) go worker(w, jobs, results, &wg) } // 发送任务到 jobs 通道 for j := 1; j <= numJobs; j++ { jobs <- j } close(jobs) // 等待所有 worker 完成 wg.Wait() close(results) // 打印结果 for result := range results { fmt.Println(\\\"Result:\\\", result) } }\"]},\"185\":{\"h\":\"2. 扇入（Fan-in）\",\"t\":[\"扇入模式将多个输入通道合并到一个通道，从而可以在单个 Goroutine 中处理来自多个来源的数据。\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) // generator 生成一系列数据并发送到通道 func generator(start int, end int, c chan<- int) { for i := start; i <= end; i++ { c <- i time.Sleep(time.Millisecond * 500) // 模拟延迟 } close(c) } // fanIn 将多个通道合并为一个通道 func fanIn(channels ...<-chan int) <-chan int { out := make(chan int) var wg sync.WaitGroup output := func(c <-chan int) { for n := range c { out <- n } wg.Done() } for _, c := range channels { wg.Add(1) go output(c) } go func() { wg.Wait() close(out) }() return out } func main() { c1 := make(chan int) c2 := make(chan int) go generator(1, 5, c1) go generator(6, 10, c2) for n := range fanIn(c1, c2) { fmt.Println(n) } }\"]},\"186\":{\"h\":\"3. 扇出（Fan-out）\",\"t\":[\"扇出模式将一个输入通道的数据分发到多个 Goroutine 进行并行处理。\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" \\\"time\\\" ) // worker 函数处理来自 jobs 通道的任务 func worker(id int, jobs <-chan int, wg *sync.WaitGroup) { defer wg.Done() for j := range jobs { fmt.Printf(\\\"Worker %d processing job %d\\\\n\\\", id, j) time.Sleep(time.Second) // 模拟工作 } } func main() { jobs := make(chan int, 10) var wg sync.WaitGroup // 启动 worker Goroutine for w := 1; w <= 3; w++ { wg.Add(1) go worker(w, jobs, &wg) } // 发送任务到 jobs 通道 for j := 1; j <= 10; j++ { jobs <- j } close(jobs) // 等待所有 worker 完成 wg.Wait() }\"]},\"187\":{\"h\":\"4. 管道（Pipeline）\",\"t\":[\"管道模式将任务分解为一系列的处理步骤，每个步骤由一个 Goroutine 处理，并将结果传递到下一个步骤的 Goroutine。\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) // 生成器生成一系列数字 func generator(nums ...int) <-chan int { out := make(chan int) go func() { for _, n := range nums { out <- n } close(out) }() return out } // 阶段1：数字加倍 func doubler(in <-chan int) <-chan int { out := make(chan int) go func() { for n := range in { out <- n * 2 } close(out) }() return out } // 阶段2：数字平方 func squarer(in <-chan int) <-chan int { out := make(chan int) go func() { for n := range in { out <- n * n } close(out) }() return out } func main() { // 生成数据并通过管道传递 nums := generator(1, 2, 3, 4, 5) doubled := doubler(nums) squared := squarer(doubled) // 打印结果 for n := range squared { fmt.Println(n) } }\"]},\"188\":{\"h\":\"5. 多路复用（Multiplexing）\",\"t\":[\"多路复用模式通过 select 语句从多个通道中选择可用的通道进行处理。\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) // 生成器函数生成数据并发送到通道 func generator(name string, interval time.Duration) <-chan string { c := make(chan string) go func() { for i := 1; ; i++ { c <- fmt.Sprintf(\\\"%s: %d\\\", name, i) time.Sleep(interval) } }() return c } func main() { c1 := generator(\\\"Channel 1\\\", 2*time.Second) c2 := generator(\\\"Channel 2\\\", 3*time.Second) for i := 0; i < 5; i++ { select { case msg1 := <-c1: fmt.Println(msg1) case msg2 := <-c2: fmt.Println(msg2) } } }\"]},\"189\":{\"h\":\"6. 生产者-消费者（Producer-Consumer）\",\"t\":[\"生产者-消费者模式通过缓冲通道协调生产者和消费者的工作，确保数据的安全传递和处理。\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" \\\"time\\\" ) // 生产者函数生成数据并发送到通道 func producer(id int, jobs chan<- int, wg *sync.WaitGroup) { defer wg.Done() for j := 1; j <= 5; j++ { fmt.Printf(\\\"Producer %d producing job %d\\\\n\\\", id, j) jobs <- j time.Sleep(time.Millisecond * 500) } } // 消费者函数从通道接收数据并处理 func consumer(id int, jobs <-chan int, wg *sync.WaitGroup) { defer wg.Done() for j := range jobs { fmt.Printf(\\\"Consumer %d processing job %d\\\\n\\\", id, j) time.Sleep(time.Second) } } func main() { jobs := make(chan int, 10) var wg sync.WaitGroup // 启动生产者 Goroutine for p := 1; p <= 2; p++ { wg.Add(1) go producer(p, jobs, &wg) } // 启动消费者 Goroutine for c := 1; c <= 2; c++ { wg.Add(1) go consumer(c, jobs, &wg) } // 等待所有生产者完成 wg.Wait() close(jobs) }\",\"这些并发模式提供了一种结构化的方法来编写并发程序，通过合理使用这些模式，可以简化并发编程的复杂性，提高代码的可维护性和扩展性。\"]},\"190\":{\"h\":\"6. Context 上下文\",\"t\":[\"在 Go 语言中，context 包提供了一种用于在 API 边界上传递请求范围数据、取消信号和截止日期的方式。context 包主要用于在不同的 Goroutine 之间共享上下文信息，常用于处理请求生命周期管理、超时控制、取消信号传递等场景。下面是一些常见的用法示例以及详细解释。\"]},\"191\":{\"h\":\"基本用法\"},\"192\":{\"h\":\"创建上下文\",\"t\":[\"有几种方式可以创建一个上下文对象：\",\"context.Background()：返回一个空的上下文，通常在程序的主函数、初始化、测试中使用。\",\"context.TODO()：返回一个空的上下文，表示还没有明确的上下文要使用，通常用于暂时替代位置。\",\"ctx := context.Background()\"]},\"193\":{\"h\":\"传递上下文\",\"t\":[\"上下文对象通常作为函数的第一个参数进行传递。\",\"func DoSomething(ctx context.Context) { // 函数体 } func main() { ctx := context.Background() DoSomething(ctx) }\"]},\"194\":{\"h\":\"取消上下文\",\"t\":[\"可以使用 context.WithCancel 创建一个可以取消的上下文。当调用返回的取消函数时，所有派生自该上下文的操作都会收到取消信号。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"time\\\" ) func doWork(ctx context.Context) { for { select { case <-ctx.Done(): fmt.Println(\\\"Work cancelled\\\") return default: fmt.Println(\\\"Working...\\\") time.Sleep(500 * time.Millisecond) } } } func main() { ctx, cancel := context.WithCancel(context.Background()) go doWork(ctx) time.Sleep(2 * time.Second) cancel() // 取消上下文 time.Sleep(1 * time.Second) }\"]},\"195\":{\"h\":\"超时上下文\",\"t\":[\"使用 context.WithTimeout 可以创建一个带有超时的上下文。当超时时间到达时，操作会自动取消。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"time\\\" ) func doWork(ctx context.Context) { for { select { case <-ctx.Done(): fmt.Println(\\\"Work timed out\\\") return default: fmt.Println(\\\"Working...\\\") time.Sleep(500 * time.Millisecond) } } } func main() { ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) defer cancel() go doWork(ctx) time.Sleep(3 * time.Second) }\"]},\"196\":{\"h\":\"截止时间上下文\",\"t\":[\"使用 context.WithDeadline 可以创建一个带有截止时间的上下文，与 WithTimeout 类似，但可以指定具体的时间点。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"time\\\" ) func doWork(ctx context.Context) { for { select { case <-ctx.Done(): fmt.Println(\\\"Work deadline reached\\\") return default: fmt.Println(\\\"Working...\\\") time.Sleep(500 * time.Millisecond) } } } func main() { deadline := time.Now().Add(2 * time.Second) ctx, cancel := context.WithDeadline(context.Background(), deadline) defer cancel() go doWork(ctx) time.Sleep(3 * time.Second) }\"]},\"197\":{\"h\":\"带值上下文\",\"t\":[\"使用 context.WithValue 可以在上下文中存储键值对数据，适用于跨 API 边界传递请求范围的数据。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" ) func doWork(ctx context.Context) { key := \\\"myKey\\\" if value, ok := ctx.Value(key).(string); ok { fmt.Println(\\\"Value from context:\\\", value) } else { fmt.Println(\\\"Key not found in context\\\") } } func main() { ctx := context.WithValue(context.Background(), \\\"myKey\\\", \\\"myValue\\\") doWork(ctx) }\",\"综合示例\",\"下面是一个综合示例，展示了如何使用取消、超时和带值的上下文。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"time\\\" ) func doWork(ctx context.Context) { key := \\\"taskID\\\" if taskID, ok := ctx.Value(key).(string); ok { fmt.Printf(\\\"Started task with ID: %s\\\\n\\\", taskID) } for { select { case <-ctx.Done(): fmt.Println(\\\"Work cancelled or timed out\\\") return default: fmt.Println(\\\"Working...\\\") time.Sleep(500 * time.Millisecond) } } } func main() { // 创建一个带有超时的上下文 ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) defer cancel() // 在上下文中添加值 ctx = context.WithValue(ctx, \\\"taskID\\\", \\\"1234\\\") go doWork(ctx) time.Sleep(3 * time.Second) }\"]},\"198\":{\"h\":\"总结\",\"t\":[\"在 Go 语言中，context 包提供了一种简洁而强大的方式来管理并发程序中的请求范围数据、取消信号和截止日期。通过正确地使用 context，可以更好地控制 Goroutine 的生命周期，避免资源泄漏，提高代码的可读性和维护性。\"]},\"199\":{\"h\":\"1. Goroutine 协程\",\"t\":[\"Go 协程（Goroutine）是 Go 语言提供的一种轻量级线程，由 Go 运行时来管理。是与其他函数同时运行的函数，它们是并发执行代码的基础。\",\"在函数调用前加上 go 关键字，这次调用就会在一个新的 goroutine 中并发执行。当被调用的函数返回时，这个 goroutine 也自动结束。\",\"需要注意的是，如果这个函数有返回值，那么这个返回值会被丢弃。\",\"Go 协程（Goroutine）之间通过通道（channel）进行通信，简单的说就是多个协程之间通信的管道。通道可以防止多个协程访问共享内存时发生资源争抢的问题。\"]},\"200\":{\"h\":\"启动 Goroutine\",\"t\":[\"要启动一个新的 Goroutine，只需要在函数调用前加上 go 关键字。例如：\",\"go myFunction()\",\"这行代码会启动一个新的 Goroutine 来执行 myFunction。\"]},\"201\":{\"h\":\"Goroutine 的特性\",\"t\":[\"轻量级：Goroutine 比传统线程更轻量级。每个 Goroutine 使用的内存非常少，启动速度也更快。\",\"调度：Goroutine 由 Go 运行时管理和调度，而不是操作系统。\",\"栈管理：Goroutine 的栈是动态增长的，初始大小一般较小（如 2KB），但可以根据需要动态扩展，最大可达 1GB。\"]},\"202\":{\"h\":\"同步和通信\",\"t\":[\"在 Go 中，同步和通信通常通过通道（channel）来实现。通道是 Go 语言提供的一种类型安全的通信机制。\"]},\"203\":{\"h\":\"创建通道\",\"t\":[\"可以使用 make 函数创建通道：\",\"ch := make(chan int)\"]},\"204\":{\"h\":\"发送和接收\",\"t\":[\"使用 <- 操作符可以发送和接收数据：\",\"// 发送数据到通道 ch <- 42 // 从通道接收数据 value := <-ch\"]},\"205\":{\"h\":\"带缓冲的通道\",\"t\":[\"创建带缓冲的通道：\",\"ch := make(chan int, 100)\",\"这样通道可以在不阻塞发送 Goroutine 的情况下缓冲一定数量的数据。\"]},\"206\":{\"h\":\"示例代码\",\"t\":[\"以下是一个简单的 Goroutine 和通道的示例：\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) func worker(ch chan int) { for i := 0; i < 5; i++ { ch <- i time.Sleep(time.Second) } close(ch) } func main() { ch := make(chan int) go worker(ch) for val := range ch { fmt.Println(val) } }\",\"在这个例子中，worker 函数向通道 ch 发送数据，然后 main 函数从通道 ch 接收数据并打印。\"]},\"207\":{\"h\":\"Goroutines 和主程序\",\"t\":[\"需要注意的是，如果主程序退出，所有未完成的 Goroutines 也会立即终止。因此，通常需要确保主程序等待所有 Goroutines 完成。例如，可以使用 sync.WaitGroup 来实现这一点：\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) func worker(wg *sync.WaitGroup, id int) { defer wg.Done() fmt.Printf(\\\"Worker %d starting\\\\n\\\", id) // 模拟工作 time.Sleep(time.Second) fmt.Printf(\\\"Worker %d done\\\\n\\\", id) } func main() { var wg sync.WaitGroup for i := 1; i <= 5; i++ { wg.Add(1) go worker(&wg, i) } wg.Wait() fmt.Println(\\\"All workers done\\\") }\",\"这个示例使用 sync.WaitGroup 来等待所有的 Goroutines 完成。wg.Add(1) 用于增加计数，wg.Done() 在 Goroutine 完成时减少计数，wg.Wait() 则阻塞直到所有的 Goroutines 完成。\"]},\"208\":{\"h\":\"协程、线程、进程\",\"t\":[\"协程、线程和进程是并发和并行编程中的三种主要概念。它们有不同的特性和适用场景，以下是它们的主要区别：\"]},\"209\":{\"h\":\"进程 (Process)\",\"t\":[\"定义：\",\"进程是操作系统中资源分配的基本单位。\",\"每个进程都有自己的内存空间、文件描述符和其他资源。\",\"特点：\",\"隔离性：进程之间是相互独立的，一个进程的崩溃不会影响其他进程。\",\"开销大：进程之间切换的开销较大，需要保存和恢复大量上下文信息。\",\"通信复杂：进程间通信（IPC，如管道、消息队列、共享内存等）相对复杂。\",\"适用场景：\",\"适用于需要高度隔离和独立运行的任务。\",\"适用于不同编程语言和不同平台之间的并发处理。\"]},\"210\":{\"h\":\"线程 (Thread)\",\"t\":[\"定义：\",\"线程是进程中的一个执行单元，属于进程的一部分。\",\"同一进程中的线程共享该进程的内存和其他资源。\",\"特点：\",\"轻量级：相比进程，线程的创建和切换开销较小。\",\"共享资源：同一进程内的线程可以直接访问共享的内存和资源，但也因此带来了同步问题。\",\"并发执行：多个线程可以在多核 CPU 上并发执行。\",\"适用场景：\",\"适用于需要并行处理的任务，如多线程服务器、并行计算等。\",\"适用于需要频繁切换和低开销的场景。\"]},\"211\":{\"h\":\"协程 (Coroutine)\",\"t\":[\"定义：\",\"协程是一种用户态的轻量级线程，也称为微线程或纤程。\",\"协程由程序自身管理调度，而不是操作系统。\",\"特点：\",\"更轻量级：协程的创建和切换开销更小，因为不涉及内核态的切换。\",\"协作式调度：协程通过显式的让出操作（如 yield）来切换，控制权由程序员掌握。\",\"共享内存：同一线程内的协程可以共享内存，但需要注意同步问题。\",\"适用场景：\",\"适用于 I/O 密集型任务，如高并发网络服务器。\",\"适用于需要大量并发但对并行性要求不高的场景，如爬虫、异步编程等。\"]},\"212\":{\"h\":\"总结\",\"t\":[\"进程：资源隔离好，开销大，适用于独立运行的任务。\",\"线程：资源共享，开销较小，适用于需要并行处理的任务。\",\"协程：更轻量级，用户态调度，适用于大量并发的 I/O 密集型任务。\",\"各自的选择主要取决于具体的应用场景和性能需求。协程在现代编程中越来越受欢迎，尤其是在需要高并发和高效 I/O 操作的场景中。\"]},\"213\":{\"h\":\"8. 内存模型\",\"t\":[\"在并发编程中，内存模型描述了程序中线程或 Goroutine 如何与内存进行交互。了解内存模型对编写并发安全的程序至关重要。Go 语言的内存模型定义了对共享变量的访问顺序规则，确保在并发环境下的程序行为是可预测的。\"]},\"214\":{\"h\":\"Go 内存模型概述\",\"t\":[\"Go 的内存模型主要通过以下规则来保证内存操作的可见性和一致性：\",\"程序顺序规则：在单个 Goroutine 中，内存操作按程序顺序执行。\",\"传递性规则：如果操作 A 在操作 B 之前，且操作 B 在操作 C 之前，那么操作 A 必须在操作 C 之前。\",\"同步操作规则：通过 sync/atomic 包的原子操作和 sync 包的同步原语（如互斥锁、通道）来定义内存操作之间的同步关系。\"]},\"215\":{\"h\":\"关键概念\"},\"216\":{\"h\":\"Happens-Before\",\"t\":[\"\\\"Happens-Before\\\" 是一个关键概念，用于描述操作之间的内存顺序关系。如果一个操作 \\\"happens-before\\\" 另一个操作，那么第一个操作的结果对于第二个操作是可见的。\"]},\"217\":{\"h\":\"内存屏障\",\"t\":[\"内存屏障是一种 CPU 指令，用于控制内存操作的顺序。Go 编译器和运行时会在适当的位置插入内存屏障，以确保程序符合内存模型的要求。\"]},\"218\":{\"h\":\"同步原语\",\"t\":[\"Go 提供了多种同步原语来确保内存操作的顺序性和可见性：\"]},\"219\":{\"h\":\"互斥锁（Mutex）\",\"t\":[\"互斥锁确保在同一时间只有一个 Goroutine 可以访问共享资源。\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) var ( mu sync.Mutex count int ) func increment() { mu.Lock() count++ mu.Unlock() } func main() { var wg sync.WaitGroup for i := 0; i < 10; i++ { wg.Add(1) go func() { defer wg.Done() increment() }() } wg.Wait() fmt.Println(\\\"Final count:\\\", count) }\"]},\"220\":{\"h\":\"读写锁（RWMutex）\",\"t\":[\"读写锁允许多个 Goroutine 同时读取，但写操作是互斥的。\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) var ( mu sync.RWMutex count int ) func read() int { mu.RLock() defer mu.RUnlock() return count } func write() { mu.Lock() count++ mu.Unlock() } func main() { var wg sync.WaitGroup for i := 0; i < 10; i++ { wg.Add(1) go func() { defer wg.Done() write() }() } for i := 0; i < 10; i++ { wg.Add(1) go func() { defer wg.Done() fmt.Println(read()) }() } wg.Wait() fmt.Println(\\\"Final count:\\\", count) }\"]},\"221\":{\"h\":\"原子操作\",\"t\":[\"原子操作确保对基本数据类型的操作是不可分割的，无需加锁即可实现并发安全。\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" \\\"sync/atomic\\\" ) var count int32 func increment() { atomic.AddInt32(&count, 1) } func main() { var wg sync.WaitGroup for i := 0; i < 10; i++ { wg.Add(1) go func() { defer wg.Done() increment() }() } wg.Wait() fmt.Println(\\\"Final count:\\\", count) }\"]},\"222\":{\"h\":\"通道（Channels）\",\"t\":[\"通道是 Go 特有的用于 Goroutine 间安全通信的机制，隐式地提供同步和内存可见性保证。\",\"package main import ( \\\"fmt\\\" ) func worker(done chan bool) { fmt.Println(\\\"Working...\\\") done <- true } func main() { done := make(chan bool) go worker(done) <-done fmt.Println(\\\"Work done\\\") }\"]},\"223\":{\"h\":\"内存模型规则\",\"t\":[\"程序顺序规则：单个 Goroutine 中的操作按程序顺序执行。\",\"解锁-加锁规则：对一个互斥锁的解锁操作 happens-before 该互斥锁的后续加锁操作。\",\"通道传递规则：向无缓冲通道发送一个值 happens-before 从该通道接收到这个值。\",\"闭包外规则：Go 程序中对 Goroutine 的启动 happens-before 这个 Goroutine 中的操作开始。\",\"示例分析\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) var ( mu sync.Mutex value int ) func writer(wg *sync.WaitGroup) { defer wg.Done() mu.Lock() value = 42 mu.Unlock() } func reader(wg *sync.WaitGroup) { defer wg.Done() mu.Lock() defer mu.Unlock() fmt.Println(value) } func main() { var wg sync.WaitGroup wg.Add(2) go writer(&wg) go reader(&wg) wg.Wait() }\",\"在这个示例中，writer Goroutine 中的 mu.Unlock() happens-before reader Goroutine 中的 mu.Lock()，因此 reader 会看到 value 被设置为 42。\"]},\"224\":{\"h\":\"总结\",\"t\":[\"理解 Go 的内存模型是编写并发安全程序的基础。通过使用同步原语如互斥锁、读写锁、原子操作和通道，可以确保 Goroutine 之间的内存操作是可预测和一致的。明确 \\\"happens-before\\\" 关系和遵循内存模型规则有助于避免竞态条件和其他并发问题。\"]},\"225\":{\"h\":\"并发编程\"},\"226\":{\"h\":\"3. Select 语句\",\"t\":[\"在 Go 语言中，select 语句是一种控制结构，允许一个 Goroutine 同时等待多个通道操作。select 语句会阻塞，直到其中的一个 case 可以继续执行，然后执行该 case 中的语句。select 语句是处理并发任务时非常有用的工具，特别是需要处理多个通道的通信时。\"]},\"227\":{\"h\":\"语句的基本用法\",\"t\":[\"select { case val1 := <-ch1: // 当从 ch1 接收到数据时执行 case ch2 <- val2: // 当向 ch2 发送数据时执行 case <-time.After(time.Second): // 如果一秒内没有任何通道操作成功，则执行此 case default: // 如果没有任何通道操作成功，立即执行此 case }\"]},\"228\":{\"h\":\"示例代码\",\"t\":[\"下面是一些使用 select 语句的示例，以展示其灵活性和强大之处。\"]},\"229\":{\"h\":\"示例 1：从多个通道接收数据\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"time\\\" ) func main() { ch1 := make(chan int) ch2 := make(chan int) go func() { time.Sleep(time.Second) ch1 <- 1 }() go func() { time.Sleep(2 * time.Second) ch2 <- 2 }() for i := 0; i < 2; i++ { select { case msg1 := <-ch1: fmt.Println(\\\"Received\\\", msg1) case msg2 := <-ch2: fmt.Println(\\\"Received\\\", msg2) } } }\",\"这个示例中，两个 Goroutine 分别在不同的时间向 ch1 和 ch2 发送数据，select 语句能够处理哪个通道先接收到数据。\"]},\"230\":{\"h\":\"示例 2：实现超时机制\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"time\\\" ) func main() { ch := make(chan int) go func() { time.Sleep(2 * time.Second) ch <- 42 }() select { case msg := <-ch: fmt.Println(\\\"Received:\\\", msg) case <-time.After(1 * time.Second): fmt.Println(\\\"Timeout\\\") } }\",\"在这个示例中，select 语句中包含了一个超时机制，如果一秒内没有接收到数据，则会执行超时的 case。\"]},\"231\":{\"h\":\"示例 3：非阻塞的通道操作\",\"t\":[\"package main import \\\"fmt\\\" func main() { ch := make(chan int) select { case msg := <-ch: fmt.Println(\\\"Received:\\\", msg) default: fmt.Println(\\\"No data received\\\") } }\",\"在这个示例中，select 语句的 default 分支使得通道操作变得非阻塞，如果没有数据接收，则会立即执行 default 分支。\"]},\"232\":{\"h\":\"语句的注意事项\",\"t\":[\"随机选择：如果有多个 case 都可以执行，select 会随机选择一个执行。\",\"避免阻塞：使用 default 分支可以避免 select 语句阻塞。\",\"通道关闭：如果一个通道关闭且仍有数据在缓冲区中，select 语句可以正常接收到数据，但之后会立即返回零值。\"]},\"233\":{\"h\":\"高级用法\",\"t\":[\"你可以通过将多个通道操作组合在一起，使用 select 语句构建复杂的并发逻辑。例如，可以实现优先级通道、动态增加或减少通道的数量等。\",\"通过灵活运用 select 语句，Go 程序员能够高效地处理并发任务，使得代码更加简洁和易于维护。\"]},\"234\":{\"h\":\"4. 同步原语\",\"t\":[\"控制原语（Control Primitives）是并发编程中用于管理和协调多个线程或协程的基本构建块。它们帮助程序确保资源的正确使用和状态的一致性。以下是一些常见的控制原语：\"]},\"235\":{\"h\":\"1. 锁（Locks）\",\"t\":[\"锁用于确保在任何时刻，只有一个线程可以访问某个资源，从而避免数据竞争和不一致性。常见的锁类型有：\",\"互斥锁（Mutex）：用于保护临界区，确保一次只有一个线程执行。\",\"读写锁（RWMutex）：允许多个线程同时读取资源，但在写入时独占资源。\",\"Go 语言中的互斥锁和读写锁使用示例：\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) var ( mu sync.Mutex // 互斥锁，用于保护共享资源 count int // 共享资源 ) // increment 函数使用互斥锁来确保对共享资源的安全访问 func increment() { mu.Lock() // 加锁，进入临界区 defer mu.Unlock() // 函数结束时解锁 count++ // 修改共享资源 } func main() { var wg sync.WaitGroup // WaitGroup 用于等待所有 Goroutine 完成 // 启动 1000 个 Goroutine，每个 Goroutine 调用 increment 函数 for i := 0; i < 1000; i++ { wg.Add(1) // 增加 WaitGroup 计数 go func() { defer wg.Done() // 函数结束时减少 WaitGroup 计数 increment() }() } wg.Wait() // 等待所有 Goroutine 完成 fmt.Println(\\\"Final count:\\\", count) // 打印最终结果 }\"]},\"236\":{\"h\":\"2. 条件变量（Condition Variables）\",\"t\":[\"条件变量用于阻塞线程，直到某个特定条件为真。它们通常与互斥锁结合使用，用于实现更复杂的同步场景。\",\"Go 语言中使用条件变量：\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) var ( mu sync.Mutex // 互斥锁，用于保护共享资源 cond = sync.NewCond(&mu) // 条件变量 ready = false // 条件变量的条件 ) // waitCondition 函数等待条件变量满足条件 func waitCondition() { mu.Lock() // 加锁，进入临界区 for !ready { cond.Wait() // 等待条件变量满足条件 } fmt.Println(\\\"Condition met, proceeding\\\") mu.Unlock() // 解锁，离开临界区 } // signalCondition 函数设置条件变量，并通知等待的 Goroutine func signalCondition() { mu.Lock() // 加锁，进入临界区 ready = true // 修改条件 cond.Signal() // 通知等待的 Goroutine mu.Unlock() // 解锁，离开临界区 } func main() { var wg sync.WaitGroup // WaitGroup 用于等待所有 Goroutine 完成 wg.Add(1) go func() { defer wg.Done() waitCondition() }() signalCondition() wg.Wait() }\"]},\"237\":{\"h\":\"3. 信号量（Semaphores）\",\"t\":[\"信号量是一个计数器，用于限制对资源的访问次数。它可以控制同时访问某个资源的线程数。\",\"Go 语言中没有直接的信号量实现，可以使用带缓冲的通道来模拟：\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) // worker 函数模拟工作，通过信号量控制并发数 func worker(sem chan struct{}, id int) { sem <- struct{}{} // 获取信号量，进入临界区 fmt.Printf(\\\"Worker %d is working\\\\n\\\", id) time.Sleep(time.Second) // 模拟工作 fmt.Printf(\\\"Worker %d is done\\\\n\\\", id) <-sem // 释放信号量，离开临界区 } func main() { const maxWorkers = 3 // 最大并发数 sem := make(chan struct{}, maxWorkers) // 带缓冲通道作为信号量 // 启动 10 个 Goroutine，每个 Goroutine 调用 worker 函数 for i := 0; i < 10; i++ { go worker(sem, i) } time.Sleep(5 * time.Second) // 等待所有 worker 完成 }\"]},\"238\":{\"h\":\"4. 事件（Events）\",\"t\":[\"事件用于通知线程某个条件已经发生，可以继续执行。通常在等待某个操作完成时使用。\",\"Go 语言中可以使用通道来实现事件机制：\",\"package main import \\\"fmt\\\" // worker 函数完成后通过通道通知 main 函数 func worker(done chan bool) { fmt.Println(\\\"Worker is working\\\") done <- true // 发送完成信号 } func main() { done := make(chan bool) // 创建通道 go worker(done) // 启动 worker Goroutine <-done // 等待 worker 完成 fmt.Println(\\\"Worker is done\\\") }\"]},\"239\":{\"h\":\"5. 栅栏（Barriers）\",\"t\":[\"栅栏用于使一组线程在某个点上同步，只有当所有线程都到达这个点时，它们才会继续执行。\",\"Go 语言中没有直接的栅栏实现，但可以通过 sync.WaitGroup 模拟：\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) // worker 函数模拟工作 func worker(id int, wg *sync.WaitGroup) { defer wg.Done() // 函数结束时减少 WaitGroup 计数 fmt.Printf(\\\"Worker %d is working\\\\n\\\", id) } func main() { var wg sync.WaitGroup // WaitGroup 用于等待所有 Goroutine 完成 numWorkers := 5 // 启动 numWorkers 个 Goroutine，每个 Goroutine 调用 worker 函数 for i := 0; i < numWorkers; i++ { wg.Add(1) // 增加 WaitGroup 计数 go worker(i, &wg) } wg.Wait() // 等待所有 Goroutine 完成 fmt.Println(\\\"All workers are done\\\") }\"]},\"240\":{\"h\":\"6. 原子操作（Atomic Operations）\",\"t\":[\"原子操作是不可分割的操作，用于确保在多线程环境下变量的操作是安全的。\",\"Go 语言中的原子操作：\",\"package main import ( \\\"fmt\\\" \\\"sync/atomic\\\" ) func main() { var count int32 = 0 // 使用 int32 类型的计数器 // 启动 1000 个 Goroutine，每个 Goroutine 执行原子加操作 for i := 0; i < 1000; i++ { go func() { atomic.AddInt32(&count, 1) // 原子加操作 }() } // 在实际使用中，可以使用 sync.WaitGroup 等待所有 Goroutine 完成 // 这里为了简单，直接打印结果 fmt.Println(\\\"Final count:\\\", atomic.LoadInt32(&count)) // 读取计数器值 }\",\"控制原语是并发编程的基础，通过合理使用这些原语，可以有效地管理并发程序的复杂性，确保数据一致性和程序的正确性。\"]},\"241\":{\"h\":\"网络编程\"},\"242\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"243\":{\"h\":\"Community\"}},\"dirtCount\":0,\"index\":[[\"栅栏用于使一组线程在某个点上同步\",{\"1\":{\"239\":1}}],[\"栅栏\",{\"0\":{\"239\":1}}],[\"事件用于通知线程某个条件已经发生\",{\"1\":{\"238\":1}}],[\"事件\",{\"0\":{\"238\":1}}],[\"事实上\",{\"1\":{\"101\":1}}],[\"释放信号量\",{\"1\":{\"237\":1}}],[\"信号量是一个计数器\",{\"1\":{\"237\":1}}],[\"信号量\",{\"0\":{\"237\":1}}],[\"离开临界区\",{\"1\":{\"236\":2,\"237\":1}}],[\"条件变量的条件\",{\"1\":{\"236\":1}}],[\"条件变量用于阻塞线程\",{\"1\":{\"236\":1}}],[\"条件变量\",{\"0\":{\"236\":1},\"1\":{\"236\":1}}],[\"计数\",{\"1\":{\"235\":2,\"239\":2}}],[\"增加\",{\"1\":{\"235\":1,\"239\":1}}],[\"锁用于确保在任何时刻\",{\"1\":{\"235\":1}}],[\"锁\",{\"0\":{\"235\":1}}],[\"随机选择\",{\"1\":{\"232\":1}}],[\"立即执行此\",{\"1\":{\"227\":1}}],[\"允许一个\",{\"1\":{\"226\":1}}],[\"允许多个线程同时读取资源\",{\"1\":{\"235\":1}}],[\"允许多个\",{\"1\":{\"166\":1}}],[\"明确\",{\"1\":{\"224\":1}}],[\"明确性\",{\"1\":{\"102\":1}}],[\"理解\",{\"1\":{\"224\":1}}],[\"理解并解决这些问题对于编写高效和可靠的并发程序至关重要\",{\"1\":{\"164\":1}}],[\"向无缓冲通道发送一个值\",{\"1\":{\"223\":1}}],[\"向切片中添加元素需要使用\",{\"1\":{\"67\":1}}],[\"单个\",{\"1\":{\"223\":1}}],[\"单个变量\",{\"1\":{\"162\":1}}],[\"隐式地提供同步和内存可见性保证\",{\"1\":{\"222\":1}}],[\"间安全通信的机制\",{\"1\":{\"222\":1}}],[\"另一个操作\",{\"1\":{\"216\":1}}],[\"另外\",{\"1\":{\"161\":1}}],[\"尤其是在需要高并发和高效\",{\"1\":{\"212\":1}}],[\"尤其是在处理大量结构体或需要高性能内存访问的场景中\",{\"1\":{\"156\":1}}],[\"资源共享\",{\"1\":{\"212\":1}}],[\"资源隔离好\",{\"1\":{\"212\":1}}],[\"异步编程等\",{\"1\":{\"211\":1}}],[\"密集型任务\",{\"1\":{\"211\":1,\"212\":1}}],[\"控制原语是并发编程的基础\",{\"1\":{\"240\":1}}],[\"控制原语\",{\"1\":{\"234\":1}}],[\"控制权由程序员掌握\",{\"1\":{\"211\":1}}],[\"控制信息\",{\"1\":{\"172\":1}}],[\"协作式调度\",{\"1\":{\"211\":1}}],[\"协程在现代编程中越来越受欢迎\",{\"1\":{\"212\":1}}],[\"协程通过显式的让出操作\",{\"1\":{\"211\":1}}],[\"协程的创建和切换开销更小\",{\"1\":{\"211\":1}}],[\"协程由程序自身管理调度\",{\"1\":{\"211\":1}}],[\"协程是一种用户态的轻量级线程\",{\"1\":{\"211\":1}}],[\"协程\",{\"0\":{\"199\":1,\"208\":1,\"211\":1},\"1\":{\"199\":2,\"208\":1,\"212\":1}}],[\"共享内存\",{\"1\":{\"211\":1}}],[\"共享内存等\",{\"1\":{\"209\":1}}],[\"共享资源\",{\"1\":{\"210\":1,\"235\":1}}],[\"属于进程的一部分\",{\"1\":{\"210\":1}}],[\"相比进程\",{\"1\":{\"210\":1}}],[\"相比于使用空接口\",{\"1\":{\"110\":1}}],[\"相对复杂\",{\"1\":{\"209\":1}}],[\"消息队列\",{\"1\":{\"209\":1}}],[\"消费者函数从通道接收数据并处理\",{\"1\":{\"189\":1}}],[\"消费者模式通过缓冲通道协调生产者和消费者的工作\",{\"1\":{\"189\":1}}],[\"消费者\",{\"0\":{\"189\":1}}],[\"隔离性\",{\"1\":{\"209\":1}}],[\"线程的创建和切换开销较小\",{\"1\":{\"210\":1}}],[\"线程是进程中的一个执行单元\",{\"1\":{\"210\":1}}],[\"线程和进程是并发和并行编程中的三种主要概念\",{\"1\":{\"208\":1}}],[\"线程\",{\"0\":{\"208\":1,\"210\":1},\"1\":{\"212\":1}}],[\"栈管理\",{\"1\":{\"201\":1}}],[\"栈或者其他需要动态管理元素顺序的数据结构\",{\"1\":{\"26\":1}}],[\"调度\",{\"1\":{\"201\":1}}],[\"调用嵌入的\",{\"1\":{\"155\":1}}],[\"调用时需要使用到该接收者\",{\"1\":{\"101\":1}}],[\"调用根据后进先出的顺序执行\",{\"1\":{\"99\":1}}],[\"调用\",{\"1\":{\"90\":1,\"102\":1,\"235\":1,\"237\":1,\"239\":1}}],[\"比传统线程更轻量级\",{\"1\":{\"201\":1}}],[\"比较运算符\",{\"1\":{\"136\":1}}],[\"比较都不相等\",{\"1\":{\"128\":1}}],[\"比较元素大小的规则以及交换元素的位置\",{\"1\":{\"50\":1}}],[\"由\",{\"1\":{\"199\":1,\"201\":1}}],[\"由于\",{\"1\":{\"123\":1,\"125\":1}}],[\"由于其高并发处理能力和小内存占用\",{\"1\":{\"77\":1}}],[\"由于其高性能和简洁性\",{\"1\":{\"77\":1}}],[\"由于扩容的性能消耗\",{\"1\":{\"66\":1}}],[\"综合示例\",{\"1\":{\"197\":1}}],[\"综上所述\",{\"1\":{\"155\":1,\"160\":1}}],[\"截止时间上下文\",{\"0\":{\"196\":1}}],[\"截止时间等\",{\"1\":{\"15\":1}}],[\"测试中使用\",{\"1\":{\"192\":1}}],[\"边界传递请求范围的数据\",{\"1\":{\"197\":1}}],[\"边界上传递请求范围数据\",{\"1\":{\"190\":1}}],[\"边界和\",{\"1\":{\"15\":1}}],[\"生产者函数生成数据并发送到通道\",{\"1\":{\"189\":1}}],[\"生产者\",{\"0\":{\"189\":1},\"1\":{\"189\":1}}],[\"生成器函数生成数据并发送到通道\",{\"1\":{\"188\":1}}],[\"生成器生成一系列数字\",{\"1\":{\"187\":1}}],[\"生成数据并通过管道传递\",{\"1\":{\"187\":1}}],[\"生成一系列数据并发送到通道\",{\"1\":{\"185\":1}}],[\"阶段2\",{\"1\":{\"187\":1}}],[\"阶段1\",{\"1\":{\"187\":1}}],[\"扇出模式将一个输入通道的数据分发到多个\",{\"1\":{\"186\":1}}],[\"扇出\",{\"0\":{\"186\":1}}],[\"扇入模式将多个输入通道合并到一个通道\",{\"1\":{\"185\":1}}],[\"扇入\",{\"0\":{\"185\":1}}],[\"完成时减少计数\",{\"1\":{\"207\":1}}],[\"完成\",{\"1\":{\"184\":1,\"186\":1,\"207\":3,\"235\":2,\"236\":1,\"237\":1,\"238\":1,\"239\":2,\"240\":1}}],[\"启动速度也更快\",{\"1\":{\"201\":1}}],[\"启动消费者\",{\"1\":{\"189\":1}}],[\"启动生产者\",{\"1\":{\"189\":1}}],[\"启动\",{\"0\":{\"200\":1},\"1\":{\"184\":1,\"186\":1,\"235\":1,\"237\":1,\"238\":1,\"239\":1,\"240\":1}}],[\"模拟\",{\"1\":{\"239\":1}}],[\"模拟延迟\",{\"1\":{\"185\":1}}],[\"模拟工作\",{\"1\":{\"184\":1,\"186\":1,\"207\":1,\"237\":1}}],[\"模拟处理任务\",{\"1\":{\"184\":1}}],[\"避免阻塞\",{\"1\":{\"232\":1}}],[\"避免资源泄漏\",{\"1\":{\"198\":1}}],[\"避免因为过多的\",{\"1\":{\"184\":1}}],[\"避免了复杂的访问控制规则\",{\"1\":{\"102\":1}}],[\"按预期顺序执行\",{\"1\":{\"182\":1}}],[\"按位取反\",{\"1\":{\"136\":1}}],[\"按位异或赋值\",{\"1\":{\"134\":1}}],[\"按位异或\",{\"1\":{\"133\":1,\"136\":1}}],[\"按位或赋值\",{\"1\":{\"134\":1}}],[\"按位或\",{\"1\":{\"133\":1,\"136\":1}}],[\"按位与赋值\",{\"1\":{\"134\":1}}],[\"按位与\",{\"1\":{\"133\":1,\"136\":1}}],[\"带缓冲的通道\",{\"0\":{\"205\":1}}],[\"带缓冲通道作为信号量\",{\"1\":{\"237\":1}}],[\"带缓冲通道可以容纳一定数量的元素\",{\"1\":{\"178\":1}}],[\"带缓冲通道\",{\"0\":{\"176\":1,\"178\":1}}],[\"带值上下文\",{\"0\":{\"197\":1}}],[\"带初始化语句的\",{\"1\":{\"120\":1}}],[\"发送完成信号\",{\"1\":{\"238\":1}}],[\"发送任务到\",{\"1\":{\"184\":1,\"186\":1}}],[\"发送数据时执行\",{\"1\":{\"227\":1}}],[\"发送数据\",{\"1\":{\"180\":1,\"206\":1,\"229\":1}}],[\"发送数据到通道\",{\"1\":{\"175\":1,\"204\":1}}],[\"发送者阻塞直到有接收者\",{\"1\":{\"177\":1}}],[\"发送和接收\",{\"0\":{\"204\":1}}],[\"发送和接收数据\",{\"0\":{\"175\":1}}],[\"发送和接收操作可以是阻塞的\",{\"1\":{\"173\":1}}],[\"发送信号\",{\"1\":{\"155\":1}}],[\"阻塞特性\",{\"1\":{\"173\":1}}],[\"安全的并发程序\",{\"1\":{\"171\":1}}],[\"安装\",{\"0\":{\"6\":1}}],[\"能修改\",{\"1\":{\"168\":1}}],[\"能够帮助开发者编写高效且易于维护的并发程序\",{\"1\":{\"182\":1}}],[\"能够等待多个通道操作\",{\"1\":{\"181\":1}}],[\"能够正确地管理多个线程或\",{\"1\":{\"165\":1}}],[\"能够使得代码逻辑更加清晰\",{\"1\":{\"120\":1}}],[\"能够满足各种类型转换的需求\",{\"1\":{\"57\":1}}],[\"最大并发数\",{\"1\":{\"237\":1}}],[\"最大可达\",{\"1\":{\"201\":1}}],[\"最终结果是不确定的\",{\"1\":{\"167\":1}}],[\"最后\",{\"1\":{\"26\":1}}],[\"程序员能够高效地处理并发任务\",{\"1\":{\"233\":1}}],[\"程序中对\",{\"1\":{\"223\":1}}],[\"程序顺序规则\",{\"1\":{\"214\":1,\"223\":1}}],[\"程序可能产生不可预期的错误或不一致的数据\",{\"1\":{\"167\":1}}],[\"程序的运行结果依赖于\",{\"1\":{\"167\":1}}],[\"竞态条件发生在多个\",{\"1\":{\"167\":1}}],[\"竞态条件指的是多个\",{\"1\":{\"167\":1}}],[\"竞态条件\",{\"0\":{\"167\":1},\"1\":{\"171\":1}}],[\"读取计数器值\",{\"1\":{\"240\":1}}],[\"读写锁允许多个\",{\"1\":{\"220\":1}}],[\"读写锁\",{\"0\":{\"220\":1},\"1\":{\"166\":1,\"224\":1,\"235\":1}}],[\"读出即失效\",{\"1\":{\"160\":1}}],[\"读出管道\",{\"1\":{\"160\":1}}],[\"互斥锁确保在同一时间只有一个\",{\"1\":{\"219\":1}}],[\"互斥锁\",{\"0\":{\"219\":1},\"1\":{\"166\":1,\"235\":2,\"236\":1}}],[\"看做是常量的索引\",{\"1\":{\"163\":1}}],[\"已经被定义的变量无法使用该语法糖\",{\"1\":{\"161\":1}}],[\"已经按对齐要求排列\",{\"1\":{\"156\":1}}],[\"友人\",{\"1\":{\"161\":1}}],[\"意思为可变化的量\",{\"1\":{\"161\":1}}],[\"意味着它从右向左结合\",{\"1\":{\"136\":1}}],[\"引入了变量的概念\",{\"1\":{\"161\":1}}],[\"引用传递的数据结构\",{\"1\":{\"73\":1}}],[\"引用传递\",{\"1\":{\"71\":1}}],[\"效率低\",{\"1\":{\"161\":1}}],[\"管道模式将任务分解为一系列的处理步骤\",{\"1\":{\"187\":1}}],[\"管道\",{\"0\":{\"187\":1}}],[\"管道中的值\",{\"1\":{\"160\":1}}],[\"管道类型\",{\"1\":{\"160\":1}}],[\"写入管道\",{\"1\":{\"160\":1}}],[\"变量被多个\",{\"1\":{\"167\":1}}],[\"变量是变化的量\",{\"1\":{\"162\":1}}],[\"变量声明后如果没有给定初始值\",{\"1\":{\"161\":1}}],[\"变量的初始化\",{\"1\":{\"161\":1}}],[\"变量的声明\",{\"1\":{\"161\":1}}],[\"变量名为\",{\"1\":{\"161\":2}}],[\"变量\",{\"0\":{\"161\":1},\"1\":{\"160\":1,\"168\":1}}],[\"变成两倍\",{\"1\":{\"101\":1}}],[\"动态增加或减少通道的数量等\",{\"1\":{\"233\":1}}],[\"动态数组\",{\"1\":{\"160\":1}}],[\"动态长度\",{\"1\":{\"71\":1}}],[\"直接打印结果\",{\"1\":{\"240\":1}}],[\"直接存在变量中\",{\"1\":{\"159\":1}}],[\"直到某个特定条件为真\",{\"1\":{\"236\":1}}],[\"直到其中的一个\",{\"1\":{\"226\":1}}],[\"直到缓冲区为空\",{\"1\":{\"179\":1}}],[\"直到缓冲区满\",{\"1\":{\"178\":1}}],[\"直到数据可用或者通道就绪\",{\"1\":{\"173\":1}}],[\"直到通道关闭\",{\"1\":{\"122\":1}}],[\"直到\",{\"1\":{\"121\":1}}],[\"直到指定的条件不再满足为止\",{\"1\":{\"121\":1}}],[\"布尔类型\",{\"1\":{\"159\":1}}],[\"布尔值\",{\"1\":{\"37\":1}}],[\"整数类型\",{\"1\":{\"159\":1}}],[\"复合数据类型\",{\"0\":{\"160\":1},\"1\":{\"158\":1}}],[\"复合赋值运算符\",{\"1\":{\"136\":1}}],[\"合理地排列结构体字段可以减少内存占用和提高访问效率\",{\"1\":{\"156\":1}}],[\"尽量减少填充字节\",{\"1\":{\"156\":1}}],[\"总的来说\",{\"1\":{\"156\":1}}],[\"总结来说\",{\"1\":{\"89\":1}}],[\"总结\",{\"0\":{\"20\":1,\"34\":1,\"42\":1,\"57\":1,\"171\":1,\"198\":1,\"212\":1,\"224\":1},\"1\":{\"68\":1,\"83\":1,\"123\":1,\"156\":1}}],[\"后面插入\",{\"1\":{\"156\":1}}],[\"后会自动跳出\",{\"1\":{\"120\":1}}],[\"占用\",{\"1\":{\"156\":1}}],[\"填充和空洞\",{\"1\":{\"156\":1}}],[\"具体语法如下\",{\"1\":{\"161\":1}}],[\"具体的变量信息如下\",{\"1\":{\"160\":1}}],[\"具体数值可能会因编译器和平台而异\",{\"1\":{\"156\":1}}],[\"具体来说\",{\"1\":{\"156\":1}}],[\"具体如下\",{\"1\":{\"67\":1,\"92\":1}}],[\"嵌入其他结构体中\",{\"1\":{\"155\":1}}],[\"工作池模式通过一组固定数量的工作\",{\"1\":{\"184\":1}}],[\"工作池\",{\"0\":{\"184\":1}}],[\"工具的数据库字段映射\",{\"1\":{\"154\":1}}],[\"工欲善其事\",{\"1\":{\"81\":1}}],[\"序列化和反序列化\",{\"1\":{\"154\":1}}],[\"序列化和反序列化时忽略该字段\",{\"1\":{\"153\":1}}],[\"序列化和反序列化时\",{\"1\":{\"153\":1}}],[\"序列化\",{\"1\":{\"154\":1}}],[\"反序列化为结构体\",{\"1\":{\"152\":1}}],[\"`yaml\",{\"1\":{\"154\":1}}],[\"`bson\",{\"1\":{\"154\":1}}],[\"`gorm\",{\"1\":{\"154\":1}}],[\"`\",{\"1\":{\"152\":6,\"154\":3}}],[\"`json\",{\"1\":{\"152\":4}}],[\"标记等场景中使用\",{\"1\":{\"155\":1}}],[\"标签外\",{\"1\":{\"154\":1}}],[\"标签\",{\"1\":{\"152\":1,\"154\":3}}],[\"标准库中的许多函数都会返回一个结果值和一个错误值\",{\"1\":{\"86\":1}}],[\"标准库中的错误处理\",{\"0\":{\"86\":1}}],[\"标准库模块及其功能的概述\",{\"1\":{\"12\":1}}],[\"标准库\",{\"0\":{\"12\":1}}],[\"常用于处理请求生命周期管理\",{\"1\":{\"190\":1}}],[\"常见的锁类型有\",{\"1\":{\"235\":1}}],[\"常见的并发安全技术\",{\"0\":{\"166\":1}}],[\"常见的包括\",{\"1\":{\"152\":1}}],[\"常量\",{\"0\":{\"162\":1},\"1\":{\"102\":1}}],[\"详解\",{\"1\":{\"149\":1}}],[\"保留了结构体\",{\"1\":{\"147\":1}}],[\"依旧取决于具体平台和编译器\",{\"1\":{\"156\":1}}],[\"依次类推\",{\"1\":{\"144\":1}}],[\"依然可以通过接口访问其功能\",{\"1\":{\"102\":1}}],[\"依然能够修改成功\",{\"1\":{\"101\":1}}],[\"重新排列后的结构体可能占用更少的内存\",{\"1\":{\"156\":1}}],[\"重置指针回到数组的第一个元素\",{\"1\":{\"142\":1}}],[\"重命名一个文件\",{\"1\":{\"44\":1}}],[\"移动指针到下一个元素\",{\"1\":{\"142\":1}}],[\"交换两个数的值\",{\"1\":{\"141\":1}}],[\"本质还是解引用\",{\"1\":{\"150\":1}}],[\"本质上还是传递的是指针的副本\",{\"1\":{\"141\":1}}],[\"本身不是并发安全的\",{\"1\":{\"127\":1}}],[\"本身的变量中\",{\"1\":{\"67\":1}}],[\"表示还没有明确的上下文要使用\",{\"1\":{\"192\":1}}],[\"表示拥有\",{\"1\":{\"160\":1}}],[\"表示一个事件的发生\",{\"1\":{\"155\":1}}],[\"表示如果该字段的值为空\",{\"1\":{\"153\":1}}],[\"表示如果该字段为空\",{\"1\":{\"152\":1}}],[\"表示在进行\",{\"1\":{\"153\":2}}],[\"表示在序列化和反序列化时忽略该字段\",{\"1\":{\"152\":1}}],[\"表示取该变量的地址\",{\"1\":{\"139\":1}}],[\"表示这是一个指针类型的变量\",{\"1\":{\"138\":1}}],[\"表示任意类型\",{\"1\":{\"105\":1}}],[\"放在变量名前\",{\"1\":{\"138\":1,\"139\":1}}],[\"符号\",{\"1\":{\"138\":1,\"139\":1}}],[\"考虑以下结构体\",{\"1\":{\"156\":1}}],[\"考虑到这一点\",{\"1\":{\"137\":1}}],[\"考虑使用其他数据结构或转换策略来处理这些值\",{\"1\":{\"128\":1}}],[\"虽然在函数中也有所涉及\",{\"1\":{\"158\":1}}],[\"虽然在\",{\"1\":{\"142\":1}}],[\"虽然\",{\"1\":{\"137\":1}}],[\"虽然结构体字段可以是未导出的\",{\"1\":{\"102\":1}}],[\"赋值和作为参数或者返回值\",{\"1\":{\"160\":1}}],[\"赋值运算符\",{\"0\":{\"134\":1},\"1\":{\"136\":1}}],[\"赋给\",{\"1\":{\"136\":1}}],[\"先将\",{\"1\":{\"136\":1}}],[\"先计算\",{\"1\":{\"136\":1}}],[\"乘性运算符\",{\"1\":{\"136\":1}}],[\"乘法运算符\",{\"1\":{\"136\":1}}],[\"乘法赋值\",{\"1\":{\"134\":1}}],[\"乘法\",{\"1\":{\"130\":1,\"136\":1}}],[\"负号\",{\"1\":{\"136\":1}}],[\"负数\",{\"1\":{\"28\":1}}],[\"二进制\",{\"1\":{\"133\":7}}],[\"右移赋值\",{\"1\":{\"134\":1}}],[\"右移\",{\"1\":{\"133\":1,\"136\":1}}],[\"左移赋值\",{\"1\":{\"134\":1}}],[\"左移\",{\"1\":{\"133\":1,\"136\":1}}],[\"^=\",{\"1\":{\"134\":1,\"136\":1}}],[\"^\",{\"1\":{\"133\":2,\"136\":2}}],[\"位系统上\",{\"1\":{\"160\":2}}],[\"位于偏移量\",{\"1\":{\"156\":1}}],[\"位移运算符\",{\"1\":{\"136\":1}}],[\"位运算符\",{\"0\":{\"133\":1},\"1\":{\"136\":1}}],[\"位置参数\",{\"1\":{\"32\":1}}],[\"逻辑或\",{\"1\":{\"136\":1}}],[\"逻辑与\",{\"1\":{\"136\":1}}],[\"逻辑非\",{\"1\":{\"136\":1}}],[\"逻辑运算符\",{\"0\":{\"132\":1},\"1\":{\"136\":2}}],[\"逻辑控制语句\",{\"0\":{\"118\":1}}],[\"小于等于\",{\"1\":{\"131\":1,\"136\":1}}],[\"小于\",{\"1\":{\"131\":1,\"136\":1}}],[\"小写字母开头\",{\"1\":{\"102\":1}}],[\"关系和遵循内存模型规则有助于避免竞态条件和其他并发问题\",{\"1\":{\"224\":1}}],[\"关系运算符\",{\"0\":{\"131\":1}}],[\"关键概念\",{\"0\":{\"215\":1}}],[\"关键字即可\",{\"1\":{\"162\":1}}],[\"关键字来声明\",{\"1\":{\"161\":1}}],[\"关键字后没有表达式\",{\"1\":{\"120\":1}}],[\"关键字和\",{\"1\":{\"112\":1}}],[\"关键字\",{\"0\":{\"122\":1},\"1\":{\"92\":1,\"112\":1,\"148\":1,\"199\":1,\"200\":1}}],[\"关闭的通道可以用来通知接收方没有更多的数据\",{\"1\":{\"173\":1}}],[\"关闭后的通道不再允许发送数据\",{\"1\":{\"173\":1}}],[\"关闭通道后\",{\"1\":{\"179\":1}}],[\"关闭通道\",{\"0\":{\"179\":1},\"1\":{\"173\":1}}],[\"求余赋值\",{\"1\":{\"134\":1}}],[\"求余\",{\"1\":{\"130\":1}}],[\"求两数之和\",{\"1\":{\"104\":1}}],[\"取消上下文\",{\"0\":{\"194\":1},\"1\":{\"194\":1}}],[\"取消信号和截止日期\",{\"1\":{\"198\":1}}],[\"取消信号和截止日期的方式\",{\"1\":{\"190\":1}}],[\"取消信号传递等场景\",{\"1\":{\"190\":1}}],[\"取地址符来获取指定变量的地址\",{\"1\":{\"160\":1}}],[\"取出指针并获取值\",{\"1\":{\"135\":1}}],[\"取址运算符\",{\"1\":{\"135\":1}}],[\"取模\",{\"1\":{\"130\":1,\"136\":1}}],[\"取决于所迭代的数据结构\",{\"1\":{\"122\":1}}],[\"减法赋值\",{\"1\":{\"134\":1}}],[\"减法\",{\"1\":{\"130\":1,\"136\":1}}],[\"减少了重复代码\",{\"1\":{\"110\":1}}],[\"减少了运行时错误\",{\"1\":{\"110\":1}}],[\"减少了学习和使用的难度\",{\"1\":{\"76\":1}}],[\"算术运算符\",{\"0\":{\"130\":1}}],[\"运行时管理和调度\",{\"1\":{\"201\":1}}],[\"运行时来管理\",{\"1\":{\"199\":1}}],[\"运行上述优化后的代码\",{\"1\":{\"156\":1}}],[\"运行上述代码\",{\"1\":{\"156\":1}}],[\"运行程序时可以这样使用\",{\"1\":{\"30\":1}}],[\"运算符有不同的优先级\",{\"1\":{\"136\":1}}],[\"运算符的优先级决定了表达式中各部分的计算顺序\",{\"1\":{\"136\":1}}],[\"运算符的优先级\",{\"0\":{\"136\":1}}],[\"运算符\",{\"0\":{\"129\":1}}],[\"检查元素是否存在\",{\"1\":{\"155\":1}}],[\"检查\",{\"1\":{\"128\":1}}],[\"尝试使用另外一个\",{\"1\":{\"128\":1}}],[\"尝试使用\",{\"1\":{\"128\":1}}],[\"展示为什么不能使用\",{\"1\":{\"128\":1}}],[\"展示了如何使用取消\",{\"1\":{\"197\":1}}],[\"展示了如何设置一个\",{\"1\":{\"9\":1}}],[\"展示了如何连接到\",{\"1\":{\"8\":1}}],[\"加锁\",{\"1\":{\"235\":1,\"236\":2}}],[\"加锁规则\",{\"1\":{\"223\":1}}],[\"加\",{\"1\":{\"163\":1}}],[\"加性运算符\",{\"1\":{\"136\":1}}],[\"加法赋值\",{\"1\":{\"134\":1}}],[\"加法\",{\"1\":{\"130\":1,\"136\":1}}],[\"加载值\",{\"1\":{\"127\":1}}],[\"加密算法\",{\"1\":{\"18\":1}}],[\"存储的内容都是指针\",{\"1\":{\"145\":1}}],[\"存储的是一个指向底层数组的指针\",{\"1\":{\"68\":1}}],[\"存储到内存中的值也必然会占用内存\",{\"1\":{\"144\":1}}],[\"存储值\",{\"1\":{\"127\":1}}],[\"零值\",{\"1\":{\"126\":1,\"153\":1,\"161\":1}}],[\"键值对集合\",{\"1\":{\"160\":1}}],[\"键名\",{\"1\":{\"153\":1}}],[\"键的类型包括\",{\"1\":{\"128\":1}}],[\"键的类型\",{\"1\":{\"126\":1}}],[\"键和值\",{\"1\":{\"122\":1}}],[\"声明常量时初始化为\",{\"1\":{\"163\":1}}],[\"声明单个变量\",{\"1\":{\"161\":1}}],[\"声明结构体\",{\"0\":{\"148\":1}}],[\"声明指针\",{\"0\":{\"138\":1}}],[\"声明和初始化\",{\"0\":{\"125\":1}}],[\"声明方式\",{\"1\":{\"70\":1,\"71\":1}}],[\"集合数据结构中的占位符\",{\"1\":{\"155\":1}}],[\"集合的长度\",{\"1\":{\"126\":1}}],[\"集合\",{\"0\":{\"124\":1}}],[\"了解内存模型对编写并发安全的程序至关重要\",{\"1\":{\"213\":1}}],[\"了解结构体在内存中的存储方式和对齐规则\",{\"1\":{\"156\":1}}],[\"了解并熟练使用\",{\"1\":{\"123\":1}}],[\"了解到这些之后\",{\"1\":{\"101\":1}}],[\"准备好\",{\"1\":{\"123\":1}}],[\"执行原子加操作\",{\"1\":{\"240\":1}}],[\"执行\",{\"1\":{\"123\":1}}],[\"执行后的结果为\",{\"1\":{\"101\":1}}],[\"注意\",{\"1\":{\"122\":1}}],[\"注意事项\",{\"1\":{\"121\":1}}],[\"索引和unicode码点\",{\"1\":{\"122\":1}}],[\"索引和元素值\",{\"1\":{\"122\":1}}],[\"迭代通道\",{\"1\":{\"122\":1}}],[\"迭代映射\",{\"1\":{\"122\":1}}],[\"迭代字符串\",{\"1\":{\"122\":1}}],[\"迭代数组和切片\",{\"1\":{\"122\":1}}],[\"应避免其与方法名重复\",{\"1\":{\"148\":1}}],[\"应该放\",{\"1\":{\"122\":1}}],[\"应用和\",{\"1\":{\"77\":1}}],[\"应用\",{\"0\":{\"77\":1}}],[\"映射是引用类型\",{\"1\":{\"160\":1}}],[\"映射是一个哈希表\",{\"1\":{\"160\":1}}],[\"映射变量本身是一个指向哈希表的指针\",{\"1\":{\"160\":1}}],[\"映射中的键值对存储在内存中的某个位置\",{\"1\":{\"160\":1}}],[\"映射类型\",{\"1\":{\"160\":1}}],[\"映射的迭代顺序是随机的\",{\"1\":{\"122\":1}}],[\"映射\",{\"1\":{\"122\":1}}],[\"映射等数据结构\",{\"1\":{\"121\":1}}],[\"括起来\",{\"1\":{\"121\":1}}],[\"之前\",{\"1\":{\"214\":3}}],[\"之前首先需要安装配置好\",{\"1\":{\"79\":1}}],[\"之后每声明一个常量则将\",{\"1\":{\"163\":1}}],[\"之后填充了\",{\"1\":{\"156\":1}}],[\"之间的内存操作是可预测和一致的\",{\"1\":{\"224\":1}}],[\"之间通过通道\",{\"1\":{\"199\":1}}],[\"之间共享上下文信息\",{\"1\":{\"190\":1}}],[\"之间传递数据的示例\",{\"1\":{\"180\":1}}],[\"之间传递数据\",{\"1\":{\"170\":1,\"182\":1}}],[\"之间安全传递\",{\"1\":{\"170\":1}}],[\"之间安全地传递数据\",{\"1\":{\"166\":1}}],[\"之间进行通信和同步\",{\"1\":{\"172\":1}}],[\"之间进行通信\",{\"1\":{\"160\":1}}],[\"之间需要\",{\"1\":{\"156\":1}}],[\"之外的条件表达式\",{\"1\":{\"121\":1}}],[\"到\",{\"1\":{\"121\":2}}],[\"每个进程都有自己的内存空间\",{\"1\":{\"209\":1}}],[\"每个步骤由一个\",{\"1\":{\"187\":1}}],[\"每个字段都以适当的内存对齐方式存储\",{\"1\":{\"156\":1}}],[\"每个\",{\"1\":{\"123\":1,\"201\":1,\"235\":1,\"237\":1,\"239\":1,\"240\":1}}],[\"每个特性提供了强大的工具来处理函数的定义\",{\"1\":{\"102\":1}}],[\"每次循环迭代后执行的操作\",{\"1\":{\"121\":1}}],[\"方便维护\",{\"1\":{\"120\":1}}],[\"方法和函数的却别\",{\"1\":{\"101\":1}}],[\"方法和函数的区别\",{\"1\":{\"101\":1}}],[\"方法拥有接收者\",{\"1\":{\"101\":1}}],[\"方法是定义在类型上的函数\",{\"1\":{\"101\":1}}],[\"方法的接收者分为\",{\"1\":{\"101\":1}}],[\"方法的类型都可以被视为一个错误\",{\"1\":{\"85\":1}}],[\"方法的三个参数依次为\",{\"1\":{\"66\":1}}],[\"方法进行初始化时\",{\"1\":{\"66\":1}}],[\"方法来创建切片\",{\"1\":{\"66\":1}}],[\"方法\",{\"0\":{\"101\":1},\"1\":{\"50\":1,\"67\":1,\"101\":1,\"112\":1,\"113\":1,\"155\":1}}],[\"方法可以自定义类型的字符串表示方式\",{\"1\":{\"39\":1}}],[\"被设置为\",{\"1\":{\"223\":1}}],[\"被分配为\",{\"1\":{\"120\":1}}],[\"被广泛应用于云计算平台和工具的开发\",{\"1\":{\"77\":1}}],[\"内存屏障是一种\",{\"1\":{\"217\":1}}],[\"内存屏障\",{\"0\":{\"217\":1}}],[\"内存操作按程序顺序执行\",{\"1\":{\"214\":1}}],[\"内存模型规则\",{\"0\":{\"223\":1}}],[\"内存模型概述\",{\"0\":{\"214\":1}}],[\"内存模型描述了程序中线程或\",{\"1\":{\"213\":1}}],[\"内存模型\",{\"0\":{\"213\":1}}],[\"内存地址\",{\"1\":{\"160\":1}}],[\"内存布局优化\",{\"1\":{\"156\":1}}],[\"内存布局解释\",{\"1\":{\"156\":1}}],[\"内存优化\",{\"1\":{\"156\":1}}],[\"内存对齐实际上是一种用空间换时间的设计\",{\"1\":{\"156\":1}}],[\"内存对齐\",{\"1\":{\"156\":1}}],[\"内存消耗\",{\"1\":{\"155\":1}}],[\"内部\",{\"1\":{\"120\":1}}],[\"内置的数据类型一样\",{\"1\":{\"151\":1}}],[\"内置的数据类型\",{\"1\":{\"148\":1}}],[\"内置的数据结构\",{\"1\":{\"125\":1}}],[\"内置了许多功能\",{\"1\":{\"83\":1}}],[\"内置函数将元素附加到切片的末尾\",{\"1\":{\"67\":1}}],[\"用户态调度\",{\"1\":{\"212\":1}}],[\"用来存储其他变量的内存地址\",{\"1\":{\"137\":1}}],[\"用逗号分隔\",{\"1\":{\"120\":1}}],[\"用于确保在多线程环境下变量的操作是安全的\",{\"1\":{\"240\":1}}],[\"用于确保同一时刻只有一个\",{\"1\":{\"166\":1}}],[\"用于限制对资源的访问次数\",{\"1\":{\"237\":1}}],[\"用于实现更复杂的同步场景\",{\"1\":{\"236\":1}}],[\"用于等待所有\",{\"1\":{\"235\":1,\"236\":1,\"239\":1}}],[\"用于保护共享资源\",{\"1\":{\"235\":1,\"236\":1}}],[\"用于保护临界区\",{\"1\":{\"235\":1}}],[\"用于控制内存操作的顺序\",{\"1\":{\"217\":1}}],[\"用于描述操作之间的内存顺序关系\",{\"1\":{\"216\":1}}],[\"用于描述集合的长度\",{\"1\":{\"50\":1}}],[\"用于增加计数\",{\"1\":{\"207\":1}}],[\"用于有效地管理和协调多个并发任务\",{\"1\":{\"183\":1}}],[\"用于传递\",{\"1\":{\"172\":1}}],[\"用于对基本数据类型进行原子操作\",{\"1\":{\"166\":1}}],[\"用于声明一个\",{\"1\":{\"160\":1}}],[\"用于声明一个指向类型\",{\"1\":{\"160\":1}}],[\"用于在多个\",{\"1\":{\"172\":1}}],[\"用于在\",{\"1\":{\"160\":1,\"170\":1}}],[\"用于组织不同类型的字段\",{\"1\":{\"160\":1}}],[\"用于构建集合数据结构\",{\"1\":{\"155\":1}}],[\"用于\",{\"1\":{\"154\":3}}],[\"用于提供给反射等工具以获取结构体字段的额外信息\",{\"1\":{\"152\":1}}],[\"用于存储键值对\",{\"1\":{\"124\":1}}],[\"用于存储相同类型\",{\"1\":{\"64\":1}}],[\"用于迭代数组\",{\"1\":{\"121\":1}}],[\"用于重复执行一段代码块\",{\"1\":{\"121\":1}}],[\"用于格式化输出到文件或其他\",{\"1\":{\"41\":1}}],[\"用于生成日志消息\",{\"1\":{\"19\":1}}],[\"用于处理跨\",{\"1\":{\"15\":1}}],[\"用于处理命令行输入参数\",{\"1\":{\"13\":1,\"19\":1}}],[\"分别在不同的时间向\",{\"1\":{\"229\":1}}],[\"分别用于整数\",{\"1\":{\"37\":1}}],[\"分别用于定义一个字符串类型和整数类型的命令行参数\",{\"1\":{\"30\":1}}],[\"分配不同的数据类型\",{\"1\":{\"158\":1}}],[\"分支可以避免\",{\"1\":{\"232\":1}}],[\"分支使得通道操作变得非阻塞\",{\"1\":{\"231\":1}}],[\"分支的代码\",{\"1\":{\"123\":1}}],[\"分支\",{\"1\":{\"123\":1,\"231\":1}}],[\"分支在所有\",{\"1\":{\"123\":1}}],[\"分支中指定多个匹配条件\",{\"1\":{\"120\":1}}],[\"块\",{\"1\":{\"120\":1}}],[\"特有的用于\",{\"1\":{\"222\":1}}],[\"特点\",{\"1\":{\"209\":1,\"210\":1,\"211\":1}}],[\"特点与注意事项\",{\"1\":{\"120\":1,\"123\":1}}],[\"特性和概念\",{\"0\":{\"173\":1}}],[\"特殊情况nan\",{\"0\":{\"128\":1}}],[\"特别是需要处理多个通道的通信时\",{\"1\":{\"226\":1}}],[\"特别是用于从多个通信通道中选择和执行不同的\",{\"1\":{\"123\":1}}],[\"特别是在使用和传递时的行为有所不同\",{\"1\":{\"69\":1}}],[\"特别是在处理用户输入或从外部数据源读取数据时\",{\"1\":{\"53\":1}}],[\"特别适合需要持久化状态或者捕获动态变化的场景\",{\"1\":{\"96\":1}}],[\"替代多个\",{\"1\":{\"120\":1}}],[\"时\",{\"1\":{\"128\":1}}],[\"时返回的键值对的顺序是不确定的\",{\"1\":{\"124\":1}}],[\"时退出循环\",{\"1\":{\"121\":1}}],[\"时执行的代码块\",{\"1\":{\"120\":2}}],[\"时执行的语句\",{\"1\":{\"119\":6}}],[\"时间处理\",{\"1\":{\"18\":1}}],[\"空结构体在\",{\"1\":{\"155\":1}}],[\"空结构体在信号传递\",{\"1\":{\"155\":1}}],[\"空结构体不消耗任何内存空间\",{\"1\":{\"155\":1}}],[\"空结构体可以嵌入到其他结构体中\",{\"1\":{\"155\":1}}],[\"空结构体可以作为一种占位符\",{\"1\":{\"155\":1}}],[\"空结构体可以用于将方法注入到其他结构体中\",{\"1\":{\"155\":1}}],[\"空结构体可以用作\",{\"1\":{\"155\":2}}],[\"空结构体通常用于以下几种场景\",{\"1\":{\"155\":1}}],[\"空结构体的声明如下\",{\"1\":{\"155\":1}}],[\"空结构体\",{\"0\":{\"155\":1},\"1\":{\"155\":1}}],[\"空\",{\"1\":{\"120\":1}}],[\"空接口对于需要处理未知类型的数据非常有用\",{\"1\":{\"115\":1}}],[\"空接口\",{\"0\":{\"115\":1},\"1\":{\"115\":1}}],[\"空指针时执行\",{\"1\":{\"143\":1}}],[\"空指针判断\",{\"1\":{\"143\":1}}],[\"空指针\",{\"0\":{\"143\":1},\"1\":{\"66\":1}}],[\"上并发执行\",{\"1\":{\"210\":1}}],[\"上下文对象通常作为函数的第一个参数进行传递\",{\"1\":{\"193\":1}}],[\"上下文\",{\"0\":{\"190\":1}}],[\"上下文管理\",{\"1\":{\"15\":1}}],[\"上述的所有逻辑控制语句均可嵌套使用\",{\"1\":{\"123\":1}}],[\"上述代码将输出\",{\"1\":{\"121\":1}}],[\"上述代码将输出从\",{\"1\":{\"121\":1}}],[\"上述代码会输出\",{\"1\":{\"121\":1}}],[\"上面的例子定义了一个shape接口\",{\"1\":{\"112\":1}}],[\"进入临界区\",{\"1\":{\"235\":1,\"236\":2,\"237\":1}}],[\"进行通信\",{\"1\":{\"199\":1}}],[\"进行并行处理\",{\"1\":{\"186\":1}}],[\"进行信号传递时\",{\"1\":{\"155\":1}}],[\"进行操作\",{\"1\":{\"121\":1}}],[\"进一步增强了代码的可重用性和可维护性\",{\"1\":{\"110\":1}}],[\"进程间通信\",{\"1\":{\"209\":1}}],[\"进程之间切换的开销较大\",{\"1\":{\"209\":1}}],[\"进程之间是相互独立的\",{\"1\":{\"209\":1}}],[\"进程是操作系统中资源分配的基本单位\",{\"1\":{\"209\":1}}],[\"进程\",{\"0\":{\"208\":1,\"209\":1},\"1\":{\"212\":1}}],[\"进程操作\",{\"0\":{\"46\":1}}],[\"进程管理等\",{\"1\":{\"43\":1}}],[\"代码复用\",{\"1\":{\"110\":1}}],[\"代替数组的长度\",{\"1\":{\"61\":1}}],[\"|=\",{\"1\":{\"134\":1,\"136\":1}}],[\"||\",{\"1\":{\"132\":2,\"136\":1}}],[\"|\",{\"1\":{\"109\":4,\"133\":2,\"136\":1}}],[\"定义\",{\"1\":{\"209\":1,\"210\":1,\"211\":1}}],[\"定义一个仅接受\",{\"1\":{\"160\":1}}],[\"定义一个结构体\",{\"1\":{\"149\":1,\"152\":1}}],[\"定义一个rectangle结构体实现shape接口\",{\"1\":{\"113\":1}}],[\"定义一个接口number\",{\"1\":{\"109\":1}}],[\"定义命令行参数时\",{\"1\":{\"31\":1}}],[\"定义命令行参数\",{\"1\":{\"30\":1}}],[\"顺序可能不同\",{\"1\":{\"108\":1}}],[\"约束\",{\"1\":{\"107\":1}}],[\"很容易造成系统崩溃\",{\"1\":{\"142\":1}}],[\"很好\",{\"1\":{\"104\":1}}],[\"很简单\",{\"1\":{\"104\":1}}],[\"根据实际的数据需求\",{\"1\":{\"158\":1}}],[\"根据传进来的变量动态的控制数据类型\",{\"1\":{\"104\":1}}],[\"根据指定格式输出参数\",{\"1\":{\"36\":1}}],[\"确保一次只有一个线程执行\",{\"1\":{\"235\":1}}],[\"确保在并发环境下的程序行为是可预测的\",{\"1\":{\"213\":1}}],[\"确保在同一时刻只有一个\",{\"1\":{\"168\":1}}],[\"确保数据一致性和程序的正确性\",{\"1\":{\"240\":1}}],[\"确保数据的安全传递和处理\",{\"1\":{\"189\":1}}],[\"确保数据在\",{\"1\":{\"170\":1}}],[\"确保\",{\"1\":{\"182\":1}}],[\"确保计数操作是并发安全的\",{\"1\":{\"170\":1}}],[\"确保程序的正确性和一致性\",{\"1\":{\"165\":1}}],[\"确保程序在面对异常情况时能够安全和可靠地执行\",{\"1\":{\"89\":1}}],[\"确实\",{\"1\":{\"104\":1}}],[\"没错\",{\"1\":{\"104\":1}}],[\"没有指定数组的数据\",{\"1\":{\"61\":1}}],[\"再发送数据会引发\",{\"1\":{\"179\":1}}],[\"再写一个函数确实可以实现这个需求\",{\"1\":{\"104\":1}}],[\"再写一个函数不就行了吗\",{\"1\":{\"104\":1}}],[\"再次发送会阻塞\",{\"1\":{\"178\":1}}],[\"再次打印轮转后的环形链表的所有值\",{\"1\":{\"28\":1}}],[\"再次遍历链表并打印元素\",{\"1\":{\"25\":1}}],[\"该互斥锁的后续加锁操作\",{\"1\":{\"223\":1}}],[\"该示例定义了两个数据类型为\",{\"1\":{\"161\":1}}],[\"该示例定义了一个数据类型为\",{\"1\":{\"161\":1}}],[\"该长度为键值对的个数\",{\"1\":{\"126\":1}}],[\"该变量的作用域仅限于\",{\"1\":{\"120\":1}}],[\"该函数可以求两个整数的和\",{\"1\":{\"104\":1}}],[\"该接口包括\",{\"1\":{\"50\":1}}],[\"泛型提供了编译时的类型检查\",{\"1\":{\"110\":1}}],[\"泛型允许编写通用函数和数据结构\",{\"1\":{\"110\":1}}],[\"泛型的优势\",{\"0\":{\"110\":1}}],[\"泛型不仅可以用于函数\",{\"1\":{\"106\":1}}],[\"泛型类型\",{\"0\":{\"106\":1}}],[\"泛型函数和类型可以有多个类型参数\",{\"1\":{\"108\":1}}],[\"泛型函数\",{\"0\":{\"105\":1}}],[\"泛型通过类型参数和类型约束实现\",{\"1\":{\"103\":1}}],[\"泛型\",{\"0\":{\"103\":1}}],[\"辅助函数\",{\"1\":{\"102\":1}}],[\"所有未完成的\",{\"1\":{\"207\":1}}],[\"所有派生自该上下文的操作都会收到取消信号\",{\"1\":{\"194\":1}}],[\"所有访问控制以包为基本单位\",{\"1\":{\"102\":1}}],[\"所以可以定义一个工厂函数来创建对象\",{\"1\":{\"149\":1}}],[\"所以通过地址来操作数据时\",{\"1\":{\"141\":1}}],[\"所以我们可以像迭代数组和切片那样迭代它\",{\"1\":{\"124\":1}}],[\"所以在声明阶段就尽可能的给定一个可能会用到的容量\",{\"1\":{\"66\":1}}],[\"字节边界\",{\"1\":{\"156\":1}}],[\"字节且在\",{\"1\":{\"156\":1}}],[\"字节的边界\",{\"1\":{\"156\":3}}],[\"字面量简写形式实例化\",{\"1\":{\"149\":1}}],[\"字面量直接实例化\",{\"1\":{\"149\":1}}],[\"字段和方法\",{\"1\":{\"102\":1}}],[\"字符串类型\",{\"1\":{\"159\":1}}],[\"字符串转换为整数\",{\"1\":{\"53\":1}}],[\"字符串\",{\"1\":{\"37\":1,\"121\":1,\"122\":1,\"126\":1}}],[\"字符串和基本数据类型之间的转换\",{\"1\":{\"14\":1}}],[\"未初始化的\",{\"1\":{\"126\":1}}],[\"未导出\",{\"1\":{\"102\":1}}],[\"未知数组长度\",{\"1\":{\"61\":1}}],[\"导致不可预期的结果\",{\"1\":{\"171\":1}}],[\"导致竞态条件\",{\"1\":{\"167\":1}}],[\"导致栈溢出\",{\"1\":{\"97\":1}}],[\"导出\",{\"1\":{\"102\":1}}],[\"大于等于\",{\"1\":{\"131\":1,\"136\":1}}],[\"大于\",{\"1\":{\"131\":1,\"136\":1}}],[\"大写字母开头\",{\"1\":{\"102\":1}}],[\"大大提高开发效率\",{\"1\":{\"81\":1}}],[\"作为信号传递的占位符\",{\"1\":{\"155\":1}}],[\"作为参数\",{\"0\":{\"141\":1}}],[\"作为参数传递\",{\"1\":{\"126\":1}}],[\"作为参数传递时会传递数组的副本\",{\"1\":{\"101\":1}}],[\"作为键来获取值\",{\"1\":{\"128\":1}}],[\"作为键\",{\"1\":{\"128\":1}}],[\"作为\",{\"1\":{\"128\":3,\"153\":1}}],[\"作为特殊情况\",{\"1\":{\"67\":1}}],[\"都可以执行\",{\"1\":{\"232\":1}}],[\"都可以修改内部的值\",{\"1\":{\"101\":1}}],[\"都是传递对应的副本\",{\"1\":{\"151\":1}}],[\"都是可选的\",{\"1\":{\"121\":1}}],[\"都会随机选择一个满足条件的\",{\"1\":{\"123\":1}}],[\"都不满足时执行\",{\"1\":{\"123\":1}}],[\"都不匹配时执行的代码块\",{\"1\":{\"120\":1}}],[\"都描述了一个通信操作\",{\"1\":{\"123\":1}}],[\"都为\",{\"1\":{\"119\":1}}],[\"都能提供强大的支持\",{\"1\":{\"78\":1}}],[\"转换为了\",{\"1\":{\"101\":1}}],[\"帮我们做了引用\",{\"1\":{\"101\":1}}],[\"帮助信息\",{\"1\":{\"31\":1}}],[\"为\",{\"1\":{\"119\":5}}],[\"为了解决这个问题\",{\"1\":{\"161\":1}}],[\"为了减少结构体的内存占用\",{\"1\":{\"156\":1}}],[\"为了对齐\",{\"1\":{\"156\":1}}],[\"为了满足对齐要求\",{\"1\":{\"156\":1}}],[\"为了提高内存访问效率\",{\"1\":{\"156\":1}}],[\"为了避免这种情况\",{\"1\":{\"128\":1}}],[\"为了安全地检查接口变量是否可以转换为特定类型\",{\"1\":{\"116\":1}}],[\"为了成功匹配接收者的类型\",{\"1\":{\"101\":1}}],[\"为你自己下载安装的对应目录即可\",{\"1\":{\"83\":1}}],[\"此时缓冲区已满\",{\"1\":{\"178\":1}}],[\"此时再通过该指针来修改形参\",{\"1\":{\"101\":1}}],[\"此时即便我们没有使用指针调用\",{\"1\":{\"101\":1}}],[\"此时成功的修改了\",{\"1\":{\"101\":1}}],[\"此时虽然通过实际的数组指针修改了底层数组\",{\"1\":{\"68\":1}}],[\"成倍后\",{\"1\":{\"101\":8}}],[\"成为现代软件开发中的一颗新星\",{\"1\":{\"78\":1}}],[\"成为微服务架构的首选语言之一\",{\"1\":{\"77\":1}}],[\"z\",{\"1\":{\"101\":6}}],[\"zero\",{\"1\":{\"100\":1,\"120\":1}}],[\"两个\",{\"1\":{\"229\":1}}],[\"两种类型\",{\"1\":{\"101\":1}}],[\"两者的区别请参考\",{\"1\":{\"149\":1}}],[\"两者也可同时兼备\",{\"1\":{\"83\":1}}],[\"两者几乎类似\",{\"1\":{\"58\":1}}],[\"说明了切片这种数据类型底层实际上存储了指向切片的指针\",{\"1\":{\"101\":1}}],[\"说明方法属于该接收者\",{\"1\":{\"101\":1}}],[\"说明数组和切片在传递和使用时的区别\",{\"1\":{\"72\":1}}],[\"类似\",{\"1\":{\"196\":1}}],[\"类似与\",{\"1\":{\"115\":1}}],[\"类似的辅助函数\",{\"1\":{\"102\":1}}],[\"类似于\",{\"1\":{\"101\":1,\"121\":1}}],[\"类似于栈\",{\"1\":{\"99\":1}}],[\"类方法\",{\"1\":{\"101\":1}}],[\"类型数据的无缓冲通道\",{\"1\":{\"174\":1}}],[\"类型开关\",{\"1\":{\"120\":1}}],[\"类型安全\",{\"1\":{\"110\":1}}],[\"类型参数可以有约束条件\",{\"1\":{\"107\":1}}],[\"类型约束\",{\"0\":{\"107\":1}}],[\"类型\",{\"1\":{\"102\":1,\"156\":2,\"160\":1}}],[\"类型的计数器\",{\"1\":{\"240\":1}}],[\"类型的管道变量\",{\"1\":{\"160\":1}}],[\"类型的数据\",{\"1\":{\"160\":1}}],[\"类型的变量\",{\"1\":{\"160\":1}}],[\"类型的字段必须对齐到\",{\"1\":{\"156\":2}}],[\"类型的\",{\"1\":{\"101\":1}}],[\"类型的零值是\",{\"1\":{\"126\":2}}],[\"类型的零值\",{\"1\":{\"61\":1}}],[\"类型进行错误处理\",{\"1\":{\"100\":1}}],[\"类型来实现按照姓名排序的需求\",{\"1\":{\"52\":1}}],[\"延迟执行\",{\"0\":{\"99\":1},\"1\":{\"99\":1}}],[\"区别\",{\"1\":{\"96\":1}}],[\"闭包外规则\",{\"1\":{\"223\":1}}],[\"闭包是指一个函数值\",{\"1\":{\"96\":1}}],[\"闭包\",{\"0\":{\"96\":1},\"1\":{\"96\":1}}],[\"闭包等方面的详细说明\",{\"1\":{\"90\":1}}],[\"命名返回值\",{\"1\":{\"93\":1}}],[\"命令行参数解析\",{\"1\":{\"13\":1,\"19\":1}}],[\"命令\",{\"1\":{\"6\":1}}],[\"多路复用模式通过\",{\"1\":{\"188\":1}}],[\"多路复用\",{\"0\":{\"188\":1}}],[\"多路复用通信\",{\"1\":{\"123\":1}}],[\"多个线程可以在多核\",{\"1\":{\"210\":1}}],[\"多个goroutine可以安全地向通道发送\",{\"1\":{\"173\":1}}],[\"多个变量\",{\"1\":{\"162\":1}}],[\"多个匹配条件\",{\"1\":{\"120\":1}}],[\"多个类型参数\",{\"0\":{\"108\":1}}],[\"多个\",{\"1\":{\"99\":1}}],[\"多返回值函数\",{\"1\":{\"93\":1}}],[\"多参数函数\",{\"1\":{\"93\":1}}],[\"匿名函数是指没有名称的函数\",{\"1\":{\"96\":1}}],[\"匿名函数和闭包有啥区别\",{\"1\":{\"96\":1}}],[\"匿名函数可以访问其外层作用域中的变量\",{\"1\":{\"96\":1}}],[\"匿名函数\",{\"0\":{\"95\":1},\"1\":{\"90\":1,\"95\":1}}],[\"返回一个空的上下文\",{\"1\":{\"192\":2}}],[\"返回结果\",{\"1\":{\"184\":1}}],[\"返回该类型的零值\",{\"1\":{\"126\":1}}],[\"返回值变量\",{\"1\":{\"158\":1}}],[\"返回值等\",{\"1\":{\"158\":1}}],[\"返回值以及高级用法\",{\"1\":{\"102\":1}}],[\"返回值类型\",{\"1\":{\"92\":1}}],[\"返回值\",{\"1\":{\"90\":1}}],[\"返回更新的切片\",{\"1\":{\"67\":1}}],[\"与任何值\",{\"1\":{\"128\":1}}],[\"与其他编程语言不同\",{\"1\":{\"121\":1}}],[\"与\",{\"1\":{\"90\":1,\"132\":1,\"149\":1,\"196\":1}}],[\"继续处理结果\",{\"1\":{\"88\":1}}],[\"来定义内存操作之间的同步关系\",{\"1\":{\"214\":1}}],[\"来切换\",{\"1\":{\"211\":1}}],[\"来等待所有的\",{\"1\":{\"207\":1}}],[\"来实现这一点\",{\"1\":{\"207\":1}}],[\"来实现\",{\"1\":{\"202\":1}}],[\"来实现同样的效果\",{\"1\":{\"121\":1}}],[\"来执行\",{\"1\":{\"200\":1}}],[\"来处理大量的任务\",{\"1\":{\"184\":1}}],[\"来确保对共享变量的访问是安全的\",{\"1\":{\"168\":1}}],[\"来取出指针所指向的地址的值\",{\"1\":{\"160\":1}}],[\"来保护\",{\"1\":{\"127\":1}}],[\"来终止\",{\"1\":{\"120\":1}}],[\"来判断文件是否成功打开\",{\"1\":{\"86\":1}}],[\"来创建一个切片\",{\"1\":{\"62\":1}}],[\"你需要检查第二个返回值\",{\"1\":{\"86\":1}}],[\"你可以通过将多个通道操作组合在一起\",{\"1\":{\"233\":1}}],[\"你可以使用类型约束来定义接口\",{\"1\":{\"109\":1}}],[\"你可以根据错误值判断发生了什么问题\",{\"1\":{\"86\":1}}],[\"你可以很方便地管理文件\",{\"1\":{\"47\":1}}],[\"你可以方便地实现和操作环形链表\",{\"1\":{\"28\":1}}],[\"你可以方便地实现和操作双向链表\",{\"1\":{\"26\":1}}],[\"任何类型只要实现了接口定义的所有方法\",{\"1\":{\"113\":1}}],[\"任何实现了\",{\"1\":{\"85\":1}}],[\"任务调度等\",{\"1\":{\"28\":1}}],[\"选择合适自己的开发工具即可\",{\"1\":{\"83\":1}}],[\"选择适合自己的版本进行下载即可\",{\"1\":{\"80\":1}}],[\"各自的选择主要取决于具体的应用场景和性能需求\",{\"1\":{\"212\":1}}],[\"各有优缺\",{\"1\":{\"83\":1}}],[\"各种数据结构\",{\"1\":{\"14\":1}}],[\"无缓冲通道在没有接收者准备好接收数据时会阻塞发送操作\",{\"1\":{\"177\":1}}],[\"无缓冲通道\",{\"0\":{\"176\":1,\"177\":1}}],[\"无序\",{\"1\":{\"126\":1}}],[\"无限循环体\",{\"1\":{\"121\":1}}],[\"无限循环\",{\"1\":{\"121\":1}}],[\"无需加锁即可实现并发安全\",{\"1\":{\"221\":1}}],[\"无需额外的显式同步操作\",{\"1\":{\"173\":1}}],[\"无需使用\",{\"1\":{\"120\":1}}],[\"无需精神内耗\",{\"1\":{\"83\":1}}],[\"无需其他配置\",{\"1\":{\"83\":1}}],[\"无论是传递指针结构体还是值结构体\",{\"1\":{\"151\":1}}],[\"无论是\",{\"1\":{\"78\":1}}],[\"功能全靠插件\",{\"1\":{\"83\":1}}],[\"功能\",{\"1\":{\"83\":1}}],[\"较为麻烦\",{\"1\":{\"83\":1}}],[\"且操作\",{\"1\":{\"214\":1}}],[\"且仅接受\",{\"1\":{\"160\":1}}],[\"且必须按照声明的顺序初始化\",{\"1\":{\"149\":1}}],[\"且只有自定义类型能够拥有方法\",{\"1\":{\"101\":1}}],[\"且有\",{\"1\":{\"83\":1}}],[\"且价格较高\",{\"1\":{\"83\":1}}],[\"且存储的数据类型相同\",{\"1\":{\"59\":1}}],[\"版本收费\",{\"1\":{\"83\":1}}],[\"免费开源\",{\"1\":{\"83\":1}}],[\"轻量级\",{\"1\":{\"83\":1,\"201\":1,\"210\":1}}],[\"轻松处理大量并发任务\",{\"1\":{\"76\":1}}],[\"优缺点对比\",{\"1\":{\"83\":1}}],[\"优先级\",{\"1\":{\"24\":1}}],[\"也称为微线程或纤程\",{\"1\":{\"211\":1}}],[\"也自动结束\",{\"1\":{\"199\":1}}],[\"也无法与其他类型转换\",{\"1\":{\"159\":1}}],[\"也无法直接参与数值运算\",{\"1\":{\"159\":1}}],[\"也可将\",{\"1\":{\"163\":1}}],[\"也可使用字面量进行初始化\",{\"1\":{\"125\":1}}],[\"也可以使用结构体类型\",{\"1\":{\"148\":1}}],[\"也可以作为参数进行传递\",{\"1\":{\"90\":1}}],[\"也可以配置我们自己下载的\",{\"1\":{\"83\":1}}],[\"也必须熟练掌握\",{\"1\":{\"123\":1}}],[\"也对每一个类型都写一个求和函数吗\",{\"1\":{\"104\":1}}],[\"也会立即终止\",{\"1\":{\"207\":1}}],[\"也会有地址\",{\"1\":{\"144\":1}}],[\"也会造成原值的变化\",{\"1\":{\"101\":1}}],[\"也会反应在原切片上\",{\"1\":{\"68\":1}}],[\"也是将指针的内容复制一份传递\",{\"1\":{\"101\":1}}],[\"也就是将原来的值复制一份传递\",{\"1\":{\"101\":1}}],[\"自由度较高\",{\"1\":{\"142\":1}}],[\"自行进行进行了解引用操作\",{\"1\":{\"101\":1}}],[\"自带的\",{\"1\":{\"83\":1}}],[\"自定义类型\",{\"1\":{\"128\":1}}],[\"自定义排序\",{\"0\":{\"50\":1}}],[\"自定义格式化输出\",{\"0\":{\"39\":1}}],[\"自定义使用说明\",{\"0\":{\"33\":1}}],[\"插入和更新操作是相同的\",{\"1\":{\"126\":1}}],[\"插入和删除操作\",{\"1\":{\"124\":1}}],[\"插入或更新\",{\"1\":{\"126\":1}}],[\"插入元素\",{\"1\":{\"24\":1}}],[\"插件\",{\"1\":{\"82\":1}}],[\"一次性初始化多个变量\",{\"1\":{\"161\":1}}],[\"一元运算符\",{\"1\":{\"136\":1}}],[\"一个进程的崩溃不会影响其他进程\",{\"1\":{\"209\":1}}],[\"一个指向整数类型的指针变量\",{\"1\":{\"138\":1}}],[\"一个简单的泛型函数定义如下\",{\"1\":{\"105\":1}}],[\"一个好的开发工具能让你事半功倍\",{\"1\":{\"81\":1}}],[\"一旦初始化\",{\"1\":{\"58\":1}}],[\"请重启电脑使得环境变量生效即可\",{\"1\":{\"80\":1}}],[\"请参考官方文档和代码示例\",{\"1\":{\"11\":1}}],[\"仍无法通过\",{\"1\":{\"80\":1}}],[\"配置\",{\"1\":{\"82\":1,\"83\":2}}],[\"配置变量\",{\"1\":{\"80\":1}}],[\"配置文件解析或者网络通信的程序时\",{\"1\":{\"57\":1}}],[\"下载\",{\"1\":{\"83\":1}}],[\"下载后安装即可\",{\"1\":{\"83\":1}}],[\"下载好后安装即可\",{\"1\":{\"82\":1}}],[\"下载安装\",{\"1\":{\"82\":1,\"83\":1}}],[\"下载地址\",{\"1\":{\"80\":1}}],[\"下面是一个综合示例\",{\"1\":{\"197\":1}}],[\"下面是一个简单的示例\",{\"1\":{\"25\":1,\"27\":1,\"72\":1}}],[\"下面是一个简单的\",{\"1\":{\"8\":1,\"9\":1}}],[\"下面是一段\",{\"1\":{\"142\":1}}],[\"下面是一些使用\",{\"1\":{\"228\":1}}],[\"下面是一些常见的用法示例以及详细解释\",{\"1\":{\"190\":1}}],[\"下面是一些\",{\"1\":{\"43\":1}}],[\"下面是关于\",{\"1\":{\"29\":1}}],[\"跳过即可\",{\"1\":{\"79\":1}}],[\"正号\",{\"1\":{\"136\":1}}],[\"正式学习\",{\"1\":{\"79\":1}}],[\"正数\",{\"1\":{\"28\":1}}],[\"高级用法\",{\"0\":{\"233\":1}}],[\"高效的方式\",{\"1\":{\"172\":1}}],[\"高效和强大的并发处理能力\",{\"1\":{\"78\":1}}],[\"高并发应用的开发者来说\",{\"1\":{\"78\":1}}],[\"高性能\",{\"1\":{\"76\":1}}],[\"系统编程\",{\"1\":{\"77\":1}}],[\"k\",{\"1\":{\"108\":6,\"160\":1,\"163\":2}}],[\"kubernetes\",{\"1\":{\"77\":1}}],[\"ken\",{\"1\":{\"75\":1}}],[\"keys\",{\"1\":{\"108\":6}}],[\"key\",{\"1\":{\"9\":3,\"45\":3,\"122\":3,\"125\":1,\"127\":2,\"128\":5,\"154\":1,\"155\":2,\"197\":5}}],[\"云计算\",{\"1\":{\"77\":1,\"78\":1}}],[\"微服务架构\",{\"1\":{\"77\":1,\"78\":1}}],[\"服务\",{\"1\":{\"77\":1}}],[\"服务器并处理连接\",{\"1\":{\"9\":1}}],[\"服务器并执行命令\",{\"1\":{\"8\":1}}],[\"服务器示例\",{\"1\":{\"9\":1}}],[\"服务器\",{\"0\":{\"9\":1}}],[\"主要关注于包级别的访问限制\",{\"1\":{\"102\":1}}],[\"主要包括\",{\"1\":{\"77\":1}}],[\"主要功能\",{\"0\":{\"10\":1}}],[\"编码解码等常见功能\",{\"1\":{\"76\":1}}],[\"编译器和运行时会在适当的位置插入内存屏障\",{\"1\":{\"217\":1}}],[\"编译器可能会在字段之间插入一些填充字节\",{\"1\":{\"156\":1}}],[\"编译器会根据元素个数自行推断数组的长度\",{\"1\":{\"61\":1}}],[\"编译后的二进制文件执行速度快\",{\"1\":{\"76\":1}}],[\"编译错误\",{\"1\":{\"61\":1}}],[\"涵盖网络\",{\"1\":{\"76\":1}}],[\"涵盖了从基本数据类型到高级网络和并发编程的各个方面\",{\"1\":{\"12\":1}}],[\"丰富的标准库\",{\"1\":{\"76\":1}}],[\"跨平台\",{\"1\":{\"76\":1}}],[\"简单的说就是多个协程之间通信的管道\",{\"1\":{\"199\":1}}],[\"简单赋值\",{\"1\":{\"134\":1,\"136\":1}}],[\"简单易读\",{\"1\":{\"76\":1}}],[\"简化代码\",{\"1\":{\"110\":1}}],[\"简洁性\",{\"1\":{\"102\":1}}],[\"简介\",{\"0\":{\"5\":1}}],[\"旨在提高编程效率\",{\"1\":{\"75\":1}}],[\"设计理念主要有以下几个方面\",{\"1\":{\"102\":1}}],[\"设计\",{\"1\":{\"75\":1}}],[\"设置环境变量\",{\"1\":{\"45\":1}}],[\"设置环境变量的值\",{\"1\":{\"45\":1}}],[\"首次发布于2009年\",{\"1\":{\"75\":1}}],[\"首先需要了解切片的底层结构\",{\"1\":{\"68\":1}}],[\"首先进行数组定义\",{\"1\":{\"61\":1}}],[\"背景\",{\"0\":{\"75\":1}}],[\"介绍\",{\"0\":{\"74\":1,\"76\":1}}],[\"更轻量级\",{\"1\":{\"211\":1,\"212\":1}}],[\"更节省内存\",{\"1\":{\"155\":1}}],[\"更易读\",{\"1\":{\"110\":1}}],[\"更加灵活\",{\"1\":{\"73\":1}}],[\"更多高级用法\",{\"0\":{\"41\":1}}],[\"适用场景\",{\"1\":{\"209\":1,\"210\":1,\"211\":1}}],[\"适用于大量并发的\",{\"1\":{\"212\":1}}],[\"适用于独立运行的任务\",{\"1\":{\"212\":1}}],[\"适用于\",{\"1\":{\"211\":1}}],[\"适用于不同编程语言和不同平台之间的并发处理\",{\"1\":{\"209\":1}}],[\"适用于需要大量并发但对并行性要求不高的场景\",{\"1\":{\"211\":1}}],[\"适用于需要频繁切换和低开销的场景\",{\"1\":{\"210\":1}}],[\"适用于需要频繁插入\",{\"1\":{\"26\":1}}],[\"适用于需要并行处理的任务\",{\"1\":{\"210\":1,\"212\":1}}],[\"适用于需要高度隔离和独立运行的任务\",{\"1\":{\"209\":1}}],[\"适用于跨\",{\"1\":{\"197\":1}}],[\"适用于同一变量的多种条件\",{\"1\":{\"120\":1}}],[\"适用于实时数据分析和处理\",{\"1\":{\"77\":1}}],[\"适用于构建高性能的服务器端应用\",{\"1\":{\"75\":1}}],[\"适合构建高性能应用\",{\"1\":{\"76\":1}}],[\"适合处理动态增删元素的需求\",{\"1\":{\"73\":1}}],[\"适合用于需要静态长度的场景\",{\"1\":{\"73\":1}}],[\"灵活性\",{\"1\":{\"71\":1}}],[\"固定长度\",{\"1\":{\"70\":1}}],[\"有几种方式可以创建一个上下文对象\",{\"1\":{\"192\":1}}],[\"有容量的通道在缓存未满时允许发送操作立即完成\",{\"1\":{\"173\":1}}],[\"有助于编写更高效的代码\",{\"1\":{\"156\":1}}],[\"有助于实现面向对象编程的抽象和多态\",{\"1\":{\"111\":1}}],[\"有助于实现良好的包封装\",{\"1\":{\"102\":1}}],[\"有时候一个操作会调用另一个可能出错的操作\",{\"1\":{\"89\":1}}],[\"有强大的生态支持\",{\"1\":{\"83\":1}}],[\"有较好支持\",{\"1\":{\"83\":1}}],[\"有一些重要的区别\",{\"1\":{\"69\":1}}],[\"有必要存储append的结果\",{\"1\":{\"67\":1}}],[\"才会展现出修改原切片的效果\",{\"1\":{\"68\":1}}],[\"只有当所有线程都到达这个点时\",{\"1\":{\"239\":1}}],[\"只有一个线程可以访问某个资源\",{\"1\":{\"235\":1}}],[\"只有在\",{\"1\":{\"156\":1}}],[\"只有在修改切片内元素的时候\",{\"1\":{\"68\":1}}],[\"只需要在函数调用前加上\",{\"1\":{\"200\":1}}],[\"只需要使用\",{\"1\":{\"162\":1}}],[\"只需实现这个方法即可\",{\"1\":{\"85\":1}}],[\"只不过是在编译阶段\",{\"1\":{\"150\":1}}],[\"只不过数据类型从基本类型变成了指针类型\",{\"1\":{\"145\":1}}],[\"只不过该副本中的内容和原指针变量的内容相同\",{\"1\":{\"141\":1}}],[\"只要能够拿到对应的数据地址\",{\"1\":{\"142\":1}}],[\"只要所有字段支持\",{\"1\":{\"126\":1}}],[\"只要动态类型支持\",{\"1\":{\"126\":1}}],[\"只要你实现了接口中定义的所有方法\",{\"1\":{\"113\":1}}],[\"只接受可比较的类型\",{\"1\":{\"107\":1}}],[\"只是为了使下一个字段的起始地址满足对齐要求\",{\"1\":{\"156\":1}}],[\"只是数据类型不同\",{\"1\":{\"104\":1}}],[\"只是切片中没有初始化长度\",{\"1\":{\"66\":1}}],[\"只能直接调用自身绑定的方法\",{\"1\":{\"101\":1}}],[\"只在函数名前面多了\",{\"1\":{\"101\":1}}],[\"答案是\",{\"1\":{\"101\":1}}],[\"答案是自动扩容的\",{\"1\":{\"66\":1}}],[\"答案依然是不会变化\",{\"1\":{\"68\":1}}],[\"原子加操作\",{\"1\":{\"240\":1}}],[\"原子操作是不可分割的操作\",{\"1\":{\"240\":1}}],[\"原子操作确保对基本数据类型的操作是不可分割的\",{\"1\":{\"221\":1}}],[\"原子操作和通道\",{\"1\":{\"171\":1,\"224\":1}}],[\"原子操作\",{\"0\":{\"221\":1,\"240\":1},\"1\":{\"15\":1,\"166\":1}}],[\"原因是指针运算比较危险\",{\"1\":{\"142\":1}}],[\"原因如下\",{\"1\":{\"101\":1}}],[\"原数据也会发生改变\",{\"1\":{\"141\":1}}],[\"原切片中的指针指向的还是原来的底层数组\",{\"1\":{\"68\":1}}],[\"原切片底层的存储数组没有发生变化\",{\"1\":{\"68\":1}}],[\"8b\",{\"1\":{\"160\":1}}],[\"8\",{\"0\":{\"99\":1,\"137\":1,\"213\":1},\"1\":{\"68\":1,\"98\":1,\"121\":1,\"141\":3,\"156\":9}}],[\"改变\",{\"1\":{\"68\":3}}],[\"改变当前工作目录\",{\"1\":{\"47\":2}}],[\"传递性规则\",{\"1\":{\"214\":1}}],[\"传递上下文\",{\"0\":{\"193\":1}}],[\"传递给一个函数或赋值给另一个变量\",{\"1\":{\"126\":1}}],[\"传递给函数的是该指针的副本\",{\"1\":{\"68\":1}}],[\"传递指针时\",{\"1\":{\"101\":1}}],[\"传递的是切片结构的副本\",{\"1\":{\"71\":1}}],[\"传递的是数组的副本而不是引用\",{\"1\":{\"70\":1}}],[\"传递的是数组值的拷贝\",{\"1\":{\"63\":1}}],[\"传递的是这个切片的副本\",{\"1\":{\"68\":1}}],[\"当向\",{\"1\":{\"227\":1}}],[\"当从\",{\"1\":{\"227\":1}}],[\"当被调用的函数返回时\",{\"1\":{\"199\":1}}],[\"当超时时间到达时\",{\"1\":{\"195\":1}}],[\"当调用返回的取消函数时\",{\"1\":{\"194\":1}}],[\"当做变量或常量使用\",{\"1\":{\"163\":1}}],[\"当一个指针被定义后没有分配到任何变量的时候\",{\"1\":{\"143\":1}}],[\"当其作为\",{\"1\":{\"128\":1}}],[\"当需要从多个通道中接收消息时\",{\"1\":{\"123\":1}}],[\"当没有任何通信情况发生时执行的逻辑\",{\"1\":{\"123\":1}}],[\"当条件为\",{\"1\":{\"121\":1}}],[\"当所有\",{\"1\":{\"120\":1}}],[\"当\",{\"1\":{\"120\":2}}],[\"当将数组作为参数传递给函数时\",{\"1\":{\"70\":1}}],[\"当将切片作为参数传递给函数时\",{\"1\":{\"68\":1}}],[\"当用户使用\",{\"1\":{\"33\":1}}],[\"当用户提供无效的参数或者请求帮助时\",{\"1\":{\"33\":1}}],[\"要启动一个新的\",{\"1\":{\"200\":1}}],[\"要是能将数据类型变成一个变量传进来\",{\"1\":{\"104\":1}}],[\"要求\",{\"1\":{\"104\":1}}],[\"要了解切片作为参数时\",{\"1\":{\"68\":1}}],[\"要安装\",{\"1\":{\"6\":1}}],[\"++p\",{\"1\":{\"142\":1}}],[\"++i\",{\"1\":{\"142\":1}}],[\"+=\",{\"1\":{\"94\":1,\"109\":1,\"121\":1,\"134\":2,\"136\":1,\"170\":1}}],[\"+\",{\"1\":{\"67\":1,\"92\":1,\"95\":1,\"98\":1,\"104\":2,\"113\":1,\"130\":2,\"134\":1,\"136\":3,\"142\":1,\"160\":1}}],[\"+v\",{\"1\":{\"37\":1,\"152\":1}}],[\"需要保存和恢复大量上下文信息\",{\"1\":{\"209\":1}}],[\"需要对齐到\",{\"1\":{\"156\":1}}],[\"需要对其进行查找操作\",{\"1\":{\"128\":1}}],[\"需要在\",{\"1\":{\"156\":1}}],[\"需要注意的是\",{\"1\":{\"116\":1,\"199\":1,\"207\":1}}],[\"需要熟练掌握\",{\"1\":{\"102\":1}}],[\"需要自己配置安装\",{\"1\":{\"83\":1}}],[\"需要配置插件\",{\"1\":{\"83\":1}}],[\"需要借助\",{\"1\":{\"67\":1}}],[\"需要通过实现\",{\"1\":{\"24\":1}}],[\"因为不涉及内核态的切换\",{\"1\":{\"211\":1}}],[\"因为字段\",{\"1\":{\"156\":1}}],[\"因为它不包含任何数据字段\",{\"1\":{\"155\":1}}],[\"因为它不占用内存空间\",{\"1\":{\"155\":1}}],[\"因为它会绕过\",{\"1\":{\"142\":1}}],[\"因为\",{\"1\":{\"128\":3,\"149\":1}}],[\"因为你拷贝的只是指针的副本\",{\"1\":{\"68\":1}}],[\"因为使用\",{\"1\":{\"66\":1}}],[\"因此切片是通过地址引用数组元素的\",{\"1\":{\"160\":1}}],[\"因此在表达式\",{\"1\":{\"136\":1}}],[\"因此对\",{\"1\":{\"126\":1}}],[\"因此输出结果会是\",{\"1\":{\"123\":1}}],[\"因此所有类型都实现了空接口\",{\"1\":{\"115\":1}}],[\"因此rectangle类型就可以被赋值给shape接口变量\",{\"1\":{\"113\":1}}],[\"因此\",{\"1\":{\"67\":1,\"71\":1,\"116\":1,\"156\":2,\"207\":1,\"223\":1}}],[\"否则就会产生歧义\",{\"1\":{\"149\":1}}],[\"否则会无限递归\",{\"1\":{\"97\":1}}],[\"否则会直接报错\",{\"1\":{\"61\":1}}],[\"否则\",{\"1\":{\"67\":1,\"86\":1}}],[\"添加元素\",{\"1\":{\"155\":1}}],[\"添加数据到切片末尾\",{\"1\":{\"67\":1}}],[\"添加\",{\"1\":{\"67\":1}}],[\"修改条件\",{\"1\":{\"236\":1}}],[\"修改共享资源\",{\"1\":{\"235\":1}}],[\"修改结构体字段\",{\"1\":{\"150\":2}}],[\"修改形参并不会对原值曹成变化\",{\"1\":{\"101\":1}}],[\"修改操作都是通过该指针来进行的\",{\"1\":{\"68\":1}}],[\"修改切片内的数组\",{\"1\":{\"67\":1}}],[\"修改\",{\"1\":{\"67\":1,\"68\":3}}],[\"修改数据\",{\"1\":{\"62\":1}}],[\"访问共享资源\",{\"1\":{\"166\":1}}],[\"访问数组元素时\",{\"1\":{\"160\":1}}],[\"访问结构体字段\",{\"1\":{\"150\":2}}],[\"访问结构体成员时使用\",{\"1\":{\"150\":1}}],[\"访问结构体成员\",{\"0\":{\"150\":1}}],[\"访问其指定偏移量的数据\",{\"1\":{\"142\":1}}],[\"访问指针的值\",{\"0\":{\"140\":1}}],[\"访问控制一目了然\",{\"1\":{\"102\":1}}],[\"访问控制\",{\"0\":{\"102\":1}}],[\"访问速度较快\",{\"1\":{\"70\":1}}],[\"访问\",{\"1\":{\"67\":1}}],[\"访问链表尾部元素\",{\"1\":{\"25\":1}}],[\"则执行此\",{\"1\":{\"227\":1}}],[\"则阻塞直到所有的\",{\"1\":{\"207\":1}}],[\"则\",{\"1\":{\"161\":1}}],[\"则在序列化时忽略它\",{\"1\":{\"152\":1,\"153\":1}}],[\"则会立即执行\",{\"1\":{\"231\":1}}],[\"则会执行超时的\",{\"1\":{\"230\":1}}],[\"则会执行\",{\"1\":{\"123\":1}}],[\"则会自动扩容\",{\"1\":{\"66\":1}}],[\"则表示打开文件操作成功\",{\"1\":{\"86\":1}}],[\"则返回一个非\",{\"1\":{\"86\":1}}],[\"则重新许可目的地以容纳新元素\",{\"1\":{\"67\":1}}],[\"则默认会将所有的数组置为\",{\"1\":{\"61\":1}}],[\"还提供了一种简化变量声明和初始化的语法糖\",{\"1\":{\"161\":1}}],[\"还提供了一种特殊的\",{\"1\":{\"121\":1}}],[\"还有其他常见的标签\",{\"1\":{\"154\":1}}],[\"还有一些运算符是右结合的\",{\"1\":{\"136\":1}}],[\"还可以用于定义数据结构\",{\"1\":{\"106\":1}}],[\"还可以当做变量\",{\"1\":{\"90\":1}}],[\"还可开发其他任意语言\",{\"1\":{\"83\":1}}],[\"还是系统编程和数据处理\",{\"1\":{\"78\":1}}],[\"还是不会展现出任何变化\",{\"1\":{\"68\":1}}],[\"还是根据这个容量来限制呢\",{\"1\":{\"66\":1}}],[\"还能提供高效和可靠的解决方案\",{\"1\":{\"20\":1}}],[\"那要是我将该指针指向另外一个新切片呢\",{\"1\":{\"68\":1}}],[\"那到底是可以自动扩容呢\",{\"1\":{\"66\":1}}],[\"那么第一个操作的结果对于第二个操作是可见的\",{\"1\":{\"216\":1}}],[\"那么操作\",{\"1\":{\"214\":1}}],[\"那么这个返回值会被丢弃\",{\"1\":{\"199\":1}}],[\"那么常量即为不变的量\",{\"1\":{\"162\":1}}],[\"那么再来看下面的这个例子\",{\"1\":{\"150\":1}}],[\"那么再加一些需求\",{\"1\":{\"104\":1}}],[\"那么就必须要初始化所有字段\",{\"1\":{\"149\":1}}],[\"那么不同类型的数据可通过结构体来进行存储和组织\",{\"1\":{\"147\":1}}],[\"那么它将作为一个\",{\"1\":{\"120\":1}}],[\"那么要是求两个浮点数的和呢\",{\"1\":{\"104\":1}}],[\"那么要是减少切片长度呢\",{\"1\":{\"68\":1}}],[\"那么\",{\"1\":{\"61\":1}}],[\"指令\",{\"1\":{\"217\":1}}],[\"指向\",{\"1\":{\"160\":1}}],[\"指向数组的第一个元素\",{\"1\":{\"142\":1}}],[\"指向变量\",{\"1\":{\"135\":1,\"139\":1}}],[\"指向底层数组\",{\"1\":{\"68\":1}}],[\"指向的是\",{\"1\":{\"66\":1}}],[\"指针为\",{\"1\":{\"160\":2}}],[\"指针数组本质上是一个数组\",{\"1\":{\"145\":1}}],[\"指针数组\",{\"0\":{\"145\":1}}],[\"指针的指针\",{\"0\":{\"144\":1}}],[\"指针运算\",{\"0\":{\"142\":1}}],[\"指针运算符\",{\"1\":{\"135\":1}}],[\"指针变量声明后\",{\"1\":{\"143\":1}}],[\"指针变量作为参数进行传递时\",{\"1\":{\"141\":1}}],[\"指针变量指向一个内存地址\",{\"1\":{\"137\":1}}],[\"指针是指向变量内存地址的值\",{\"1\":{\"144\":1}}],[\"指针是一个特殊类型的变量\",{\"1\":{\"137\":1}}],[\"指针是什么\",{\"1\":{\"137\":1}}],[\"指针类型\",{\"1\":{\"128\":1,\"160\":1}}],[\"指针接收者\",{\"1\":{\"101\":2}}],[\"指针\",{\"0\":{\"137\":1},\"1\":{\"68\":1,\"126\":1}}],[\"指针等类型的格式化输出\",{\"1\":{\"37\":1}}],[\"指定了容量\",{\"1\":{\"66\":1}}],[\"容量\",{\"1\":{\"66\":1,\"68\":1,\"173\":1}}],[\"长度和容量\",{\"1\":{\"160\":1}}],[\"长度\",{\"1\":{\"66\":1,\"68\":1}}],[\"推荐使用\",{\"1\":{\"66\":1}}],[\"同一线程内的协程可以共享内存\",{\"1\":{\"211\":1}}],[\"同一进程内的线程可以直接访问共享的内存和资源\",{\"1\":{\"210\":1}}],[\"同一进程中的线程共享该进程的内存和其他资源\",{\"1\":{\"210\":1}}],[\"同步操作规则\",{\"1\":{\"214\":1}}],[\"同步和通信通常通过通道\",{\"1\":{\"202\":1}}],[\"同步和通信\",{\"0\":{\"202\":1}}],[\"同步\",{\"1\":{\"182\":1}}],[\"同步原语\",{\"0\":{\"218\":1,\"234\":1},\"1\":{\"15\":1}}],[\"同样没有发送者时也会阻塞接收操作\",{\"1\":{\"177\":1}}],[\"同时等待多个通道操作\",{\"1\":{\"226\":1}}],[\"同时读取\",{\"1\":{\"166\":1,\"220\":1}}],[\"同时声明多个常量时\",{\"1\":{\"162\":1}}],[\"同时声明多个变量\",{\"1\":{\"161\":1}}],[\"同时保证内存对齐\",{\"1\":{\"156\":1}}],[\"同时也限制了指针的使用\",{\"1\":{\"137\":1}}],[\"同时准备好\",{\"1\":{\"123\":1}}],[\"同理即可支持多维数组\",{\"1\":{\"63\":1}}],[\"即在创建时可以指定通道能够缓存的元素数量\",{\"1\":{\"173\":1}}],[\"即发送的数据会按照发送的顺序被接收\",{\"1\":{\"173\":1}}],[\"即指针的指针\",{\"1\":{\"144\":1}}],[\"即为\",{\"1\":{\"144\":2}}],[\"即空指针\",{\"1\":{\"143\":2}}],[\"即可访问\",{\"1\":{\"142\":1}}],[\"即可使用多态\",{\"1\":{\"113\":1}}],[\"即实现了==和\",{\"1\":{\"107\":1}}],[\"即函数的归属不同\",{\"1\":{\"101\":1}}],[\"即使它们都是\",{\"1\":{\"128\":1}}],[\"即使在\",{\"1\":{\"128\":1}}],[\"即使在定义时所在的作用域已经不存在\",{\"1\":{\"96\":1}}],[\"即使只有一行代码\",{\"1\":{\"121\":1}}],[\"即使这些变量不在其参数列表中\",{\"1\":{\"96\":1}}],[\"即使将该指针指向其他地址\",{\"1\":{\"68\":1}}],[\"即错误值\",{\"1\":{\"86\":1}}],[\"即有多少数据\",{\"1\":{\"66\":1}}],[\"即二维数组\",{\"1\":{\"63\":1}}],[\"即相等元素的相对顺序在排序后保持不变\",{\"1\":{\"51\":1}}],[\"而导致资源的过度消耗\",{\"1\":{\"184\":1}}],[\"而无需等待接收方接收\",{\"1\":{\"173\":1}}],[\"而无需针对每种类型编写特定的实现\",{\"1\":{\"110\":1}}],[\"而是代指默认值\",{\"1\":{\"161\":1}}],[\"而是基于现有数组创建一个切片视图\",{\"1\":{\"62\":1}}],[\"而且可能造成极其危险的后果\",{\"1\":{\"161\":1}}],[\"而且可能会有频繁的插入和删除操作\",{\"1\":{\"64\":1}}],[\"而数组和结构体的操作是对其内存块中实际存储的数据进行操作\",{\"1\":{\"160\":1}}],[\"而不是操作系统\",{\"1\":{\"201\":1,\"211\":1}}],[\"而不是地址\",{\"1\":{\"160\":2}}],[\"而不关心具体实现\",{\"1\":{\"111\":1}}],[\"而不需要传递实际数据\",{\"1\":{\"155\":1}}],[\"而不需要重复代码\",{\"1\":{\"106\":1}}],[\"而不需要为每种类型编写单独的代码\",{\"1\":{\"103\":1}}],[\"而函数没有\",{\"1\":{\"101\":1}}],[\"而容量是最大长度\",{\"1\":{\"66\":1}}],[\"而使用\",{\"1\":{\"66\":1}}],[\"而切片是不定长的\",{\"1\":{\"58\":1}}],[\"查找时依然无法找到它\",{\"1\":{\"128\":1}}],[\"查询\",{\"1\":{\"126\":1}}],[\"查询子切片的值\",{\"1\":{\"67\":1}}],[\"查询子数组的值\",{\"1\":{\"62\":1}}],[\"查询索引\",{\"1\":{\"67\":1}}],[\"查看数据\",{\"1\":{\"62\":1}}],[\"故修改形参后能够对原数据造成改变\",{\"1\":{\"151\":1}}],[\"故修改形参时\",{\"1\":{\"101\":1}}],[\"故有指针的指针\",{\"1\":{\"144\":1}}],[\"故可以使用\",{\"1\":{\"125\":1}}],[\"故会修改原值\",{\"1\":{\"101\":1}}],[\"故在修改形参后\",{\"1\":{\"101\":1}}],[\"故方法的接收者为指针时\",{\"1\":{\"101\":1}}],[\"故这里不必定义可直接使用\",{\"1\":{\"93\":1}}],[\"故不会展现出任何变化\",{\"1\":{\"68\":1}}],[\"故不表现出任何变化\",{\"1\":{\"68\":1}}],[\"故表现出来的是没有做任何修改\",{\"1\":{\"68\":1}}],[\"故对形参修改\",{\"1\":{\"68\":1}}],[\"故操作形参数组\",{\"1\":{\"63\":1}}],[\"故多余的数为零值\",{\"1\":{\"61\":1}}],[\"故支持随机访问\",{\"1\":{\"59\":1}}],[\"结合\",{\"1\":{\"123\":1,\"183\":1}}],[\"结构\",{\"1\":{\"120\":1}}],[\"结构体字段直接存储在结构体内存块中\",{\"1\":{\"160\":1}}],[\"结构体可以包含指针字段\",{\"1\":{\"160\":1}}],[\"结构体是一个聚合数据类型\",{\"1\":{\"160\":1}}],[\"结构体是由一系列具有相同类型或不同类型的数据构成的数据集合\",{\"1\":{\"147\":1}}],[\"结构体的大小可能会更小\",{\"1\":{\"156\":1}}],[\"结构体的存储\",{\"0\":{\"156\":1}}],[\"结构体标签解释\",{\"0\":{\"153\":1}}],[\"结构体标签使用案例\",{\"1\":{\"152\":1}}],[\"结构体标签的具体使用如下\",{\"1\":{\"152\":1}}],[\"结构体标签\",{\"0\":{\"152\":1}}],[\"结构体做参数时\",{\"1\":{\"151\":1}}],[\"结构体指针做参数\",{\"1\":{\"151\":1}}],[\"结构体值做参数\",{\"1\":{\"151\":1}}],[\"结构体作为参数\",{\"0\":{\"151\":1}}],[\"结构体为例\",{\"1\":{\"150\":1}}],[\"结构体内部的字段名也遵循首字母大小写命名暴露的方式\",{\"1\":{\"148\":1}}],[\"结构体中不仅可以使用\",{\"1\":{\"148\":1}}],[\"结构体定义需要使用\",{\"1\":{\"148\":1}}],[\"结构体成员访问\",{\"1\":{\"135\":1}}],[\"结构体类型也能作为参数传递给函数\",{\"1\":{\"151\":1}}],[\"结构体类型\",{\"1\":{\"128\":1,\"160\":1}}],[\"结构体\",{\"0\":{\"147\":1},\"1\":{\"102\":1,\"126\":1}}],[\"结构体和\",{\"1\":{\"52\":1}}],[\"结论\",{\"0\":{\"78\":1}}],[\"结果是依然没有变化\",{\"1\":{\"68\":1}}],[\"结果为\",{\"1\":{\"61\":1}}],[\"就相当于你实现了该接口\",{\"1\":{\"113\":1}}],[\"就隐式地实现了该接口\",{\"1\":{\"113\":1}}],[\"就是泛型\",{\"1\":{\"104\":1}}],[\"就是方法的接收者类型\",{\"1\":{\"101\":1}}],[\"就有多少长度\",{\"1\":{\"66\":1}}],[\"就默认将剩余的数据重置为零值\",{\"1\":{\"61\":1}}],[\"就不能更改其大小\",{\"1\":{\"58\":1}}],[\"列表初始化\",{\"1\":{\"61\":1}}],[\"仅获取对应键的值\",{\"1\":{\"126\":1}}],[\"仅在包内可见\",{\"1\":{\"102\":1}}],[\"仅对\",{\"1\":{\"83\":1}}],[\"仅声明\",{\"1\":{\"61\":1}}],[\"仅用于测试\",{\"1\":{\"8\":1}}],[\"可使得在不显式声明数据类型时\",{\"1\":{\"161\":1}}],[\"可使用\",{\"1\":{\"160\":1}}],[\"可使用括号来提升表达式中指定运算符的优先级\",{\"1\":{\"136\":1}}],[\"可能导致不可预知的行为\",{\"1\":{\"142\":1}}],[\"可能会导致数据竞态和程序崩溃\",{\"1\":{\"127\":1}}],[\"可选\",{\"1\":{\"120\":1,\"123\":1}}],[\"可借助辅助函数或者接口\",{\"1\":{\"102\":1}}],[\"可变参数\",{\"1\":{\"94\":1}}],[\"可变参数函数\",{\"0\":{\"94\":1}}],[\"可用于控制逻辑执行\",{\"1\":{\"93\":1}}],[\"可直接定义并初始化变量\",{\"1\":{\"161\":1}}],[\"可直接初始化变量\",{\"1\":{\"161\":1}}],[\"可直接通过内存地址进行数据访问\",{\"1\":{\"161\":1}}],[\"可直接隐藏\",{\"1\":{\"93\":1}}],[\"可直接使用下标索引进行修改\",{\"1\":{\"67\":1}}],[\"可视化界面优秀\",{\"1\":{\"83\":1}}],[\"可将切片中的所有数据置为零值\",{\"1\":{\"67\":1}}],[\"可通过索引下标来进行访问\",{\"1\":{\"62\":1}}],[\"可通过下标索引进行操作\",{\"1\":{\"59\":1}}],[\"可以继续执行\",{\"1\":{\"226\":1,\"238\":1}}],[\"可以确保\",{\"1\":{\"224\":1}}],[\"可以更好地控制\",{\"1\":{\"198\":1}}],[\"可以更方便地控制序列化和反序列化的行为\",{\"1\":{\"154\":1}}],[\"可以创建一个带有截止时间的上下文\",{\"1\":{\"196\":1}}],[\"可以创建一个带有超时的上下文\",{\"1\":{\"195\":1}}],[\"可以通过\",{\"1\":{\"173\":1}}],[\"可以通过一个指针\",{\"1\":{\"142\":1}}],[\"可以编写出高效\",{\"1\":{\"171\":1}}],[\"可以编译成跨平台的可执行文件\",{\"1\":{\"76\":1}}],[\"可以增长和收缩\",{\"1\":{\"160\":1}}],[\"可以重新排列字段的顺序\",{\"1\":{\"156\":1}}],[\"可以简化并发编程的复杂性\",{\"1\":{\"189\":1}}],[\"可以简化并发程序的编写和管理\",{\"1\":{\"123\":1}}],[\"可以简化声明\",{\"1\":{\"148\":1}}],[\"可以有效地管理并发程序的复杂性\",{\"1\":{\"240\":1}}],[\"可以有效地管理并发通信\",{\"1\":{\"123\":1}}],[\"可以有无限指针的循环嵌套\",{\"1\":{\"144\":1}}],[\"可以访问共享资源\",{\"1\":{\"219\":1}}],[\"可以访问指针变量所指向的值\",{\"1\":{\"140\":1}}],[\"可以访问其定义时外部作用域中的变量\",{\"1\":{\"96\":1}}],[\"可以利用指针来简化一些任务的执行\",{\"1\":{\"137\":1}}],[\"可以直接操作内存数据\",{\"1\":{\"137\":1}}],[\"可以直接使用我们配置好的环境变量\",{\"1\":{\"82\":1}}],[\"可以作为\",{\"1\":{\"128\":1}}],[\"可以提升代码的可读性和性能\",{\"1\":{\"123\":1}}],[\"可以实现优先级通道\",{\"1\":{\"233\":1}}],[\"可以实现超时控制\",{\"1\":{\"123\":1}}],[\"可以实现更加灵活和可扩展的代码结构\",{\"1\":{\"117\":1}}],[\"可以是发送操作\",{\"1\":{\"123\":1}}],[\"可以在上下文中存储键值对数据\",{\"1\":{\"197\":1}}],[\"可以在多种场景中提高代码的效率和简洁性\",{\"1\":{\"155\":1}}],[\"可以在\",{\"1\":{\"120\":1}}],[\"可以在同一个\",{\"1\":{\"120\":1}}],[\"可以将rectangle类型的变量赋值给shape接口变量\",{\"1\":{\"114\":1}}],[\"可以定义类似于\",{\"1\":{\"102\":1}}],[\"可以定义多个参数\",{\"1\":{\"93\":1}}],[\"可以被编译器修改\",{\"1\":{\"163\":1}}],[\"可以被其他包访问\",{\"1\":{\"102\":1}}],[\"可以被直接调用或者作为值传递给其他函数\",{\"1\":{\"96\":1}}],[\"可以思考切片这种类型做为参数传递\",{\"1\":{\"101\":1}}],[\"可以类似的看为形参\",{\"1\":{\"101\":1}}],[\"可以为返回值命名\",{\"1\":{\"93\":1}}],[\"可以快速构建高性能的\",{\"1\":{\"77\":1}}],[\"可以自动扩容\",{\"1\":{\"66\":1}}],[\"可以理解为长度是实际的数据长度\",{\"1\":{\"66\":1}}],[\"可以根据数据量来自动扩充\",{\"1\":{\"58\":1}}],[\"可以用于条件逻辑\",{\"1\":{\"120\":1}}],[\"可以用于存储相同类型的数据集合\",{\"1\":{\"58\":1}}],[\"可以用作队列或者栈\",{\"1\":{\"23\":1}}],[\"可以指定进制进行字符串和整数之间的转换\",{\"1\":{\"56\":1}}],[\"可以指定默认值和参数的帮助信息\",{\"1\":{\"31\":1}}],[\"可以方便地对各种类型的数据进行排序操作\",{\"1\":{\"52\":1}}],[\"可以对用户定义的集合进行排序\",{\"1\":{\"50\":1}}],[\"可以很好地满足大部分的格式化输出需求\",{\"1\":{\"42\":1}}],[\"可以生成格式化的错误信息\",{\"1\":{\"40\":1}}],[\"可以从标准输入中读取数据\",{\"1\":{\"38\":1}}],[\"可以使用带缓冲的通道来模拟\",{\"1\":{\"237\":1}}],[\"可以使用带有两个返回值的类型断言\",{\"1\":{\"116\":1}}],[\"可以使用以下方式检测通道是否关闭\",{\"1\":{\"179\":1}}],[\"可以使用原子操作来避免竞态条件\",{\"1\":{\"169\":1}}],[\"可以使用互斥锁\",{\"1\":{\"168\":1}}],[\"可以使用空的\",{\"1\":{\"121\":1}}],[\"可以使用切片表达式\",{\"1\":{\"71\":1}}],[\"可以使用切片操作符\",{\"1\":{\"62\":1}}],[\"可以使用各种格式化占位符来指定输出的格式\",{\"1\":{\"37\":1}}],[\"可以使用\",{\"1\":{\"30\":1,\"61\":1,\"83\":1,\"87\":1,\"127\":1,\"142\":1,\"194\":1,\"203\":1,\"207\":1,\"240\":1}}],[\"可以高效地提取最小或最大元素\",{\"1\":{\"24\":1}}],[\"中并发执行\",{\"1\":{\"199\":1}}],[\"中处理来自多个来源的数据\",{\"1\":{\"185\":1}}],[\"中常量和变量类似\",{\"1\":{\"162\":1}}],[\"中变量可通过\",{\"1\":{\"161\":1}}],[\"中函数可像普通变量一样被传递\",{\"1\":{\"160\":1}}],[\"中函数是对代码封装和重用的基本形式\",{\"1\":{\"90\":1}}],[\"中结构体在内存中的存储是按其字段在结构体中声明的顺序来排列的\",{\"1\":{\"156\":1}}],[\"中结构体标签是一种元数据\",{\"1\":{\"152\":1}}],[\"中是一个非常有用的工具\",{\"1\":{\"155\":1}}],[\"中是通过引用传递数组的\",{\"1\":{\"101\":1}}],[\"中创建结构体实例的几种方式\",{\"1\":{\"149\":1}}],[\"中抛弃了类与继承\",{\"1\":{\"147\":1}}],[\"中相同类型的数据可以使用数组或者切片来存储\",{\"1\":{\"147\":1}}],[\"中支持指针运算\",{\"1\":{\"142\":1}}],[\"中声明一个指针变量需要使用\",{\"1\":{\"138\":1}}],[\"中也提供了指针\",{\"1\":{\"137\":1,\"142\":1}}],[\"中提供了指针这种类型\",{\"1\":{\"137\":1}}],[\"中提供了数组类型的数据结构\",{\"1\":{\"58\":1}}],[\"中插入了一个键\",{\"1\":{\"128\":1}}],[\"中同时读写同一个\",{\"1\":{\"127\":1}}],[\"中每个元素的索引和值\",{\"1\":{\"121\":1}}],[\"中没有构造方法\",{\"1\":{\"149\":1}}],[\"中没有构造方法的概念\",{\"1\":{\"149\":1}}],[\"中没有\",{\"1\":{\"121\":1}}],[\"中没有提供\",{\"1\":{\"121\":1}}],[\"中没有明确的继承和实现\",{\"1\":{\"113\":1}}],[\"中那样显式使用\",{\"1\":{\"120\":1}}],[\"中非常强大和灵活\",{\"1\":{\"111\":1}}],[\"中\",{\"1\":{\"111\":1,\"128\":2,\"136\":1,\"155\":1,\"202\":1,\"214\":1}}],[\"中接收者不能直接调用属于包的函数\",{\"1\":{\"101\":1}}],[\"中的语句\",{\"1\":{\"226\":1}}],[\"中的操作开始\",{\"1\":{\"223\":1}}],[\"中的操作按程序顺序执行\",{\"1\":{\"223\":1}}],[\"中的常量计数器\",{\"1\":{\"163\":1}}],[\"中的一个特殊常量\",{\"1\":{\"163\":1}}],[\"中的一切对象继承自\",{\"1\":{\"115\":1}}],[\"中的数据类型分为\",{\"1\":{\"158\":1}}],[\"中的数组是直接存储在内存中的值\",{\"1\":{\"101\":1}}],[\"中的键值对是无序的\",{\"1\":{\"126\":1}}],[\"中的详细解释和用法说明\",{\"1\":{\"123\":1}}],[\"中的访问控制是通过其名称的第一个首字母进行区分的\",{\"1\":{\"102\":1}}],[\"中的\",{\"1\":{\"101\":1,\"121\":2,\"123\":1,\"127\":1,\"223\":2}}],[\"中的函数功能似乎更加强大\",{\"1\":{\"90\":1}}],[\"中不同的是\",{\"1\":{\"101\":1}}],[\"中方法与函数的区别在于\",{\"1\":{\"101\":1}}],[\"中新添加了\",{\"1\":{\"67\":1}}],[\"中还提供了一个切片类型\",{\"1\":{\"58\":1}}],[\"除了\",{\"1\":{\"154\":1}}],[\"除了优先级外\",{\"1\":{\"136\":1}}],[\"除了使用\",{\"1\":{\"32\":1}}],[\"除法赋值\",{\"1\":{\"134\":1}}],[\"除法\",{\"1\":{\"130\":1,\"136\":1}}],[\"除此之外\",{\"1\":{\"58\":1}}],[\"7\",{\"0\":{\"58\":1,\"98\":1,\"164\":1},\"1\":{\"68\":1,\"95\":1,\"130\":1,\"133\":1}}],[\"经常会用到\",{\"1\":{\"57\":1}}],[\"错误链\",{\"0\":{\"89\":1}}],[\"错误值被用来指示函数执行过程中是否出现了问题\",{\"1\":{\"86\":1}}],[\"错误接口\",{\"0\":{\"85\":1}}],[\"错误\",{\"0\":{\"84\":1},\"1\":{\"84\":1}}],[\"错误处理\",{\"0\":{\"100\":1},\"1\":{\"56\":1,\"100\":1}}],[\"错误输出\",{\"0\":{\"40\":1}}],[\"示例分析\",{\"1\":{\"223\":1}}],[\"示例代码\",{\"0\":{\"206\":1,\"228\":1}}],[\"示例和内存布局\",{\"1\":{\"156\":1}}],[\"示例\",{\"0\":{\"229\":1,\"230\":1,\"231\":1},\"1\":{\"52\":1,\"121\":4,\"123\":1,\"128\":1}}],[\"示例结构体\",{\"1\":{\"24\":1}}],[\"9\",{\"0\":{\"100\":1,\"147\":1},\"1\":{\"49\":2,\"68\":1}}],[\"对一个互斥锁的解锁操作\",{\"1\":{\"223\":1}}],[\"对共享资源的访问\",{\"1\":{\"165\":1}}],[\"对齐意味着字段的起始地址必须是其类型大小的倍数\",{\"1\":{\"156\":1}}],[\"对应的rune值\",{\"1\":{\"122\":1}}],[\"对应的也会造成原值的改变\",{\"1\":{\"101\":1}}],[\"对象方法\",{\"1\":{\"101\":1}}],[\"对切片的操作是通过该指针来进行的\",{\"1\":{\"101\":1}}],[\"对于简单的计数操作\",{\"1\":{\"169\":1}}],[\"对于通道\",{\"1\":{\"122\":1}}],[\"对于映射\",{\"1\":{\"122\":1}}],[\"对于字符串\",{\"1\":{\"122\":1}}],[\"对于数组和切片\",{\"1\":{\"122\":1}}],[\"对于调试开发更为优雅舒适\",{\"1\":{\"83\":1}}],[\"对于希望构建高性能\",{\"1\":{\"78\":1}}],[\"对\",{\"1\":{\"52\":1}}],[\"对实现了\",{\"1\":{\"52\":1}}],[\"对字符串类型的切片进行升序排序\",{\"1\":{\"49\":1}}],[\"对浮点数类型的切片进行升序排序\",{\"1\":{\"49\":1}}],[\"对整数类型的切片进行升序排序\",{\"1\":{\"49\":1}}],[\"对结构体输出字段名\",{\"1\":{\"37\":1}}],[\"排序稳定性\",{\"0\":{\"51\":1}}],[\"排序函数\",{\"0\":{\"49\":1}}],[\"排序算法\",{\"1\":{\"14\":1}}],[\"使代码更加简洁和易读\",{\"1\":{\"120\":1}}],[\"使代码更简洁\",{\"1\":{\"110\":1}}],[\"使得代码更加简洁和易于维护\",{\"1\":{\"233\":1}}],[\"使得\",{\"1\":{\"156\":1}}],[\"使得泛型函数或类型只能接受特定类型\",{\"1\":{\"107\":1}}],[\"使得函数和数据结构可以处理任意类型的数据\",{\"1\":{\"103\":1}}],[\"使得返回值在函数体内被赋值时无需显示\",{\"1\":{\"93\":1}}],[\"使得开发者可以清晰地处理和传播错误信息\",{\"1\":{\"89\":1}}],[\"使得用户可以根据特定的需求进行排序\",{\"1\":{\"48\":1}}],[\"使用的内存非常少\",{\"1\":{\"201\":1}}],[\"使用的方法和数组完全相同\",{\"1\":{\"67\":1}}],[\"使用通道的示例\",{\"0\":{\"180\":1}}],[\"使用通道\",{\"0\":{\"170\":1}}],[\"使用原子操作\",{\"0\":{\"169\":1}}],[\"使用空结构体嵌入其他结构体中\",{\"1\":{\"155\":1}}],[\"使用空结构体作为\",{\"1\":{\"155\":2}}],[\"使用空结构体作为信号传递的占位符\",{\"1\":{\"155\":1}}],[\"使用取地址符号实例化\",{\"1\":{\"149\":1}}],[\"使用指针算术运算访问数组的特定元素\",{\"1\":{\"142\":1}}],[\"使用指针遍历数组\",{\"1\":{\"142\":1}}],[\"使用约束定义接口\",{\"0\":{\"109\":1}}],[\"使用闭包可以实现状态的保持和管理\",{\"1\":{\"96\":1}}],[\"使用匿名函数可以简化代码结构\",{\"1\":{\"96\":1}}],[\"使用场景\",{\"1\":{\"96\":1,\"123\":1}}],[\"使用流行的框架如\",{\"1\":{\"77\":1}}],[\"使用\",{\"1\":{\"26\":1,\"28\":1,\"30\":1,\"33\":1,\"38\":1,\"40\":1,\"82\":1,\"107\":1,\"121\":1,\"126\":2,\"128\":1,\"142\":1,\"149\":1,\"153\":1,\"160\":1,\"170\":1,\"195\":1,\"196\":1,\"197\":1,\"204\":1,\"232\":1,\"233\":1,\"240\":1}}],[\"quotient\",{\"1\":{\"93\":2,\"130\":1}}],[\"quicksort\",{\"1\":{\"48\":1}}],[\"queue\",{\"0\":{\"23\":1},\"1\":{\"23\":1}}],[\"目录\",{\"1\":{\"47\":1}}],[\"目录操作\",{\"1\":{\"44\":1}}],[\"终止当前进程\",{\"1\":{\"46\":1}}],[\"终止当前进程并返回指定的状态码\",{\"1\":{\"46\":1}}],[\"递归\",{\"1\":{\"97\":1}}],[\"递归函数\",{\"0\":{\"97\":1}}],[\"递归删除目录\",{\"1\":{\"44\":1}}],[\"递归删除一个目录及其子目录\",{\"1\":{\"44\":1}}],[\"递归创建目录\",{\"1\":{\"44\":1}}],[\"递归创建多层目录\",{\"1\":{\"44\":1}}],[\"打开文件\",{\"1\":{\"44\":1}}],[\"打开一个文件\",{\"1\":{\"44\":1}}],[\"打印最终结果\",{\"1\":{\"235\":1}}],[\"打印结果\",{\"1\":{\"184\":1,\"187\":1}}],[\"打印轮转后的环形链表的所有值\",{\"1\":{\"27\":1}}],[\"打印环形链表的所有值\",{\"1\":{\"27\":1}}],[\"文件描述符和其他资源\",{\"1\":{\"209\":1}}],[\"文件系统\",{\"1\":{\"76\":1}}],[\"文件操作\",{\"1\":{\"44\":1}}],[\"文件和目录操作\",{\"0\":{\"44\":1}}],[\"64\",{\"1\":{\"54\":1,\"55\":1,\"160\":1}}],[\"6\",{\"0\":{\"41\":1,\"90\":1,\"97\":1,\"189\":1,\"190\":1,\"240\":1},\"1\":{\"49\":2,\"68\":1,\"98\":1,\"109\":2,\"121\":1,\"133\":1,\"185\":1}}],[\"yield\",{\"1\":{\"211\":1}}],[\"yaml\",{\"1\":{\"154\":4}}],[\"y\",{\"1\":{\"93\":5,\"98\":2,\"100\":3,\"101\":6,\"141\":8}}],[\"years\",{\"1\":{\"39\":2,\"126\":1,\"127\":1}}],[\"your\",{\"1\":{\"8\":3,\"30\":2,\"31\":4,\"33\":2,\"38\":1}}],[\"浮点数\",{\"1\":{\"37\":1}}],[\"不必我们手动实现\",{\"1\":{\"150\":1}}],[\"不能直接把\",{\"1\":{\"163\":1}}],[\"不能直接存储键值对\",{\"1\":{\"126\":1}}],[\"不能使用\",{\"1\":{\"149\":1}}],[\"不要使用\",{\"1\":{\"128\":1}}],[\"不等于\",{\"1\":{\"128\":1,\"131\":1,\"136\":1}}],[\"不等于任何值\",{\"1\":{\"128\":1}}],[\"不过\",{\"1\":{\"124\":1,\"142\":1,\"160\":1}}],[\"不需要像\",{\"1\":{\"120\":1}}],[\"不包含任何方法\",{\"1\":{\"115\":1}}],[\"不就可以了吗\",{\"1\":{\"104\":1}}],[\"不会立即阻塞发送操作\",{\"1\":{\"178\":1}}],[\"不会影响原有的值\",{\"1\":{\"101\":1}}],[\"不会改变原有的数组值\",{\"1\":{\"63\":1}}],[\"不管调用者是不是指针\",{\"1\":{\"101\":1}}],[\"不仅难度高\",{\"1\":{\"161\":1}}],[\"不仅可以当做代码的封装\",{\"1\":{\"90\":1}}],[\"不仅能帮助开发者快速构建应用程序\",{\"1\":{\"20\":1}}],[\"不同的是\",{\"1\":{\"90\":1}}],[\"不添加换行符\",{\"1\":{\"36\":1}}],[\"必须在操作\",{\"1\":{\"214\":1}}],[\"必须调用\",{\"1\":{\"30\":1}}],[\"必先利其器\",{\"1\":{\"81\":1}}],[\"必选参数\",{\"1\":{\"34\":1}}],[\"或者下面这种形式\",{\"1\":{\"150\":1}}],[\"或者编译时错误\",{\"1\":{\"128\":1}}],[\"或者使用\",{\"1\":{\"127\":1}}],[\"或者\",{\"1\":{\"120\":1}}],[\"或者提供无效参数时\",{\"1\":{\"33\":1}}],[\"或称\",{\"1\":{\"75\":1}}],[\"或\",{\"1\":{\"70\":1,\"71\":1,\"127\":1,\"132\":1}}],[\"或向后\",{\"1\":{\"28\":1}}],[\"默认零值为\",{\"1\":{\"143\":1}}],[\"默认是扩容为当前容量的两倍\",{\"1\":{\"66\":1}}],[\"默认格式\",{\"1\":{\"37\":1}}],[\"默认情况下\",{\"1\":{\"33\":1}}],[\"默认值和帮助信息等\",{\"1\":{\"34\":1}}],[\"默认值和帮助信息\",{\"0\":{\"31\":1}}],[\"非阻塞的通道操作\",{\"0\":{\"231\":1}}],[\"非\",{\"1\":{\"132\":1}}],[\"非常方便\",{\"1\":{\"83\":1}}],[\"非命令行参数\",{\"0\":{\"32\":1}}],[\"非对称加密算法\",{\"1\":{\"18\":1}}],[\"会随机选择一个执行\",{\"1\":{\"232\":1}}],[\"会随机选择其中之一\",{\"1\":{\"123\":1}}],[\"会看到\",{\"1\":{\"223\":1}}],[\"会默认给定对应的\",{\"1\":{\"161\":1}}],[\"会得到以下输出\",{\"1\":{\"156\":1}}],[\"会对结构体字段进行对齐\",{\"1\":{\"156\":1}}],[\"会被解析为\",{\"1\":{\"150\":1}}],[\"会返回\",{\"1\":{\"128\":1}}],[\"会引发运行时恐慌\",{\"1\":{\"116\":1}}],[\"会修改原值\",{\"1\":{\"101\":1}}],[\"会将接收者的值传入方法中\",{\"1\":{\"101\":1}}],[\"会自动扩容\",{\"1\":{\"67\":1}}],[\"会分配指定大小的内存空间\",{\"1\":{\"66\":1}}],[\"会显示自定义的使用说明信息\",{\"1\":{\"33\":1}}],[\"会输出默认的使用说明信息\",{\"1\":{\"33\":1}}],[\"会在用户请求帮助时显示出来\",{\"1\":{\"31\":1}}],[\"会话\",{\"1\":{\"10\":1}}],[\"会话管理\",{\"1\":{\"5\":1,\"10\":1}}],[\"参数传递\",{\"1\":{\"102\":1}}],[\"参数类型可以相同或不同\",{\"1\":{\"93\":1}}],[\"参数与返回值\",{\"0\":{\"93\":1}}],[\"参数列表\",{\"1\":{\"92\":1}}],[\"参数\",{\"1\":{\"90\":1,\"158\":1}}],[\"参数指定对应的值\",{\"1\":{\"30\":1}}],[\"参考资料\",{\"0\":{\"11\":1}}],[\"和主程序\",{\"0\":{\"207\":1}}],[\"和通道的示例\",{\"1\":{\"206\":1}}],[\"和接收\",{\"1\":{\"173\":1}}],[\"和竞态条件\",{\"1\":{\"164\":1}}],[\"和浮点数类型\",{\"1\":{\"159\":1}}],[\"和数学中类似\",{\"1\":{\"136\":1}}],[\"和perimeter\",{\"1\":{\"112\":1,\"113\":1}}],[\"和切片\",{\"1\":{\"69\":1}}],[\"和堆排序\",{\"1\":{\"48\":1}}],[\"和\",{\"1\":{\"30\":2,\"31\":4,\"32\":1,\"36\":1,\"50\":1,\"75\":1,\"76\":3,\"77\":2,\"81\":1,\"83\":1,\"89\":1,\"101\":3,\"119\":1,\"121\":2,\"123\":2,\"126\":1,\"148\":1,\"149\":1,\"151\":1,\"156\":2,\"158\":1,\"161\":1,\"168\":1,\"172\":1,\"229\":1}}],[\"函数完成后通过通道通知\",{\"1\":{\"238\":1}}],[\"函数模拟工作\",{\"1\":{\"237\":1,\"239\":1}}],[\"函数设置条件变量\",{\"1\":{\"236\":1}}],[\"函数等待条件变量满足条件\",{\"1\":{\"236\":1}}],[\"函数等对切片进行操作\",{\"1\":{\"71\":1}}],[\"函数结束时减少\",{\"1\":{\"235\":1,\"239\":1}}],[\"函数结束时解锁\",{\"1\":{\"235\":1}}],[\"函数使用互斥锁来确保对共享资源的安全访问\",{\"1\":{\"235\":1}}],[\"函数体\",{\"1\":{\"193\":1}}],[\"函数处理来自\",{\"1\":{\"186\":1}}],[\"函数从通道\",{\"1\":{\"180\":1,\"206\":1}}],[\"函数向通道\",{\"1\":{\"180\":1,\"206\":1}}],[\"函数创建通道\",{\"1\":{\"203\":1}}],[\"函数创建\",{\"1\":{\"174\":1}}],[\"函数关闭通道\",{\"1\":{\"173\":1}}],[\"函数类型赋值\",{\"1\":{\"160\":1}}],[\"函数类型声明\",{\"1\":{\"160\":1}}],[\"函数类型\",{\"1\":{\"160\":1}}],[\"函数实例化\",{\"1\":{\"149\":1}}],[\"函数和包含切片的结构体不能作为键\",{\"1\":{\"126\":1}}],[\"函数只能用于可比较的类型\",{\"1\":{\"107\":1}}],[\"函数是最高频被使用到的技术点\",{\"1\":{\"102\":1}}],[\"函数的主要特性和用法示例\",{\"1\":{\"102\":1}}],[\"函数的定义\",{\"1\":{\"90\":1}}],[\"函数参数的传递过程中\",{\"1\":{\"101\":1}}],[\"函数作为返回值\",{\"1\":{\"98\":1}}],[\"函数作为参数\",{\"1\":{\"98\":1}}],[\"函数作为参数和返回值\",{\"0\":{\"98\":1}}],[\"函数可以返回另一个函数\",{\"1\":{\"98\":1}}],[\"函数可以返回多个值\",{\"1\":{\"93\":1}}],[\"函数可以作为参数传递给其他函数\",{\"1\":{\"98\":1}}],[\"函数可以调用自身来解决问题\",{\"1\":{\"97\":1}}],[\"函数可以是匿名的\",{\"1\":{\"95\":1}}],[\"函数可以接收变长参数列表\",{\"1\":{\"94\":1}}],[\"函数可以自定义程序的使用说明\",{\"1\":{\"33\":1}}],[\"函数名称\",{\"1\":{\"92\":1}}],[\"函数调用\",{\"1\":{\"92\":1}}],[\"函数定义\",{\"1\":{\"92\":1}}],[\"函数定义使用\",{\"1\":{\"92\":1}}],[\"函数定义与调用\",{\"0\":{\"92\":1}}],[\"函数方法\",{\"0\":{\"90\":1}}],[\"函数外部切片受影响\",{\"1\":{\"72\":1}}],[\"函数外部数组不受影响\",{\"1\":{\"72\":1}}],[\"函数内部修改切片\",{\"1\":{\"72\":1}}],[\"函数内部修改数组\",{\"1\":{\"72\":1}}],[\"函数来删除指定的键值对\",{\"1\":{\"126\":1}}],[\"函数来创建\",{\"1\":{\"125\":1}}],[\"函数来创建一个新的错误\",{\"1\":{\"87\":1}}],[\"函数来实现错误链\",{\"1\":{\"89\":1}}],[\"函数来完成\",{\"1\":{\"67\":1}}],[\"函数来获取\",{\"1\":{\"32\":1,\"126\":1}}],[\"函数语法如下\",{\"1\":{\"67\":1}}],[\"函数用于打开文件\",{\"1\":{\"86\":1}}],[\"函数用于返回格式化后的字符串\",{\"1\":{\"41\":1}}],[\"函数用于解析命令行参数\",{\"1\":{\"30\":1}}],[\"函数中的数据类型参数不难理解\",{\"1\":{\"66\":1}}],[\"函数中\",{\"1\":{\"37\":1}}],[\"函数\",{\"0\":{\"91\":1},\"1\":{\"30\":1,\"67\":2,\"102\":1,\"149\":2,\"184\":1,\"235\":1,\"237\":1,\"238\":1,\"239\":1}}],[\"接收到数据时执行\",{\"1\":{\"227\":1}}],[\"接收数据并打印\",{\"1\":{\"180\":1,\"206\":1}}],[\"接收者阻塞直到有发送者\",{\"1\":{\"177\":1}}],[\"接收信号\",{\"1\":{\"155\":1}}],[\"接收操作或者仅仅是用于阻塞当前\",{\"1\":{\"123\":1}}],[\"接下来\",{\"1\":{\"28\":1}}],[\"接口类型\",{\"1\":{\"126\":1}}],[\"接口类型来表示错误\",{\"1\":{\"84\":1}}],[\"接口是go语言中实现多态和抽象的关键机制之一\",{\"1\":{\"117\":1}}],[\"接口是一个只包含一个方法的接口\",{\"1\":{\"85\":1}}],[\"接口可以通过组合多个接口来定义新的接口\",{\"1\":{\"117\":1}}],[\"接口组合\",{\"0\":{\"117\":1}}],[\"接口断言\",{\"0\":{\"116\":1}}],[\"接口变量可以通过类型断言来获取其底层具体类型的值\",{\"1\":{\"116\":1}}],[\"接口变量可以存储任何实现了接口的类型的值\",{\"1\":{\"114\":1}}],[\"接口变量\",{\"0\":{\"114\":1}}],[\"接口实现\",{\"0\":{\"113\":1}}],[\"接口定义使用\",{\"1\":{\"112\":1}}],[\"接口定义\",{\"0\":{\"112\":1}}],[\"接口定义了对象可以响应的方法集合\",{\"1\":{\"111\":1}}],[\"接口等\",{\"1\":{\"102\":1}}],[\"接口的集合进行排序\",{\"1\":{\"52\":1}}],[\"接口\",{\"0\":{\"111\":1},\"1\":{\"24\":1,\"41\":1,\"50\":1,\"102\":1,\"111\":1}}],[\"接口来使用\",{\"1\":{\"24\":1}}],[\"然后执行该\",{\"1\":{\"226\":1}}],[\"然后将\",{\"1\":{\"136\":1}}],[\"然后再加上\",{\"1\":{\"136\":1}}],[\"然后退出循环\",{\"1\":{\"121\":1}}],[\"然后初始化\",{\"1\":{\"61\":1}}],[\"然后打印出排序后的结果\",{\"1\":{\"52\":1}}],[\"然后打印环形链表的所有值\",{\"1\":{\"28\":1}}],[\"然后\",{\"1\":{\"28\":1,\"180\":1,\"206\":1}}],[\"然后向其中添加了几个元素\",{\"1\":{\"26\":1}}],[\"个\",{\"1\":{\"235\":1,\"237\":1,\"239\":1,\"240\":1}}],[\"个类型为\",{\"1\":{\"160\":1}}],[\"个填充字节\",{\"1\":{\"156\":2}}],[\"个字节\",{\"1\":{\"156\":3}}],[\"个元素\",{\"1\":{\"67\":3}}],[\"个元素的环形链表\",{\"1\":{\"28\":1}}],[\"个位置\",{\"1\":{\"28\":1}}],[\"轮转\",{\"1\":{\"28\":1}}],[\"轮转操作\",{\"1\":{\"28\":1}}],[\"将多个通道合并为一个通道\",{\"1\":{\"185\":1}}],[\"将结构体序列化为\",{\"1\":{\"152\":1}}],[\"将该类型的值赋值给接口类型的变量\",{\"1\":{\"113\":1}}],[\"将值接收者变为指针接收者\",{\"1\":{\"101\":1}}],[\"将上述代码进行修改\",{\"1\":{\"101\":1}}],[\"将\",{\"1\":{\"101\":8,\"152\":1}}],[\"将一些逻辑封装成临时使用的函数\",{\"1\":{\"96\":1}}],[\"将字符串添加到\",{\"1\":{\"67\":1}}],[\"将字符串转换为浮点数类型\",{\"1\":{\"54\":1}}],[\"将字符串转换为整数类型\",{\"1\":{\"54\":1}}],[\"将字符串转换为基本数据类型\",{\"0\":{\"54\":1}}],[\"将分配一个新的底层阵列\",{\"1\":{\"67\":1}}],[\"将浮点数转换为字符串类型\",{\"1\":{\"55\":1}}],[\"将整数转换为字符串类型\",{\"1\":{\"55\":1}}],[\"将基本数据类型转换为字符串\",{\"0\":{\"55\":1}}],[\"将链表向前移动一个位置\",{\"1\":{\"28\":1}}],[\"将环形链表向前\",{\"1\":{\"28\":1}}],[\"将元素添加到链表的头部\",{\"1\":{\"26\":1}}],[\"将元素添加到链表的末尾\",{\"1\":{\"26\":1}}],[\"循环结合使用\",{\"1\":{\"123\":1}}],[\"循环没有括号\",{\"1\":{\"121\":1}}],[\"循环的三个部分\",{\"1\":{\"121\":1}}],[\"循环的条件判断表达式\",{\"1\":{\"121\":1}}],[\"循环来实现无限循环\",{\"1\":{\"121\":1}}],[\"循环模拟\",{\"1\":{\"121\":1}}],[\"循环开始前执行的初始化语句\",{\"1\":{\"121\":1}}],[\"循环体必须用大括号\",{\"1\":{\"121\":1}}],[\"循环体\",{\"1\":{\"121\":2}}],[\"循环\",{\"1\":{\"121\":5}}],[\"循环有三种基本形式\",{\"1\":{\"121\":1}}],[\"循环是一种常见的控制流结构\",{\"1\":{\"121\":1}}],[\"循环为每个节点赋值\",{\"1\":{\"28\":1}}],[\"循环初始化环形链表的每个节点的值\",{\"1\":{\"28\":1}}],[\"循环遍历链表\",{\"1\":{\"26\":1}}],[\"初始大小一般较小\",{\"1\":{\"201\":1}}],[\"初始\",{\"1\":{\"101\":8}}],[\"初始化\",{\"1\":{\"192\":1}}],[\"初始化单个变量\",{\"1\":{\"161\":1}}],[\"初始化列表中的元素个数超过数组声明的长度\",{\"1\":{\"61\":1}}],[\"初始化环形链表的值\",{\"1\":{\"27\":1}}],[\"初始长度为\",{\"1\":{\"27\":1}}],[\"这行代码会启动一个新的\",{\"1\":{\"200\":1}}],[\"这次调用就会在一个新的\",{\"1\":{\"199\":1}}],[\"这表明通过优化字段顺序\",{\"1\":{\"156\":1}}],[\"这会导致结构体在内存中占用的空间比字段本身的大小总和更多\",{\"1\":{\"156\":1}}],[\"这是\",{\"1\":{\"150\":1}}],[\"这是极度危险的\",{\"1\":{\"142\":1}}],[\"这是因为为了能够和接收者类型进行匹配\",{\"1\":{\"101\":1}}],[\"这是因为这里方法的接收者是值\",{\"1\":{\"101\":1}}],[\"这是因为在函数调用失败时\",{\"1\":{\"88\":1}}],[\"这影响了表达式中运算符执行的顺序\",{\"1\":{\"136\":1}}],[\"这几个语句最为重要\",{\"1\":{\"123\":1}}],[\"这段代码会输出数组\",{\"1\":{\"121\":1}}],[\"这两个方法返回浮点数类型\",{\"1\":{\"112\":1}}],[\"这两个开发工具\",{\"1\":{\"81\":1}}],[\"这个示例中\",{\"1\":{\"229\":1}}],[\"这个示例使用\",{\"1\":{\"207\":1}}],[\"这个示例展示了以下几点\",{\"1\":{\"128\":1}}],[\"这个\",{\"1\":{\"199\":1,\"223\":1}}],[\"这个例子展示了如何使用\",{\"1\":{\"181\":1}}],[\"这个例子创建了一个可以传递\",{\"1\":{\"174\":1}}],[\"这个值同样也是存储在内存中\",{\"1\":{\"144\":1}}],[\"这个函数可以接受任何类型的切片作为参数\",{\"1\":{\"105\":1}}],[\"这个传进来的数据类型的变量\",{\"1\":{\"104\":1}}],[\"这个案例中大体上和函数基本类似\",{\"1\":{\"101\":1}}],[\"这大大增强了go语言的灵活性和可重用性\",{\"1\":{\"103\":1}}],[\"这也是因为\",{\"1\":{\"101\":1}}],[\"这定义了方法的接收者为\",{\"1\":{\"101\":1}}],[\"这和\",{\"1\":{\"93\":1}}],[\"这时候可能需要将多个错误链接在一起\",{\"1\":{\"89\":1}}],[\"这样通道可以在不阻塞发送\",{\"1\":{\"205\":1}}],[\"这样是错误的\",{\"1\":{\"163\":1}}],[\"这样是可以实现\",{\"1\":{\"104\":1}}],[\"这样优化后的结构体的总大小可能会减小\",{\"1\":{\"156\":1}}],[\"这样就可以创建不同类型的列表\",{\"1\":{\"106\":1}}],[\"这样就创建了一个包含更多上下文信息的错误\",{\"1\":{\"89\":1}}],[\"这样就创建了一个简单的错误\",{\"1\":{\"87\":1}}],[\"这样定义后\",{\"1\":{\"33\":1}}],[\"这意味着当没有数据可发送或接收时\",{\"1\":{\"173\":1}}],[\"这意味着在使用切片和映射时\",{\"1\":{\"160\":1}}],[\"这意味着在函数内部对数组的修改不会影响外部的原始数组\",{\"1\":{\"70\":1}}],[\"这意味着\",{\"1\":{\"85\":1}}],[\"这并不会创建一个新的数组\",{\"1\":{\"62\":1}}],[\"这使得它非常适合作为信号或占位符使用\",{\"1\":{\"155\":1}}],[\"这使得错误处理变得非常简洁和统一\",{\"1\":{\"84\":1}}],[\"这使得go语言在系统级编程和文件处理方面非常强大和灵活\",{\"1\":{\"47\":1}}],[\"这使得编写命令行工具或者控制台程序时\",{\"1\":{\"34\":1}}],[\"这种情况下\",{\"1\":{\"167\":1}}],[\"这种设计有助于减少访问内存时的性能开销\",{\"1\":{\"156\":1}}],[\"这种面向对象的语言不同\",{\"1\":{\"149\":1}}],[\"这种方式确保了发送和接收的同步\",{\"1\":{\"177\":1}}],[\"这种方式比使用其他占位符\",{\"1\":{\"155\":1}}],[\"这种方式可以创建更加具体的接口\",{\"1\":{\"117\":1}}],[\"这种方法应谨慎使用\",{\"1\":{\"142\":1}}],[\"这种特性使得接口在\",{\"1\":{\"111\":1}}],[\"这种约定适用于\",{\"1\":{\"102\":1}}],[\"这种默认声明方式\",{\"1\":{\"66\":1}}],[\"这种形式的命令行参数外\",{\"1\":{\"32\":1}}],[\"这种数据结构在需要循环遍历或轮转操作的场景中非常有用\",{\"1\":{\"28\":1}}],[\"这种数据结构在循环遍历和轮转操作中非常有用\",{\"1\":{\"27\":1}}],[\"这里为了简单\",{\"1\":{\"240\":1}}],[\"这里只能使用\",{\"1\":{\"149\":1}}],[\"这里要注意一个特殊情况\",{\"1\":{\"128\":1}}],[\"这里的零值并非等于\",{\"1\":{\"161\":1}}],[\"这里的\",{\"1\":{\"105\":1}}],[\"这里的容量指的是切片初始化时的容量\",{\"1\":{\"66\":1}}],[\"这里调用了\",{\"1\":{\"101\":1}}],[\"这里可以看做是在函数调用之前就初始化好了返回值变量\",{\"1\":{\"93\":1}}],[\"这里配置时\",{\"1\":{\"83\":1}}],[\"这里我推荐\",{\"1\":{\"81\":1}}],[\"这里不难看出\",{\"1\":{\"66\":1}}],[\"这里值得注意的是\",{\"1\":{\"61\":1}}],[\"这里\",{\"1\":{\"31\":1,\"113\":1}}],[\"这些并发模式提供了一种结构化的方法来编写并发程序\",{\"1\":{\"189\":1}}],[\"这些填充字节不存储任何有效数据\",{\"1\":{\"156\":1}}],[\"这些规则有助于编写清晰且按预期执行的表达式\",{\"1\":{\"136\":1}}],[\"这些类型的和呢\",{\"1\":{\"104\":1}}],[\"这些是\",{\"1\":{\"102\":1}}],[\"这些变量仍然可以被访问和操作\",{\"1\":{\"96\":1}}],[\"这些函数允许将当前的错误包装起来并添加上下文信息\",{\"1\":{\"89\":1}}],[\"这些功能非常有用\",{\"1\":{\"53\":1}}],[\"这些参数可以通过\",{\"1\":{\"32\":1}}],[\"这些数据结构对于高效地管理和操作数据非常有用\",{\"1\":{\"21\":1}}],[\"这些模块被广泛使用\",{\"1\":{\"20\":1}}],[\"形成一个闭环\",{\"1\":{\"27\":1}}],[\"其字段是存储在结构体内存中的值\",{\"1\":{\"160\":1}}],[\"其底层结构包含一个指向数组的指针\",{\"1\":{\"160\":1}}],[\"其元素是存储在数组内存中的值\",{\"1\":{\"160\":1}}],[\"其错误消息为\",{\"1\":{\"87\":1}}],[\"其本身也可作为数组的数据类型\",{\"1\":{\"63\":1}}],[\"其他常见标签\",{\"0\":{\"154\":1}}],[\"其他常用功能\",{\"0\":{\"47\":1,\"56\":1}}],[\"其他常用模块\",{\"0\":{\"18\":1}}],[\"其他运算符\",{\"0\":{\"135\":1}}],[\"其他可比较类型的键\",{\"1\":{\"128\":1}}],[\"其他操作都没有操作到底层数组\",{\"1\":{\"68\":1}}],[\"其他排序函数\",{\"0\":{\"52\":1}}],[\"其中最后一个元素指向第一个元素\",{\"1\":{\"27\":1}}],[\"环境检查\",{\"1\":{\"80\":1}}],[\"环境\",{\"1\":{\"79\":1}}],[\"环境配置\",{\"0\":{\"79\":1}}],[\"环境变量以及进程等操作系统相关的资源和信息\",{\"1\":{\"47\":1}}],[\"环境变量\",{\"0\":{\"45\":1}}],[\"环境变量管理\",{\"1\":{\"43\":1}}],[\"环境变量获取等\",{\"1\":{\"13\":1}}],[\"环形链表是一种特殊的链表\",{\"1\":{\"27\":1}}],[\"环形链表\",{\"0\":{\"27\":1}}],[\"500\",{\"1\":{\"185\":1,\"189\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1}}],[\"50\",{\"1\":{\"101\":1}}],[\"5432\",{\"1\":{\"45\":1}}],[\"5\",{\"0\":{\"27\":1,\"40\":1,\"96\":1,\"118\":1,\"183\":1,\"188\":1,\"239\":1},\"1\":{\"49\":6,\"61\":3,\"62\":2,\"67\":12,\"68\":9,\"70\":3,\"71\":1,\"72\":7,\"92\":1,\"96\":1,\"97\":1,\"98\":2,\"101\":1,\"107\":2,\"109\":1,\"121\":5,\"123\":1,\"131\":1,\"133\":1,\"134\":1,\"136\":2,\"141\":3,\"142\":2,\"180\":1,\"184\":1,\"185\":1,\"187\":1,\"188\":1,\"189\":1,\"206\":1,\"207\":1,\"237\":1,\"239\":1}}],[\"通信复杂\",{\"1\":{\"209\":1}}],[\"通信\",{\"1\":{\"182\":1}}],[\"通信顺序\",{\"1\":{\"173\":1}}],[\"通知等待的\",{\"1\":{\"236\":1}}],[\"通知\",{\"1\":{\"155\":1}}],[\"通道关闭\",{\"1\":{\"232\":1}}],[\"通道传递规则\",{\"1\":{\"223\":1}}],[\"通道是\",{\"1\":{\"182\":1,\"202\":1,\"222\":1}}],[\"通道已关闭\",{\"1\":{\"179\":1}}],[\"通道使用\",{\"1\":{\"175\":1}}],[\"通道可以防止多个协程访问共享内存时发生资源争抢的问题\",{\"1\":{\"199\":1}}],[\"通道可以被显式关闭\",{\"1\":{\"179\":1}}],[\"通道可以使用\",{\"1\":{\"174\":1}}],[\"通道可以是有限容量的\",{\"1\":{\"173\":1}}],[\"通道的任务\",{\"1\":{\"186\":1}}],[\"通道的使用场景\",{\"0\":{\"182\":1}}],[\"通道的创建\",{\"0\":{\"174\":1}}],[\"通道的消息\",{\"1\":{\"123\":1}}],[\"通道保证发送和接收操作的顺序是一致的\",{\"1\":{\"173\":1}}],[\"通道本质上是并发安全的\",{\"1\":{\"173\":1}}],[\"通道提供了一种安全\",{\"1\":{\"172\":1}}],[\"通道\",{\"0\":{\"172\":1,\"222\":1},\"1\":{\"166\":1,\"170\":1,\"172\":1,\"184\":1,\"186\":1,\"214\":1}}],[\"通道和数据流\",{\"1\":{\"10\":1}}],[\"通道和流\",{\"1\":{\"10\":1}}],[\"通道和流的处理\",{\"1\":{\"5\":1}}],[\"通常在等待某个操作完成时使用\",{\"1\":{\"238\":1}}],[\"通常在程序的主函数\",{\"1\":{\"192\":1}}],[\"通常需要确保主程序等待所有\",{\"1\":{\"207\":1}}],[\"通常用于暂时替代位置\",{\"1\":{\"192\":1}}],[\"通常是更新变量的语句\",{\"1\":{\"121\":1}}],[\"通常是变量声明或赋值\",{\"1\":{\"121\":1}}],[\"通常使用\",{\"1\":{\"88\":1}}],[\"通常\",{\"1\":{\"86\":1}}],[\"通常存储在保存\",{\"1\":{\"67\":1}}],[\"通过合理使用这些原语\",{\"1\":{\"240\":1}}],[\"通过合理使用这些模式\",{\"1\":{\"189\":1}}],[\"通过信号量控制并发数\",{\"1\":{\"237\":1}}],[\"通过灵活运用\",{\"1\":{\"233\":1}}],[\"通过正确地使用\",{\"1\":{\"198\":1}}],[\"通过理解和应用这些技术\",{\"1\":{\"171\":1}}],[\"通过使用同步原语如互斥锁\",{\"1\":{\"224\":1}}],[\"通过使用互斥锁\",{\"1\":{\"168\":1}}],[\"通过使用结构体标签\",{\"1\":{\"154\":1}}],[\"通过变量名来访问变量的值\",{\"1\":{\"161\":1}}],[\"通过变量来访问数据\",{\"1\":{\"161\":1}}],[\"通过指针引用底层哈希表\",{\"1\":{\"160\":1}}],[\"通过指针引用底层数组\",{\"1\":{\"160\":1}}],[\"通过这个地址可以间接访问对应的变量\",{\"1\":{\"137\":1}}],[\"通过选择和处理多个通道中的消息\",{\"1\":{\"123\":1}}],[\"通过接口\",{\"1\":{\"117\":1}}],[\"通过泛型\",{\"1\":{\"110\":1}}],[\"通过首字母大小写\",{\"1\":{\"102\":1}}],[\"通过返回值和内置的\",{\"1\":{\"100\":1}}],[\"通过切片的底层结构不难看出\",{\"1\":{\"68\":1}}],[\"通过索引来访问切片\",{\"1\":{\"67\":1}}],[\"通过学习和使用\",{\"1\":{\"47\":1}}],[\"通过掌握这些基本的函数和格式化占位符\",{\"1\":{\"42\":1}}],[\"通过实现\",{\"1\":{\"39\":1,\"50\":1}}],[\"通过命令行运行程序时\",{\"1\":{\"30\":1}}],[\"通过\",{\"1\":{\"26\":1,\"28\":1,\"52\":2,\"76\":2,\"140\":1,\"214\":1}}],[\"并通知等待的\",{\"1\":{\"236\":1}}],[\"并行计算等\",{\"1\":{\"210\":1}}],[\"并使用\",{\"1\":{\"152\":1}}],[\"并不是一个可比较的值\",{\"1\":{\"128\":1}}],[\"并不会对方法外面的值进行改变\",{\"1\":{\"101\":1}}],[\"并不会对原值产生影响\",{\"1\":{\"68\":1}}],[\"并不会开辟内存\",{\"1\":{\"66\":1}}],[\"并打印出第一个准备好的消息\",{\"1\":{\"123\":1}}],[\"并根据\",{\"1\":{\"120\":1}}],[\"并没有达到成倍的效果\",{\"1\":{\"101\":1}}],[\"并发执行\",{\"1\":{\"210\":1}}],[\"并发模式是指在并发编程中常用的设计模式和方法\",{\"1\":{\"183\":1}}],[\"并发模式\",{\"0\":{\"183\":1}}],[\"并发访问共享资源时程序的正确性和一致性\",{\"1\":{\"171\":1}}],[\"并发访问和修改\",{\"1\":{\"167\":1}}],[\"并发访问和修改共享资源时\",{\"1\":{\"167\":1}}],[\"并发写入共享变量而没有适当同步时\",{\"1\":{\"167\":1}}],[\"并发安全性\",{\"1\":{\"173\":1}}],[\"并发安全指的是程序在并发环境中运行时\",{\"1\":{\"165\":1}}],[\"并发安全和竞态条件\",{\"0\":{\"164\":1}}],[\"并发安全\",{\"0\":{\"127\":1,\"165\":1},\"1\":{\"164\":1,\"171\":1}}],[\"并发性\",{\"1\":{\"76\":1}}],[\"并发编程\",{\"0\":{\"15\":1,\"225\":1}}],[\"并且判断键是否存在\",{\"1\":{\"126\":1}}],[\"并且存在\",{\"1\":{\"123\":1}}],[\"并且该接口是导出的\",{\"1\":{\"102\":1}}],[\"并且可以赋值给变量或作为参数传递\",{\"1\":{\"95\":1}}],[\"并且结果值可能是一个默认值或者无效值\",{\"1\":{\"86\":1}}],[\"并且长度在整个生命周期中都是不可变的\",{\"1\":{\"70\":1}}],[\"并且为自定义集合提供了接口\",{\"1\":{\"48\":1}}],[\"并能够处理简单的输入操作和错误信息的格式化输出\",{\"1\":{\"42\":1}}],[\"并将结果传递到下一个步骤的\",{\"1\":{\"187\":1}}],[\"并将其赋值给相应的变量\",{\"1\":{\"30\":1}}],[\"并将它们赋值给相应的变量\",{\"1\":{\"30\":1}}],[\"并对每个节点执行指定的函数\",{\"1\":{\"28\":1}}],[\"并再次遍历链表来验证删除操作的效果\",{\"1\":{\"26\":1}}],[\"我们定义了\",{\"1\":{\"52\":1}}],[\"我们对环形链表进行一次轮转操作\",{\"1\":{\"28\":1}}],[\"我们使用\",{\"1\":{\"28\":1}}],[\"我们首先创建了一个包含三个元素的环形链表\",{\"1\":{\"28\":1}}],[\"我们首先创建了一个双向链表\",{\"1\":{\"26\":1}}],[\"我们演示了如何从链表中移除一个元素\",{\"1\":{\"26\":1}}],[\"我们展示了如何从头部和尾部插入元素\",{\"1\":{\"26\":1}}],[\"从多个通道接收数据\",{\"0\":{\"229\":1}}],[\"从该通道接收到这个值\",{\"1\":{\"223\":1}}],[\"从通道接收数据\",{\"1\":{\"175\":1,\"204\":1}}],[\"从高到低排列\",{\"1\":{\"136\":1}}],[\"从而避免数据竞争和不一致性\",{\"1\":{\"235\":1}}],[\"从而避免竞态条件\",{\"1\":{\"168\":1}}],[\"从而可以在单个\",{\"1\":{\"185\":1}}],[\"从而控制\",{\"1\":{\"160\":1}}],[\"从而达到节约内存的作用\",{\"1\":{\"158\":1}}],[\"从而达到流程控制的作用\",{\"1\":{\"123\":1}}],[\"从而提高系统整体的性能\",{\"1\":{\"156\":1}}],[\"从而提高处理器访问内存的效率\",{\"1\":{\"156\":1}}],[\"从而访问指定的数据\",{\"1\":{\"142\":1}}],[\"从而实现需求\",{\"1\":{\"136\":1}}],[\"从而实现对没有权限的数据的访问\",{\"1\":{\"102\":1}}],[\"从而实现了原值的修改\",{\"1\":{\"101\":1}}],[\"从而实现类似子数组的效果\",{\"1\":{\"62\":1}}],[\"从切片的起始位置到底层数组的结尾的元素个数\",{\"1\":{\"68\":1}}],[\"从中间指定下标删除\",{\"1\":{\"67\":1}}],[\"从链表中移除指定的元素\",{\"1\":{\"26\":1}}],[\"从头到尾访问每个元素\",{\"1\":{\"26\":1}}],[\"获取信号量\",{\"1\":{\"237\":1}}],[\"获取变量的地址需要使用\",{\"1\":{\"139\":1}}],[\"获取变量地址\",{\"0\":{\"139\":1}}],[\"获取map长度\",{\"1\":{\"126\":1}}],[\"获取对应键的值\",{\"1\":{\"126\":1}}],[\"获取当前工作目录\",{\"1\":{\"47\":2}}],[\"获取当前进程id和父进程id\",{\"1\":{\"46\":1}}],[\"获取当前进程的父进程id\",{\"1\":{\"46\":1}}],[\"获取当前进程的id\",{\"1\":{\"46\":1}}],[\"获取主机名\",{\"1\":{\"47\":2}}],[\"获取环境变量\",{\"1\":{\"45\":1}}],[\"获取环境变量的值\",{\"1\":{\"45\":1}}],[\"获取非命令行参数\",{\"1\":{\"32\":1}}],[\"获取下一个节点\",{\"1\":{\"26\":1}}],[\"获取链表的最后一个元素\",{\"1\":{\"26\":1}}],[\"获取链表的第一个元素\",{\"1\":{\"26\":1}}],[\"解锁\",{\"1\":{\"223\":1,\"236\":2}}],[\"解决竞态条件\",{\"0\":{\"168\":1},\"1\":{\"171\":1}}],[\"解决方案\",{\"1\":{\"128\":1}}],[\"解决软件工程中的常见问题\",{\"1\":{\"75\":1}}],[\"解析为\",{\"1\":{\"101\":1}}],[\"解析和使用命令行参数\",{\"1\":{\"34\":1}}],[\"解析命令行参数\",{\"0\":{\"30\":1},\"1\":{\"30\":1,\"32\":1}}],[\"解析以及定时器的使用\",{\"1\":{\"18\":1}}],[\"解释示例代码\",{\"0\":{\"26\":1,\"28\":1}}],[\"删除所有元素\",{\"1\":{\"67\":1}}],[\"删除前\",{\"1\":{\"67\":1}}],[\"删除后\",{\"1\":{\"67\":1}}],[\"删除\",{\"1\":{\"67\":1,\"126\":1}}],[\"删除指定的环境变量\",{\"1\":{\"45\":1}}],[\"删除文件\",{\"1\":{\"44\":1}}],[\"删除一个文件\",{\"1\":{\"44\":1}}],[\"删除或者遍历操作的场景\",{\"1\":{\"26\":1}}],[\"删除操作\",{\"1\":{\"26\":1}}],[\"删除链表中的一个元素\",{\"1\":{\"25\":1}}],[\"删除和遍历操作\",{\"1\":{\"25\":1}}],[\"遍历时的顺序不一定与插入顺序相同\",{\"1\":{\"126\":1}}],[\"遍历\",{\"1\":{\"124\":1,\"126\":1,\"127\":1}}],[\"遍历输出这个数组\",{\"1\":{\"61\":1}}],[\"遍历环形链表的所有节点\",{\"1\":{\"28\":1}}],[\"遍历环形链表\",{\"1\":{\"28\":1}}],[\"遍历链表\",{\"1\":{\"26\":1}}],[\"遍历链表并打印元素\",{\"1\":{\"25\":1}}],[\"遍历队列\",{\"1\":{\"23\":1}}],[\"演示了如何使用\",{\"1\":{\"25\":1,\"27\":1}}],[\"链表\",{\"0\":{\"25\":1}}],[\"43\",{\"1\":{\"178\":1}}],[\"4b\",{\"1\":{\"160\":1}}],[\"404\",{\"1\":{\"242\":1}}],[\"40\",{\"1\":{\"149\":1}}],[\"42\",{\"1\":{\"55\":2,\"115\":1,\"175\":1,\"177\":1,\"178\":1,\"204\":1,\"223\":2,\"230\":1}}],[\"4\",{\"0\":{\"25\":1,\"33\":1,\"39\":1,\"52\":1,\"95\":1,\"129\":1,\"187\":1,\"234\":1,\"238\":1},\"1\":{\"49\":2,\"61\":2,\"62\":3,\"67\":11,\"68\":9,\"70\":1,\"71\":1,\"72\":5,\"94\":1,\"95\":1,\"109\":1,\"114\":1,\"121\":2,\"122\":1,\"123\":1,\"142\":1,\"156\":7,\"187\":1}}],[\">>=\",{\"1\":{\"134\":1,\"136\":1}}],[\">>\",{\"1\":{\"133\":2,\"136\":1}}],[\">=\",{\"1\":{\"131\":2,\"136\":1}}],[\">\",{\"1\":{\"24\":1,\"107\":1,\"120\":1,\"121\":1,\"131\":1,\"136\":1}}],[\"弹出最小元素\",{\"1\":{\"24\":1}}],[\"j++\",{\"1\":{\"184\":1,\"186\":1,\"189\":1}}],[\"job\",{\"1\":{\"184\":2,\"186\":1,\"189\":2}}],[\"jobs\",{\"1\":{\"184\":7,\"186\":8,\"189\":8}}],[\"java\",{\"1\":{\"90\":1,\"93\":1,\"101\":3,\"115\":1,\"120\":1,\"149\":1}}],[\"jetbrains\",{\"1\":{\"83\":1}}],[\"j\",{\"1\":{\"24\":7,\"50\":7,\"52\":5,\"135\":1,\"141\":3,\"160\":2,\"163\":2,\"184\":7,\"186\":5,\"189\":6}}],[\"jsonstr\",{\"1\":{\"152\":2}}],[\"jsondata\",{\"1\":{\"152\":2}}],[\"json序列化\",{\"1\":{\"152\":1}}],[\"json\",{\"1\":{\"17\":2,\"152\":8,\"153\":6,\"154\":1}}],[\"实际操作的是底层数据的地址\",{\"1\":{\"160\":1}}],[\"实际上就是这样\",{\"1\":{\"162\":1}}],[\"实际上变量的定义来源于数学\",{\"1\":{\"161\":1}}],[\"实际上是结构体指针\",{\"1\":{\"150\":1}}],[\"实际上的实现逻辑都是相同的\",{\"1\":{\"104\":1}}],[\"实际上这里只是重新定义了切片的范围\",{\"1\":{\"68\":1}}],[\"实际上这里是分两个步骤\",{\"1\":{\"61\":1}}],[\"实际上切片不存储数据\",{\"1\":{\"68\":1}}],[\"实际上此时的\",{\"1\":{\"66\":1}}],[\"实数和虚数类型\",{\"1\":{\"159\":1}}],[\"实例\",{\"1\":{\"125\":1}}],[\"实现超时机制\",{\"0\":{\"230\":1}}],[\"实现不断地监听多个通道的消息\",{\"1\":{\"123\":1}}],[\"实现\",{\"1\":{\"24\":1,\"127\":1}}],[\"实用工具\",{\"0\":{\"19\":1}}],[\"在实际使用中\",{\"1\":{\"240\":1}}],[\"在实际的开发中\",{\"1\":{\"102\":1}}],[\"在操作\",{\"1\":{\"214\":2}}],[\"在单个\",{\"1\":{\"214\":1}}],[\"在函数调用前加上\",{\"1\":{\"199\":1}}],[\"在函数内部对切片的修改会影响外部的原始切片\",{\"1\":{\"71\":1}}],[\"在上下文中添加值\",{\"1\":{\"197\":1}}],[\"在上述例子中\",{\"1\":{\"30\":1}}],[\"在上述示例中\",{\"1\":{\"26\":1}}],[\"在并发任务之间进行协调\",{\"1\":{\"182\":1}}],[\"在并发编程中\",{\"1\":{\"164\":1,\"213\":1}}],[\"在第一次使用\",{\"1\":{\"163\":1}}],[\"在计算机中\",{\"1\":{\"161\":1}}],[\"在编译后会自动进行解引用\",{\"1\":{\"150\":1}}],[\"在编写需要处理用户输入\",{\"1\":{\"57\":1}}],[\"在某些应用场景下非常实用\",{\"1\":{\"137\":1}}],[\"在获取\",{\"1\":{\"126\":1}}],[\"在所有这些情况下\",{\"1\":{\"122\":1}}],[\"在这个例子中\",{\"1\":{\"120\":1,\"150\":1,\"180\":1,\"206\":1}}],[\"在这个示例中\",{\"1\":{\"52\":1,\"123\":1,\"167\":1,\"170\":1,\"223\":1,\"230\":1,\"231\":1}}],[\"在正式了解泛型之前先看一个经常在开发中遇到的问题\",{\"1\":{\"104\":1}}],[\"在前面\",{\"1\":{\"101\":1}}],[\"在方法内修改形参的值\",{\"1\":{\"101\":1}}],[\"在方法被调用时\",{\"1\":{\"101\":1}}],[\"在错误链上包装更多信息\",{\"1\":{\"89\":1}}],[\"在调用这个函数后\",{\"1\":{\"86\":1}}],[\"在go中创建自定义错误通常很简单\",{\"1\":{\"87\":1}}],[\"在go中\",{\"1\":{\"85\":1,\"88\":1}}],[\"在go语言中是合法的\",{\"1\":{\"136\":1}}],[\"在go语言中\",{\"1\":{\"29\":1,\"43\":1,\"84\":1,\"115\":1,\"122\":1,\"172\":1}}],[\"在go语言标准库中\",{\"1\":{\"21\":1}}],[\"在多个领域得到了广泛应用\",{\"1\":{\"77\":1}}],[\"在声明结构体内部的字段时\",{\"1\":{\"148\":1}}],[\"在声明数组后\",{\"1\":{\"61\":1}}],[\"在声明阶段就需要指定数组长度和数组的数据类型\",{\"1\":{\"60\":1}}],[\"在已排序的集合中搜索元素\",{\"1\":{\"52\":1}}],[\"在\",{\"1\":{\"35\":1,\"37\":1,\"48\":1,\"53\":1,\"58\":1,\"66\":1,\"67\":1,\"69\":1,\"90\":1,\"101\":2,\"111\":1,\"113\":1,\"123\":1,\"124\":1,\"128\":1,\"137\":1,\"138\":1,\"142\":2,\"147\":1,\"152\":1,\"155\":1,\"156\":1,\"160\":4,\"161\":1,\"182\":1,\"190\":1,\"198\":1,\"202\":1,\"207\":1,\"226\":1}}],[\"在使用上\",{\"1\":{\"58\":1}}],[\"在使用\",{\"1\":{\"31\":1,\"56\":1,\"155\":1}}],[\"在示例中\",{\"1\":{\"28\":1}}],[\"在环形链表中轮转一次\",{\"1\":{\"27\":1}}],[\"在链表头部添加元素\",{\"1\":{\"25\":1}}],[\"在链表尾部添加元素\",{\"1\":{\"25\":1}}],[\"在堆中的索引\",{\"1\":{\"24\":1}}],[\"值结构体不能\",{\"1\":{\"151\":1}}],[\"值的类型\",{\"1\":{\"126\":1}}],[\"值接收者\",{\"1\":{\"101\":2}}],[\"值传递的数据结构\",{\"1\":{\"73\":1}}],[\"值传递\",{\"1\":{\"70\":1}}],[\"值\",{\"1\":{\"24\":1,\"160\":1}}],[\"但在写入时独占资源\",{\"1\":{\"235\":1}}],[\"但在go语言中广泛用于处理列表和集合数据\",{\"1\":{\"22\":1}}],[\"但之后会立即返回零值\",{\"1\":{\"232\":1}}],[\"但也因此带来了同步问题\",{\"1\":{\"210\":1}}],[\"但用于通道通信\",{\"1\":{\"181\":1}}],[\"但用于通信操作\",{\"1\":{\"123\":1}}],[\"但接收操作会继续接收已存在的数据\",{\"1\":{\"179\":1}}],[\"但仍可以接收已有数据\",{\"1\":{\"173\":1}}],[\"但仍然共享相同的底层数组\",{\"1\":{\"71\":1}}],[\"但写操作是互斥的\",{\"1\":{\"166\":1,\"220\":1}}],[\"但直接操作内存地址\",{\"1\":{\"161\":1}}],[\"但结构体可以包含指针字段\",{\"1\":{\"160\":1}}],[\"但本质上仍是变量\",{\"1\":{\"158\":1}}],[\"但这也就意味着\",{\"1\":{\"142\":1}}],[\"但可以根据需要动态扩展\",{\"1\":{\"201\":1}}],[\"但可以指定具体的时间点\",{\"1\":{\"196\":1}}],[\"但可以通过\",{\"1\":{\"121\":1,\"239\":1}}],[\"但可以使用\",{\"1\":{\"121\":1}}],[\"但如果字段实现了某个接口的方法\",{\"1\":{\"102\":1}}],[\"但需要注意同步问题\",{\"1\":{\"211\":1}}],[\"但需要注意的是\",{\"1\":{\"62\":1}}],[\"但需要明确出退出条件\",{\"1\":{\"97\":1}}],[\"但它加入了并发编程和垃圾回收等现代特性\",{\"1\":{\"75\":1}}],[\"但长度固定\",{\"1\":{\"70\":1}}],[\"但指向的是同一个地址\",{\"1\":{\"68\":1}}],[\"但是在访问结构体时没有进行解引用就可直接访问结构体内容\",{\"1\":{\"150\":1}}],[\"但是在前面说过\",{\"1\":{\"66\":1}}],[\"但是实际上是禁止了大部分指针运算的\",{\"1\":{\"142\":1}}],[\"但是实际的输出是\",{\"1\":{\"101\":1}}],[\"但是不难发现\",{\"1\":{\"104\":1}}],[\"但是可以在这些方法的内部实现中访问包中的函数\",{\"1\":{\"101\":1}}],[\"但是\",{\"1\":{\"101\":1}}],[\"但是由于指针的副本同样指向的是该结构体实例\",{\"1\":{\"151\":1}}],[\"但是由于操作指针的风险较大\",{\"1\":{\"137\":1}}],[\"但是由于两个指针所指向的是同一个地址\",{\"1\":{\"101\":1}}],[\"但是由于切片的元素个数和容量是值传递\",{\"1\":{\"68\":1}}],[\"但是当增加切片的长度时\",{\"1\":{\"68\":1}}],[\"但是长度和容量这两个有什么区别呢\",{\"1\":{\"66\":1}}],[\"但是数据列表的长度不能超过数组的长度\",{\"1\":{\"61\":1}}],[\"但不知道数据量的数据\",{\"1\":{\"64\":1}}],[\"但实际在功能上差距较大\",{\"1\":{\"58\":1}}],[\"但没有直接提供堆的实现\",{\"1\":{\"24\":1}}],[\"堆是一种优先队列\",{\"1\":{\"24\":1}}],[\"堆\",{\"0\":{\"24\":1}}],[\"35\",{\"1\":{\"149\":1}}],[\"32\",{\"1\":{\"56\":1,\"160\":1}}],[\"30\",{\"1\":{\"30\":1,\"36\":2,\"39\":2,\"50\":1,\"52\":1,\"125\":1,\"127\":1,\"130\":1,\"149\":1,\"152\":2}}],[\"3\",{\"0\":{\"24\":1,\"32\":1,\"38\":1,\"51\":1,\"56\":1,\"94\":1,\"157\":1,\"186\":1,\"226\":1,\"231\":1,\"237\":1},\"1\":{\"24\":2,\"27\":2,\"49\":4,\"54\":2,\"55\":2,\"61\":6,\"62\":7,\"66\":2,\"67\":16,\"68\":8,\"70\":1,\"71\":1,\"72\":5,\"92\":1,\"93\":2,\"94\":1,\"95\":1,\"98\":1,\"105\":1,\"107\":1,\"108\":1,\"109\":3,\"114\":1,\"121\":1,\"122\":3,\"123\":1,\"130\":2,\"133\":1,\"142\":1,\"156\":3,\"160\":4,\"184\":1,\"186\":1,\"187\":1,\"188\":1,\"195\":1,\"196\":1,\"197\":1,\"237\":1}}],[\"输入\",{\"0\":{\"38\":1}}],[\"输入输出工具\",{\"1\":{\"16\":1}}],[\"输出可能是\",{\"1\":{\"156\":1}}],[\"输出集合中的元素\",{\"1\":{\"155\":1}}],[\"输出的仍然是上述结果\",{\"1\":{\"101\":1}}],[\"输出变量类型\",{\"1\":{\"37\":1}}],[\"输出参数并添加换行符\",{\"1\":{\"36\":1}}],[\"输出参数\",{\"1\":{\"36\":1}}],[\"输出解析后的参数\",{\"1\":{\"30\":1}}],[\"输出\",{\"1\":{\"23\":1,\"24\":1,\"36\":3,\"37\":2,\"39\":1,\"49\":1,\"54\":2,\"55\":2,\"56\":2,\"61\":1,\"62\":8,\"67\":13,\"68\":6,\"72\":4,\"101\":6,\"106\":2,\"107\":2,\"108\":1,\"109\":2,\"128\":1,\"140\":2,\"141\":2,\"150\":6,\"151\":4,\"152\":2,\"155\":1}}],[\"出队操作\",{\"1\":{\"23\":1}}],[\"bson\",{\"1\":{\"154\":3}}],[\"before\",{\"0\":{\"216\":1},\"1\":{\"216\":2,\"223\":4,\"224\":1}}],[\"be\",{\"1\":{\"152\":1}}],[\"beego\",{\"1\":{\"77\":1}}],[\"break\",{\"1\":{\"120\":2,\"121\":1}}],[\"b\",{\"1\":{\"92\":3,\"95\":2,\"98\":2,\"104\":4,\"105\":1,\"106\":1,\"107\":5,\"122\":1,\"130\":6,\"131\":5,\"133\":4,\"134\":3,\"136\":5,\"156\":15,\"160\":3,\"214\":2}}],[\"bytes\",{\"1\":{\"156\":10}}],[\"byte\",{\"1\":{\"67\":2,\"117\":1,\"152\":1,\"156\":3}}],[\"byname\",{\"1\":{\"52\":7}}],[\"by\",{\"1\":{\"50\":1,\"52\":1,\"100\":1}}],[\"byage\",{\"1\":{\"50\":5}}],[\"banana\",{\"1\":{\"155\":1}}],[\"base\",{\"1\":{\"56\":2}}],[\"background\",{\"1\":{\"192\":2,\"193\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":2}}],[\"back\",{\"1\":{\"25\":1,\"26\":1}}],[\"baz\",{\"1\":{\"24\":2}}],[\"barriers\",{\"0\":{\"239\":1}}],[\"bar\",{\"1\":{\"24\":2}}],[\"bool\",{\"1\":{\"24\":1,\"50\":1,\"52\":1,\"127\":1,\"128\":1,\"155\":1,\"156\":4,\"159\":1,\"222\":2,\"238\":2}}],[\"bob\",{\"1\":{\"23\":1,\"25\":1,\"37\":2,\"50\":1,\"52\":1,\"125\":1,\"126\":3,\"127\":1,\"149\":1,\"152\":2}}],[\"bufio\",{\"1\":{\"19\":3}}],[\"入队操作\",{\"1\":{\"23\":1}}],[\"创建带缓冲的通道\",{\"1\":{\"205\":1}}],[\"创建通道\",{\"0\":{\"203\":1},\"1\":{\"238\":1}}],[\"创建上下文\",{\"0\":{\"192\":1}}],[\"创建结构体实例\",{\"0\":{\"149\":1}}],[\"创建自定义错误\",{\"0\":{\"87\":1}}],[\"创建目录\",{\"1\":{\"44\":1}}],[\"创建文件\",{\"1\":{\"44\":1}}],[\"创建环形链表和初始化\",{\"1\":{\"28\":1}}],[\"创建一个带有超时的上下文\",{\"1\":{\"197\":1}}],[\"创建一个可以取消的上下文\",{\"1\":{\"194\":1}}],[\"创建一个空结构体的\",{\"1\":{\"155\":1}}],[\"创建一个目录\",{\"1\":{\"44\":1}}],[\"创建一个文件\",{\"1\":{\"44\":1}}],[\"创建一个包含\",{\"1\":{\"28\":1}}],[\"创建一个环形链表\",{\"1\":{\"27\":1}}],[\"创建一个新的空链表\",{\"1\":{\"26\":1}}],[\"创建一个新的双向链表\",{\"1\":{\"25\":1}}],[\"创建一个新的链表\",{\"1\":{\"23\":1}}],[\"创建链表和插入操作\",{\"1\":{\"26\":1}}],[\"创建优先队列\",{\"1\":{\"24\":1}}],[\"创建和管理\",{\"1\":{\"10\":1}}],[\"双向链表实现的列表\",{\"1\":{\"23\":1}}],[\"队列\",{\"0\":{\"23\":1}}],[\"2kb\",{\"1\":{\"201\":1}}],[\"21\",{\"1\":{\"67\":1}}],[\"26\",{\"1\":{\"56\":1}}],[\"25\",{\"1\":{\"37\":2,\"50\":1,\"52\":1,\"125\":1,\"127\":1,\"149\":1,\"152\":2}}],[\"20\",{\"1\":{\"30\":1,\"31\":2,\"33\":1,\"50\":1,\"52\":1,\"101\":2,\"151\":3}}],[\"2\",{\"0\":{\"23\":1,\"31\":1,\"37\":1,\"50\":1,\"55\":1,\"79\":1,\"93\":1,\"172\":1,\"185\":1,\"230\":1,\"236\":1},\"1\":{\"24\":2,\"49\":2,\"61\":4,\"62\":8,\"66\":2,\"67\":15,\"68\":11,\"70\":1,\"71\":1,\"72\":5,\"92\":1,\"94\":1,\"96\":1,\"101\":2,\"105\":1,\"106\":1,\"108\":1,\"109\":3,\"113\":1,\"120\":3,\"121\":3,\"122\":3,\"123\":2,\"133\":1,\"142\":2,\"155\":1,\"160\":4,\"161\":2,\"178\":1,\"181\":3,\"184\":1,\"187\":2,\"188\":2,\"189\":2,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"223\":1,\"229\":3,\"230\":1}}],[\"22\",{\"1\":{\"8\":1,\"9\":2}}],[\"是并发编程中用于管理和协调多个线程或协程的基本构建块\",{\"1\":{\"234\":1}}],[\"是与其他函数同时运行的函数\",{\"1\":{\"199\":1}}],[\"是指程序的行为依赖于\",{\"1\":{\"171\":1}}],[\"是确保多个\",{\"1\":{\"171\":1}}],[\"是两个重要的概念\",{\"1\":{\"164\":1}}],[\"是直接访问内存中的数据\",{\"1\":{\"160\":1}}],[\"是否在\",{\"1\":{\"128\":1}}],[\"是否会修改原值\",{\"1\":{\"101\":1}}],[\"是引用类型\",{\"1\":{\"126\":1}}],[\"是\",{\"1\":{\"125\":1,\"156\":1,\"163\":2,\"199\":1}}],[\"是无序的\",{\"1\":{\"124\":1}}],[\"是值拷贝\",{\"1\":{\"101\":1}}],[\"是将\",{\"1\":{\"101\":1}}],[\"是一种数据类型\",{\"1\":{\"172\":1}}],[\"是一种内置的数据结构\",{\"1\":{\"124\":1}}],[\"是一种定义对象行为的方式\",{\"1\":{\"111\":1}}],[\"是一个关键概念\",{\"1\":{\"216\":1}}],[\"是一个\",{\"1\":{\"156\":1}}],[\"是一个没有任何字段的结构体\",{\"1\":{\"155\":1}}],[\"是一个非常有用的工具\",{\"1\":{\"123\":1}}],[\"是一个非常重要的概念\",{\"1\":{\"84\":1}}],[\"是一个预定义的接口\",{\"1\":{\"105\":1}}],[\"是一个类型参数\",{\"1\":{\"105\":1}}],[\"是一个用于\",{\"1\":{\"5\":1}}],[\"是一门值得学习和掌握的编程语言\",{\"1\":{\"78\":1}}],[\"是一门静态类型的编程语言\",{\"1\":{\"76\":1}}],[\"是由\",{\"1\":{\"75\":1}}],[\"是合法的\",{\"1\":{\"67\":1}}],[\"是go语言中常用的标准库之一\",{\"1\":{\"42\":1}}],[\"是go语言标准库中提供的双向链表的实现\",{\"1\":{\"25\":1}}],[\"是默认值\",{\"1\":{\"31\":1}}],[\"是命令行参数的名称\",{\"1\":{\"31\":1}}],[\"是非常常用和灵活的数据结构\",{\"1\":{\"22\":1}}],[\"切片本身包含了一个指向底层数组的指针\",{\"1\":{\"160\":1}}],[\"切片本身并没有提供直接删除元素的接口\",{\"1\":{\"67\":1}}],[\"切片类型\",{\"1\":{\"160\":1}}],[\"切片索引\",{\"1\":{\"135\":1}}],[\"切片是引用类型\",{\"1\":{\"160\":1}}],[\"切片是一个动态数组\",{\"1\":{\"160\":1}}],[\"切片是动态长度\",{\"1\":{\"73\":1}}],[\"切片是对数组的一层轻量级封装\",{\"1\":{\"71\":1}}],[\"切片是对数组的抽象\",{\"1\":{\"58\":1}}],[\"切片的长度\",{\"1\":{\"68\":2}}],[\"切片的值\",{\"1\":{\"68\":1}}],[\"切片的应用范围更加广泛\",{\"1\":{\"64\":1}}],[\"切片中的元素个数\",{\"1\":{\"68\":1}}],[\"切片不指定长度\",{\"1\":{\"66\":1}}],[\"切片初始化时的长度和容量\",{\"1\":{\"66\":1}}],[\"切片和数组的声明和初始化几乎类似\",{\"1\":{\"66\":1}}],[\"切片按照姓名进行排序\",{\"1\":{\"52\":1}}],[\"切片在作为函数参数传递时\",{\"1\":{\"71\":1}}],[\"切片在\",{\"1\":{\"22\":1}}],[\"切片\",{\"0\":{\"22\":1,\"64\":1},\"1\":{\"121\":1,\"122\":1,\"126\":1}}],[\"1gb\",{\"1\":{\"201\":1}}],[\"18\",{\"1\":{\"135\":1,\"149\":1,\"150\":5,\"151\":5,\"160\":1,\"161\":1,\"162\":1}}],[\"180\",{\"1\":{\"126\":1}}],[\"18版本引入了泛型\",{\"1\":{\"103\":1}}],[\"15\",{\"1\":{\"109\":1}}],[\"110\",{\"1\":{\"133\":1}}],[\"111\",{\"1\":{\"133\":1}}],[\"11\",{\"0\":{\"111\":1},\"1\":{\"98\":1}}],[\"12\",{\"0\":{\"103\":1},\"1\":{\"156\":1}}],[\"120\",{\"1\":{\"97\":1}}],[\"1234\",{\"1\":{\"197\":1}}],[\"123\",{\"1\":{\"54\":2}}],[\"13\",{\"0\":{\"84\":1},\"1\":{\"130\":1}}],[\"1010\",{\"1\":{\"133\":1}}],[\"101\",{\"1\":{\"133\":1}}],[\"1000\",{\"1\":{\"167\":1,\"168\":1,\"169\":1,\"170\":2,\"235\":2,\"240\":2}}],[\"100\",{\"1\":{\"72\":5,\"162\":1,\"205\":1}}],[\"10\",{\"0\":{\"124\":1},\"1\":{\"67\":2,\"68\":2,\"93\":1,\"94\":1,\"96\":1,\"100\":1,\"101\":12,\"121\":3,\"130\":1,\"131\":1,\"133\":2,\"134\":1,\"135\":1,\"139\":1,\"140\":2,\"144\":1,\"160\":4,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"185\":1,\"186\":2,\"189\":1,\"219\":1,\"220\":2,\"221\":1,\"237\":2}}],[\"16\",{\"1\":{\"56\":3,\"156\":3}}],[\"1a\",{\"1\":{\"56\":1}}],[\"140000\",{\"1\":{\"54\":1}}],[\"14\",{\"1\":{\"54\":1,\"55\":2}}],[\"1\",{\"0\":{\"22\":1,\"30\":1,\"36\":1,\"49\":1,\"54\":1,\"74\":1,\"92\":1,\"184\":1,\"199\":1,\"229\":1,\"235\":1},\"1\":{\"24\":5,\"27\":2,\"46\":1,\"49\":4,\"55\":1,\"61\":4,\"62\":5,\"66\":2,\"67\":14,\"68\":9,\"70\":1,\"71\":1,\"72\":2,\"93\":1,\"94\":1,\"97\":3,\"105\":1,\"106\":2,\"108\":1,\"109\":3,\"120\":3,\"121\":4,\"122\":2,\"123\":2,\"130\":1,\"133\":3,\"142\":1,\"156\":4,\"160\":4,\"161\":2,\"163\":1,\"167\":1,\"168\":1,\"169\":2,\"170\":2,\"181\":1,\"184\":3,\"185\":2,\"186\":3,\"187\":1,\"188\":2,\"189\":5,\"194\":1,\"207\":3,\"219\":1,\"220\":2,\"221\":2,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"239\":1,\"240\":1}}],[\"包的同步原语\",{\"1\":{\"214\":1}}],[\"包的原子操作和\",{\"1\":{\"214\":1}}],[\"包的一些基本介绍和常用功能\",{\"1\":{\"29\":1}}],[\"包主要用于在不同的\",{\"1\":{\"190\":1}}],[\"包含了字段和填充字节\",{\"1\":{\"156\":1}}],[\"包进行指针运算\",{\"1\":{\"142\":1}}],[\"包为单位\",{\"1\":{\"102\":1}}],[\"包来处理数据类型的转换和格式化\",{\"1\":{\"57\":1}}],[\"包来操作环形链表\",{\"1\":{\"27\":1}}],[\"包来操作双向链表\",{\"1\":{\"25\":1}}],[\"包内常用的api\",{\"1\":{\"35\":1}}],[\"包是处理字符串和基本数据类型之间转换的重要工具\",{\"1\":{\"57\":1}}],[\"包是一个非常重要且常用的标准库\",{\"1\":{\"43\":1}}],[\"包是非常重要的\",{\"1\":{\"35\":1}}],[\"包是用于处理命令行参数的标准库\",{\"1\":{\"29\":1}}],[\"包还支持解析非命令行参数\",{\"1\":{\"32\":1}}],[\"包可以轻松地解析命令行参数\",{\"1\":{\"30\":1}}],[\"包\",{\"1\":{\"26\":1,\"28\":1,\"47\":1,\"52\":1,\"142\":1}}],[\"包提供了一种简洁而强大的方式来管理并发程序中的请求范围数据\",{\"1\":{\"198\":1}}],[\"包提供了一种用于在\",{\"1\":{\"190\":1}}],[\"包提供了一个简单而强大的方法来处理命令行参数\",{\"1\":{\"34\":1}}],[\"包提供了一个基于双链表实现的队列\",{\"1\":{\"23\":1}}],[\"包提供了字符串和基本数据类型之间的转换函数\",{\"1\":{\"53\":1}}],[\"包提供了对切片和用户定义的集合进行排序的函数\",{\"1\":{\"48\":1}}],[\"包提供了丰富的工具来处理格式化的输入和输出\",{\"1\":{\"42\":1}}],[\"包提供了环形链表的实现\",{\"1\":{\"27\":1}}],[\"包提供了堆操作的接口\",{\"1\":{\"24\":1}}],[\"包提供了几种常用的数据结构实现\",{\"1\":{\"21\":1}}],[\"包中常用的函数和用法示例\",{\"1\":{\"53\":1}}],[\"包中常用的函数和接口\",{\"1\":{\"48\":1}}],[\"包中常用的功能和api\",{\"1\":{\"43\":1}}],[\"包中并不单独提供\",{\"1\":{\"22\":1}}],[\"包中主要的数据结构\",{\"1\":{\"21\":1}}],[\"包括它自己\",{\"1\":{\"128\":2}}],[\"包括变量\",{\"1\":{\"102\":1}}],[\"包括可选参数\",{\"1\":{\"34\":1}}],[\"包括时间的格式化\",{\"1\":{\"18\":1}}],[\"包括文件操作\",{\"1\":{\"16\":1,\"43\":1}}],[\"包括\",{\"1\":{\"14\":1,\"18\":1}}],[\"包括密码认证\",{\"1\":{\"10\":1}}],[\"包括认证\",{\"1\":{\"5\":1}}],[\"深入了解和熟练使用标准库可以极大地提升\",{\"1\":{\"20\":1}}],[\"覆盖了从基础操作到高级功能的多个领域\",{\"1\":{\"20\":1}}],[\"日志记录\",{\"1\":{\"19\":1}}],[\"性能优化\",{\"1\":{\"70\":1}}],[\"性能\",{\"1\":{\"19\":1}}],[\"提供一种无锁机制\",{\"1\":{\"166\":1}}],[\"提供的语法糖\",{\"1\":{\"150\":1}}],[\"提供了多种同步原语来确保内存操作的顺序性和可见性\",{\"1\":{\"218\":1}}],[\"提供了类型推导\",{\"1\":{\"161\":1}}],[\"提供了指针\",{\"1\":{\"137\":1}}],[\"提供了非常高效的查找\",{\"1\":{\"124\":1}}],[\"提供了丰富的标准库\",{\"1\":{\"76\":1}}],[\"提供了强大的并发处理能力\",{\"1\":{\"76\":1}}],[\"提供了基本的数学函数和常量\",{\"1\":{\"18\":1}}],[\"提供了基本的同步操作\",{\"1\":{\"15\":1}}],[\"提供了\",{\"1\":{\"16\":1}}],[\"提高代码的可读性和维护性\",{\"1\":{\"198\":1}}],[\"提高代码的可维护性和扩展性\",{\"1\":{\"189\":1}}],[\"提高\",{\"1\":{\"19\":1}}],[\"操作的场景中\",{\"1\":{\"212\":1}}],[\"操作的类型\",{\"1\":{\"126\":1}}],[\"操作会自动取消\",{\"1\":{\"195\":1}}],[\"操作符可以发送和接收数据\",{\"1\":{\"204\":1}}],[\"操作符进行数据的发送和接收\",{\"1\":{\"175\":1}}],[\"操作符为\",{\"1\":{\"160\":1}}],[\"操作符\",{\"1\":{\"140\":1,\"150\":1}}],[\"操作map\",{\"0\":{\"126\":1}}],[\"操作到了底层数组\",{\"1\":{\"68\":1}}],[\"操作\",{\"1\":{\"19\":1}}],[\"操作系统功能\",{\"1\":{\"13\":1}}],[\"缓冲\",{\"1\":{\"19\":1}}],[\"数值类型\",{\"1\":{\"159\":1}}],[\"数字平方\",{\"1\":{\"187\":1}}],[\"数字加倍\",{\"1\":{\"187\":1}}],[\"数字\",{\"1\":{\"126\":1}}],[\"数组元素直接存储在数组的内存块中\",{\"1\":{\"160\":1}}],[\"数组类型\",{\"1\":{\"160\":1}}],[\"数组在声明时需要指定固定的长度\",{\"1\":{\"70\":1}}],[\"数组作为一种数据类型\",{\"1\":{\"63\":1}}],[\"数组作为参数时\",{\"1\":{\"63\":1}}],[\"数组支持随机访问\",{\"1\":{\"62\":1}}],[\"数组声明的语法如下所示\",{\"1\":{\"60\":1}}],[\"数组是固定大小的连续内存块\",{\"1\":{\"160\":1}}],[\"数组是固定长度\",{\"1\":{\"73\":1}}],[\"数组是固定长度的数据结构\",{\"1\":{\"58\":1}}],[\"数组是在栈上分配内存的\",{\"1\":{\"70\":1}}],[\"数组是一整块连续内存\",{\"1\":{\"59\":1}}],[\"数组\",{\"0\":{\"59\":1},\"1\":{\"69\":1,\"135\":1}}],[\"数组和切片\",{\"0\":{\"58\":1},\"1\":{\"22\":1}}],[\"数学运算\",{\"1\":{\"18\":1}}],[\"数据传递\",{\"1\":{\"182\":1}}],[\"数据\",{\"1\":{\"172\":1,\"173\":1}}],[\"数据都是存在内存中的二进制序列\",{\"1\":{\"161\":1}}],[\"数据库映射\",{\"1\":{\"152\":1}}],[\"数据处理\",{\"1\":{\"77\":1}}],[\"数据类型实际上是为了优化内存空间的占用而提出的概念\",{\"1\":{\"158\":1}}],[\"数据类型用于声明变量\",{\"1\":{\"158\":1}}],[\"数据类型及变量\",{\"0\":{\"157\":1}}],[\"数据类型的小节中\",{\"1\":{\"101\":1}}],[\"数据类型\",{\"0\":{\"158\":1},\"1\":{\"66\":1}}],[\"数据的编码和解码\",{\"1\":{\"17\":2}}],[\"数据序列化和编码\",{\"0\":{\"17\":1}}],[\"数据流处理等\",{\"1\":{\"16\":1}}],[\"数据结构和算法\",{\"0\":{\"14\":1}}],[\"格式化占位符\",{\"0\":{\"37\":1}}],[\"格式化输出的宽度和精度控制\",{\"1\":{\"41\":1}}],[\"格式化输出\",{\"0\":{\"36\":1}}],[\"格式化输入输出\",{\"1\":{\"13\":1}}],[\"格式文件的读写\",{\"1\":{\"17\":1}}],[\"w++\",{\"1\":{\"184\":1,\"186\":1}}],[\"w\",{\"1\":{\"184\":3,\"186\":3}}],[\"waitcondition\",{\"1\":{\"236\":3}}],[\"wait\",{\"1\":{\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"184\":1,\"185\":1,\"186\":1,\"189\":1,\"207\":2,\"219\":1,\"220\":1,\"221\":1,\"223\":1,\"235\":1,\"236\":2,\"239\":1}}],[\"waitgroup\",{\"1\":{\"15\":1,\"167\":2,\"168\":2,\"169\":2,\"170\":2,\"184\":2,\"185\":1,\"186\":2,\"189\":3,\"207\":4,\"219\":1,\"220\":1,\"221\":1,\"223\":3,\"235\":4,\"236\":2,\"239\":6,\"240\":1}}],[\"wg\",{\"1\":{\"167\":6,\"168\":6,\"169\":6,\"170\":6,\"184\":6,\"185\":4,\"186\":6,\"189\":10,\"207\":9,\"219\":4,\"220\":6,\"221\":4,\"223\":9,\"235\":4,\"236\":4,\"239\":6}}],[\"while\",{\"1\":{\"121\":4}}],[\"with\",{\"1\":{\"197\":1}}],[\"withvalue\",{\"1\":{\"197\":3}}],[\"withdeadline\",{\"1\":{\"196\":2}}],[\"withtimeout\",{\"1\":{\"195\":2,\"196\":1,\"197\":1}}],[\"withcancel\",{\"1\":{\"194\":2}}],[\"will\",{\"1\":{\"152\":1}}],[\"width\",{\"1\":{\"93\":2,\"101\":2,\"113\":3,\"114\":1,\"116\":4}}],[\"windows\",{\"1\":{\"76\":1}}],[\"www\",{\"1\":{\"83\":1,\"162\":1}}],[\"weekday\",{\"1\":{\"120\":1}}],[\"weekend\",{\"1\":{\"120\":1}}],[\"web\",{\"1\":{\"77\":2,\"78\":1}}],[\"went\",{\"1\":{\"40\":1,\"87\":2,\"89\":1}}],[\"work\",{\"1\":{\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"222\":1}}],[\"workers\",{\"1\":{\"207\":1,\"239\":1}}],[\"worker\",{\"0\":{\"184\":1},\"1\":{\"180\":3,\"184\":7,\"186\":6,\"206\":3,\"207\":4,\"222\":2,\"237\":7,\"238\":7,\"239\":5}}],[\"working\",{\"1\":{\"47\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"222\":1,\"237\":1,\"238\":1,\"239\":1}}],[\"world\",{\"1\":{\"36\":4,\"67\":1,\"99\":2}}],[\"wd\",{\"1\":{\"47\":2}}],[\"write\",{\"1\":{\"117\":1,\"220\":2}}],[\"writer\",{\"1\":{\"16\":1,\"41\":1,\"117\":2,\"223\":3}}],[\"wrappederr\",{\"1\":{\"89\":2}}],[\"wrapf\",{\"1\":{\"89\":1}}],[\"wrap\",{\"1\":{\"89\":2}}],[\"wrong\",{\"1\":{\"40\":1,\"87\":2,\"89\":1}}],[\"网络和io\",{\"0\":{\"16\":1}}],[\"网络编程\",{\"0\":{\"1\":1,\"241\":1},\"1\":{\"16\":1}}],[\"超时和带值的上下文\",{\"1\":{\"197\":1}}],[\"超时上下文\",{\"0\":{\"195\":1}}],[\"超时控制\",{\"1\":{\"123\":1,\"190\":1}}],[\"超时\",{\"1\":{\"15\":1}}],[\"的启动\",{\"1\":{\"223\":1}}],[\"的内存模型是编写并发安全程序的基础\",{\"1\":{\"224\":1}}],[\"的内存模型主要通过以下规则来保证内存操作的可见性和一致性\",{\"1\":{\"214\":1}}],[\"的内存地址\",{\"1\":{\"139\":1}}],[\"的情况下缓冲一定数量的数据\",{\"1\":{\"205\":1}}],[\"的栈是动态增长的\",{\"1\":{\"201\":1}}],[\"的生命周期\",{\"1\":{\"198\":1}}],[\"的方法包括使用互斥锁\",{\"1\":{\"171\":1}}],[\"的方式来检查错误\",{\"1\":{\"88\":1}}],[\"的通道可以实现无锁并发编程\",{\"1\":{\"170\":1}}],[\"的变量\",{\"1\":{\"161\":2}}],[\"的执行顺序\",{\"1\":{\"167\":1,\"171\":1}}],[\"的执行\",{\"1\":{\"160\":1}}],[\"的总大小是\",{\"1\":{\"156\":1}}],[\"的起始位置对齐在\",{\"1\":{\"156\":1}}],[\"的末尾与\",{\"1\":{\"156\":1}}],[\"的大小正好是\",{\"1\":{\"156\":1}}],[\"的偏移量是\",{\"1\":{\"156\":2}}],[\"的指针\",{\"1\":{\"144\":2,\"160\":1}}],[\"的指针算术运算\",{\"1\":{\"142\":1}}],[\"的指针运算案例\",{\"1\":{\"142\":1}}],[\"的优先级高于加法运算符+\",{\"1\":{\"136\":1}}],[\"的地址\",{\"1\":{\"135\":1,\"160\":1}}],[\"的数据集\",{\"1\":{\"128\":1}}],[\"的数字\",{\"1\":{\"121\":1}}],[\"的键\",{\"1\":{\"128\":2}}],[\"的键会导致不可预测的行为\",{\"1\":{\"128\":1}}],[\"的键可以是任何支持\",{\"1\":{\"126\":1}}],[\"的并发访问\",{\"1\":{\"127\":1}}],[\"的并发特性使其在数据处理和流处理领域表现出色\",{\"1\":{\"77\":1}}],[\"的零值是\",{\"1\":{\"126\":1}}],[\"的特性\",{\"0\":{\"201\":1},\"1\":{\"126\":1}}],[\"的修改会影响到所有引用它的变量\",{\"1\":{\"126\":1}}],[\"的声明语法如下所示\",{\"1\":{\"125\":1}}],[\"的操作\",{\"1\":{\"123\":1}}],[\"的消息先准备好\",{\"1\":{\"123\":1}}],[\"的消息比\",{\"1\":{\"123\":1}}],[\"的发送或接收操作\",{\"1\":{\"123\":1}}],[\"的循环\",{\"1\":{\"121\":1}}],[\"的类型选择不同的\",{\"1\":{\"120\":1}}],[\"的类型断言结果\",{\"1\":{\"120\":1}}],[\"的\",{\"1\":{\"120\":1,\"154\":1}}],[\"的访问控制机制简化了代码结构\",{\"1\":{\"102\":1}}],[\"的所有标识符\",{\"1\":{\"102\":1}}],[\"的接收者类型\",{\"1\":{\"101\":1}}],[\"的错误值\",{\"1\":{\"86\":1,\"88\":1}}],[\"的性能和效率使其适合用于系统级编程和网络服务器开发\",{\"1\":{\"77\":1}}],[\"的语法简洁明了\",{\"1\":{\"76\":1}}],[\"的主要特点包括\",{\"1\":{\"76\":1}}],[\"的设计灵感来自\",{\"1\":{\"75\":1}}],[\"的长度\",{\"1\":{\"68\":2}}],[\"的值再赋给\",{\"1\":{\"136\":1}}],[\"的值可以是任何类型\",{\"1\":{\"126\":1}}],[\"的值时\",{\"1\":{\"126\":1}}],[\"的值不再小于\",{\"1\":{\"121\":1}}],[\"的值为\",{\"1\":{\"101\":16}}],[\"的值转换为\",{\"1\":{\"101\":6}}],[\"的值\",{\"1\":{\"68\":1,\"101\":1,\"155\":4}}],[\"的元素的数组\",{\"1\":{\"160\":1}}],[\"的元素\",{\"1\":{\"67\":1}}],[\"的例子\",{\"1\":{\"52\":1}}],[\"的取消\",{\"1\":{\"15\":1}}],[\"的一个概述和基本用法示例\",{\"1\":{\"11\":1}}],[\"met\",{\"1\":{\"236\":1}}],[\"message\",{\"1\":{\"123\":3,\"155\":2}}],[\"millisecond\",{\"1\":{\"185\":1,\"189\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1}}],[\"msg\",{\"1\":{\"230\":2,\"231\":2}}],[\"msg2\",{\"1\":{\"123\":2,\"181\":2,\"188\":2,\"229\":2}}],[\"msg1\",{\"1\":{\"123\":2,\"181\":2,\"188\":2,\"229\":2}}],[\"m\",{\"1\":{\"101\":7,\"108\":5,\"125\":2,\"126\":6,\"127\":5,\"128\":4,\"160\":1}}],[\"multiplexing\",{\"0\":{\"188\":1}}],[\"multiply\",{\"1\":{\"93\":1}}],[\"mu\",{\"1\":{\"168\":5,\"219\":3,\"220\":5,\"223\":7,\"235\":3,\"236\":6}}],[\"mutex\",{\"0\":{\"219\":1},\"1\":{\"15\":1,\"127\":1,\"166\":1,\"168\":2,\"219\":1,\"223\":1,\"235\":2,\"236\":1}}],[\"mongodb\",{\"1\":{\"154\":1}}],[\"modifyslice\",{\"1\":{\"72\":2}}],[\"modifyarray\",{\"1\":{\"72\":2}}],[\"move\",{\"1\":{\"27\":1,\"28\":1}}],[\"mkdirall\",{\"1\":{\"44\":2}}],[\"mkdir\",{\"1\":{\"44\":2}}],[\"myfunction\",{\"1\":{\"200\":2}}],[\"myvalue\",{\"1\":{\"197\":1}}],[\"mykey\",{\"1\":{\"197\":2}}],[\"mystruct\",{\"1\":{\"156\":5}}],[\"myset\",{\"1\":{\"155\":5}}],[\"mymap\",{\"1\":{\"122\":2}}],[\"myint\",{\"1\":{\"101\":15}}],[\"myapp\",{\"1\":{\"45\":1}}],[\"mydir\",{\"1\":{\"44\":3}}],[\"myring\",{\"1\":{\"27\":9,\"28\":1}}],[\"mylist\",{\"1\":{\"25\":10,\"26\":1}}],[\"myqueue\",{\"1\":{\"23\":6}}],[\"md5\",{\"1\":{\"18\":1}}],[\"marshalling\",{\"1\":{\"152\":1}}],[\"marshal\",{\"1\":{\"152\":1}}],[\"mast\",{\"1\":{\"150\":4,\"151\":3}}],[\"maplen\",{\"1\":{\"126\":1}}],[\"map\",{\"0\":{\"124\":1},\"1\":{\"108\":4,\"122\":3,\"124\":3,\"125\":6,\"126\":12,\"127\":6,\"128\":7,\"155\":5,\"160\":3}}],[\"maxworkers\",{\"1\":{\"237\":2}}],[\"max\",{\"1\":{\"107\":4}}],[\"macos\",{\"1\":{\"76\":1}}],[\"many\",{\"1\":{\"61\":1}}],[\"makeadder\",{\"1\":{\"98\":2}}],[\"makemultiplier\",{\"1\":{\"96\":2}}],[\"make\",{\"1\":{\"24\":1,\"66\":5,\"67\":1,\"108\":1,\"122\":1,\"123\":2,\"125\":2,\"128\":1,\"149\":2,\"155\":2,\"160\":1,\"170\":1,\"174\":2,\"177\":1,\"178\":1,\"180\":1,\"181\":2,\"184\":2,\"185\":3,\"186\":1,\"187\":3,\"188\":1,\"189\":1,\"203\":2,\"205\":1,\"206\":1,\"222\":1,\"229\":2,\"230\":1,\"231\":1,\"237\":1,\"238\":1}}],[\"math\",{\"1\":{\"18\":3,\"128\":6}}],[\"main\",{\"1\":{\"8\":2,\"9\":2,\"23\":2,\"24\":2,\"25\":2,\"27\":2,\"30\":3,\"32\":2,\"39\":1,\"40\":1,\"44\":2,\"49\":1,\"50\":1,\"52\":2,\"54\":4,\"55\":4,\"56\":4,\"72\":2,\"89\":1,\"99\":1,\"101\":3,\"121\":8,\"123\":2,\"127\":2,\"128\":2,\"141\":1,\"142\":1,\"151\":2,\"152\":2,\"155\":8,\"156\":4,\"167\":2,\"168\":2,\"169\":2,\"170\":2,\"180\":3,\"181\":1,\"184\":2,\"185\":2,\"186\":2,\"187\":2,\"188\":2,\"189\":2,\"193\":1,\"194\":2,\"195\":2,\"196\":2,\"197\":4,\"206\":3,\"207\":2,\"219\":2,\"220\":2,\"221\":2,\"222\":2,\"223\":2,\"229\":2,\"230\":2,\"231\":2,\"235\":2,\"236\":2,\"237\":2,\"238\":3,\"239\":2,\"240\":2}}],[\"等待\",{\"1\":{\"238\":1}}],[\"等待条件变量满足条件\",{\"1\":{\"236\":1}}],[\"等待所有生产者完成\",{\"1\":{\"189\":1}}],[\"等待所有\",{\"1\":{\"184\":1,\"186\":1,\"235\":1,\"237\":1,\"239\":1,\"240\":1}}],[\"等数据格式的映射\",{\"1\":{\"154\":1}}],[\"等数据结构的元素\",{\"1\":{\"122\":1}}],[\"等同于\",{\"1\":{\"134\":1}}],[\"等于\",{\"1\":{\"120\":2,\"131\":1,\"136\":1}}],[\"等语言中函数只能返回一个值不同\",{\"1\":{\"93\":1}}],[\"等操作系统\",{\"1\":{\"76\":1}}],[\"等函数时\",{\"1\":{\"56\":1}}],[\"等哈希算法和对称\",{\"1\":{\"18\":1}}],[\"等协议的支持\",{\"1\":{\"16\":1}}],[\"等\",{\"1\":{\"14\":1,\"37\":1,\"126\":1}}],[\"如互斥锁\",{\"1\":{\"214\":1}}],[\"如何与内存进行交互\",{\"1\":{\"213\":1}}],[\"如爬虫\",{\"1\":{\"211\":1}}],[\"如高并发网络服务器\",{\"1\":{\"211\":1}}],[\"如多线程服务器\",{\"1\":{\"210\":1}}],[\"如管道\",{\"1\":{\"209\":1}}],[\"如参数变量\",{\"1\":{\"158\":1}}],[\"如布尔型\",{\"1\":{\"126\":1}}],[\"如下所示\",{\"1\":{\"67\":1,\"150\":1}}],[\"如果一个通道关闭且仍有数据在缓冲区中\",{\"1\":{\"232\":1}}],[\"如果一个操作\",{\"1\":{\"216\":1}}],[\"如果一秒内没有接收到数据\",{\"1\":{\"230\":1}}],[\"如果一秒内没有任何通道操作成功\",{\"1\":{\"227\":1}}],[\"如果操作\",{\"1\":{\"214\":1}}],[\"如果主程序退出\",{\"1\":{\"207\":1}}],[\"如果这个函数有返回值\",{\"1\":{\"199\":1}}],[\"如果省略了值则表示和上面一行的值相同\",{\"1\":{\"162\":1}}],[\"如果省略字段名\",{\"1\":{\"149\":1}}],[\"如果它们支持比较操作\",{\"1\":{\"128\":1}}],[\"如果它们的所有字段都是可比较的类型\",{\"1\":{\"128\":1}}],[\"如果在多个\",{\"1\":{\"127\":1}}],[\"如果将一个\",{\"1\":{\"126\":1}}],[\"如果不存在则插入\",{\"1\":{\"126\":1}}],[\"如果键不存在\",{\"1\":{\"126\":1}}],[\"如果没有数据接收\",{\"1\":{\"231\":1}}],[\"如果没有任何通道操作成功\",{\"1\":{\"227\":1}}],[\"如果没有任何\",{\"1\":{\"123\":1}}],[\"如果没有错误\",{\"1\":{\"88\":1}}],[\"如果多个\",{\"1\":{\"123\":1}}],[\"如果\",{\"1\":{\"120\":1}}],[\"如果类型断言失败\",{\"1\":{\"116\":1}}],[\"如果想访问其内部的数据\",{\"1\":{\"102\":1}}],[\"如果要是通过指针调用会如何呢\",{\"1\":{\"101\":1}}],[\"如果错误值为\",{\"1\":{\"86\":1}}],[\"如果有多个\",{\"1\":{\"232\":1}}],[\"如果有相同类型的字段\",{\"1\":{\"148\":1}}],[\"如果有问题\",{\"1\":{\"86\":1}}],[\"如果有足够的容量\",{\"1\":{\"67\":1}}],[\"如果你确实需要进行类似于\",{\"1\":{\"142\":1}}],[\"如果你有一个包含\",{\"1\":{\"128\":1}}],[\"如果你想要定义自己的错误类型\",{\"1\":{\"85\":1}}],[\"如果你定义的数组长度大于你给定的数据列表\",{\"1\":{\"61\":1}}],[\"如果完全按照如上步骤进行操作\",{\"1\":{\"80\":1}}],[\"如果您已经配好环境\",{\"1\":{\"79\":1}}],[\"如果切片的容量不足\",{\"1\":{\"67\":1}}],[\"如果所添加的数据超过该容量\",{\"1\":{\"66\":1}}],[\"如果需要获取数组的子数组\",{\"1\":{\"62\":1}}],[\"如果需要更详细的信息\",{\"1\":{\"11\":1}}],[\"如果数组长度不确定\",{\"1\":{\"61\":1}}],[\"如果转换失败会返回一个错误\",{\"1\":{\"56\":1}}],[\"如快速排序\",{\"1\":{\"48\":1}}],[\"如\",{\"1\":{\"13\":1,\"15\":2,\"16\":2,\"18\":2,\"19\":1,\"77\":1,\"116\":1,\"150\":1,\"155\":1,\"158\":1,\"201\":1,\"211\":1}}],[\"例如赋值运算符=\",{\"1\":{\"136\":1}}],[\"例如在一定时间内等待某个操作完成或者超时返回默认结果\",{\"1\":{\"123\":1}}],[\"例如函数参数或者存储任意类型的数据\",{\"1\":{\"115\":1}}],[\"例如泛型列表\",{\"1\":{\"106\":1}}],[\"例如打印错误信息或者进行其他操作\",{\"1\":{\"88\":1}}],[\"例如将整数转换为字符串\",{\"1\":{\"53\":1}}],[\"例如实现循环队列\",{\"1\":{\"28\":1}}],[\"例如实现队列\",{\"1\":{\"26\":1}}],[\"例如文件操作\",{\"1\":{\"13\":1}}],[\"例如\",{\"1\":{\"13\":2,\"14\":1,\"16\":1,\"30\":1,\"86\":1,\"87\":1,\"88\":1,\"107\":1,\"109\":1,\"112\":1,\"113\":1,\"114\":1,\"116\":1,\"122\":4,\"126\":1,\"136\":2,\"154\":1,\"156\":2,\"167\":1,\"200\":1,\"207\":1,\"233\":1}}],[\"基本数据类型\",{\"0\":{\"159\":1},\"1\":{\"158\":1}}],[\"基本类型的值\",{\"1\":{\"159\":1}}],[\"基本类型\",{\"1\":{\"128\":1}}],[\"基本的\",{\"1\":{\"121\":1}}],[\"基本语法\",{\"1\":{\"121\":1,\"123\":1}}],[\"基本用法\",{\"0\":{\"7\":1,\"191\":1},\"1\":{\"30\":1}}],[\"基数转换\",{\"1\":{\"56\":1}}],[\"基础知识\",{\"0\":{\"146\":1},\"1\":{\"22\":1}}],[\"基础模块\",{\"0\":{\"13\":1}}],[\"以展示其灵活性和强大之处\",{\"1\":{\"228\":1}}],[\"以确保程序符合内存模型的要求\",{\"1\":{\"217\":1}}],[\"以确保内存访问的效率\",{\"1\":{\"156\":1}}],[\"以通知接收者没有更多的数据将被发送\",{\"1\":{\"179\":1}}],[\"以节省内存\",{\"1\":{\"155\":1}}],[\"以本节中的\",{\"1\":{\"150\":1}}],[\"以满足实际需求\",{\"1\":{\"119\":1}}],[\"以便为其他结构体提供方法集合\",{\"1\":{\"155\":1}}],[\"以便处理接口类型的不同实现\",{\"1\":{\"120\":1}}],[\"以便在不同的场景中使用\",{\"1\":{\"117\":1}}],[\"以便限制泛型类型的使用范围\",{\"1\":{\"109\":1}}],[\"以便于匹配\",{\"1\":{\"101\":1}}],[\"以其简洁\",{\"1\":{\"78\":1}}],[\"以其简洁的语法和高效的编译速度而闻名\",{\"1\":{\"76\":1}}],[\"以避免因为数据的添加而导致的不断扩容\",{\"1\":{\"66\":1}}],[\"以及与数据库\",{\"1\":{\"154\":1}}],[\"以及通道\",{\"1\":{\"122\":1}}],[\"以及实现接口的类型\",{\"1\":{\"111\":1}}],[\"以及其他类型之间的转换\",{\"1\":{\"53\":1}}],[\"以及如何遍历链表并打印每个元素\",{\"1\":{\"26\":1}}],[\"以下是它们的主要区别\",{\"1\":{\"208\":1}}],[\"以下是go语言中常见运算符的优先级\",{\"1\":{\"136\":1}}],[\"以下是关于通道的一些重要特性和使用方法\",{\"1\":{\"172\":1}}],[\"以下是关于\",{\"1\":{\"123\":1}}],[\"以下是几种\",{\"1\":{\"119\":1}}],[\"以下是一个简单的\",{\"1\":{\"206\":1}}],[\"以下是一个简单的使用通道在\",{\"1\":{\"180\":1}}],[\"以下是一个示例\",{\"1\":{\"128\":1}}],[\"以下是一个结合了自定义排序和使用\",{\"1\":{\"52\":1}}],[\"以下是一些常见的控制原语\",{\"1\":{\"234\":1}}],[\"以下是一些常见的并发模式\",{\"1\":{\"183\":1}}],[\"以下是一些\",{\"1\":{\"35\":1}}],[\"以下是一些主要的\",{\"1\":{\"12\":1}}],[\"以下是\",{\"1\":{\"21\":1,\"48\":1,\"53\":1,\"90\":1,\"149\":1}}],[\"以上是\",{\"1\":{\"11\":1}}],[\"它类似于\",{\"1\":{\"181\":1}}],[\"它通过将内存划分成大小均匀的小块\",{\"1\":{\"156\":1}}],[\"它们才会继续执行\",{\"1\":{\"239\":1}}],[\"它们通常与互斥锁结合使用\",{\"1\":{\"236\":1}}],[\"它们帮助程序确保资源的正确使用和状态的一致性\",{\"1\":{\"234\":1}}],[\"它们有不同的特性和适用场景\",{\"1\":{\"208\":1}}],[\"它们是并发执行代码的基础\",{\"1\":{\"199\":1}}],[\"它们都指向同一个底层数据结构\",{\"1\":{\"126\":1}}],[\"它们用于指示函数调用或操作是否成功以及发生了什么问题\",{\"1\":{\"84\":1}}],[\"它们用于将数据输出到控制台或其他输出设备\",{\"1\":{\"36\":1}}],[\"它首先会去更新\",{\"1\":{\"126\":1}}],[\"它是引用类型\",{\"1\":{\"160\":1}}],[\"它是一个并发安全的\",{\"1\":{\"127\":1}}],[\"它是一种无序集合\",{\"1\":{\"124\":1}}],[\"它是可选的\",{\"1\":{\"123\":1}}],[\"它是方法集合的抽象表示\",{\"1\":{\"111\":1}}],[\"它可以控制同时访问某个资源的线程数\",{\"1\":{\"237\":1}}],[\"它可以是\",{\"1\":{\"123\":1}}],[\"它可以方便地进行环形数据结构的操作\",{\"1\":{\"27\":1}}],[\"它简化了对数据的遍历操作\",{\"1\":{\"122\":1}}],[\"它要求实现该接口的类型必须实现area\",{\"1\":{\"112\":1}}],[\"它限制类型参数必须是数值类型\",{\"1\":{\"109\":1}}],[\"它会返回一个非\",{\"1\":{\"88\":1}}],[\"它的值为\",{\"1\":{\"143\":1}}],[\"它的语法形式有所不同\",{\"1\":{\"122\":1}}],[\"它的签名是\",{\"1\":{\"86\":1}}],[\"它的长度和容量可以动态改变\",{\"1\":{\"71\":1}}],[\"它支持并发编程\",{\"1\":{\"76\":1}}],[\"它支持高效的插入\",{\"1\":{\"25\":1}}],[\"它由\",{\"1\":{\"75\":1}}],[\"它实现了常见的排序算法\",{\"1\":{\"48\":1}}],[\"它使得你可以轻松定义\",{\"1\":{\"34\":1}}],[\"它提供了丰富的功能和灵活的选项\",{\"1\":{\"57\":1}}],[\"它提供了与操作系统交互的功能\",{\"1\":{\"43\":1}}],[\"它提供了一种简单而直接的方式来解析和使用命令行参数\",{\"1\":{\"29\":1}}],[\"它提供了处理格式化输入和输出的基本工具\",{\"1\":{\"35\":1}}],[\"它提供了处理\",{\"1\":{\"5\":1}}],[\"它包含了丰富的功能模块\",{\"1\":{\"12\":1}}],[\"开销较小\",{\"1\":{\"212\":1}}],[\"开销大\",{\"1\":{\"209\":1,\"212\":1}}],[\"开关\",{\"1\":{\"120\":1}}],[\"开始之前\",{\"0\":{\"104\":1}}],[\"开箱即用\",{\"1\":{\"83\":1}}],[\"开发工具\",{\"0\":{\"81\":1}}],[\"开发\",{\"1\":{\"77\":1,\"78\":1}}],[\"开发的一种开源编程语言\",{\"1\":{\"75\":1}}],[\"开发者日常编程的重要资源\",{\"1\":{\"12\":1}}],[\"开源库\",{\"0\":{\"3\":1}}],[\"希望这些内容对您创建中文站点有所帮助\",{\"1\":{\"11\":1}}],[\"仓库\",{\"1\":{\"11\":1}}],[\"官方文档\",{\"1\":{\"11\":1}}],[\"支持\",{\"1\":{\"76\":1}}],[\"支持并发编程\",{\"1\":{\"76\":1}}],[\"支持动态增删元素\",{\"1\":{\"71\":1}}],[\"支持级别和格式化输出\",{\"1\":{\"19\":1}}],[\"支持原子性的内存访问\",{\"1\":{\"15\":1}}],[\"支持对切片的排序\",{\"1\":{\"14\":1}}],[\"支持本地和远程端口转发\",{\"1\":{\"10\":1}}],[\"支持多种数据传输方式\",{\"1\":{\"10\":1}}],[\"支持多种认证方法\",{\"1\":{\"10\":1}}],[\"端口转发\",{\"1\":{\"10\":1}}],[\"处理通信2的逻辑\",{\"1\":{\"123\":1}}],[\"处理通信1的逻辑\",{\"1\":{\"123\":1}}],[\"处理错误\",{\"0\":{\"88\":1},\"1\":{\"88\":1}}],[\"处理用户输入变得非常方便和直观\",{\"1\":{\"34\":1}}],[\"处理\",{\"1\":{\"10\":1,\"187\":1}}],[\"公钥认证等\",{\"1\":{\"10\":1}}],[\"认证\",{\"1\":{\"10\":1}}],[\"events\",{\"0\":{\"238\":1}}],[\"emptystruct\",{\"1\":{\"155\":3}}],[\"empty\",{\"1\":{\"155\":1}}],[\"email\",{\"1\":{\"152\":4,\"153\":1}}],[\"exists\",{\"1\":{\"126\":2,\"128\":9,\"155\":2}}],[\"exit\",{\"1\":{\"46\":2}}],[\"expression\",{\"1\":{\"120\":3}}],[\"exported\",{\"1\":{\"102\":1}}],[\"echo\",{\"1\":{\"77\":1}}],[\"eappend\",{\"1\":{\"67\":1}}],[\"end\",{\"1\":{\"185\":2}}],[\"enter\",{\"1\":{\"38\":1}}],[\"encoding\",{\"1\":{\"17\":3,\"152\":1}}],[\"elem2\",{\"1\":{\"67\":1}}],[\"elem1\",{\"1\":{\"67\":1}}],[\"elems\",{\"1\":{\"67\":1}}],[\"element\",{\"1\":{\"25\":1,\"26\":1,\"142\":2}}],[\"else\",{\"1\":{\"9\":1,\"116\":1,\"119\":6,\"120\":1,\"126\":1,\"197\":1}}],[\"e\",{\"1\":{\"23\":5,\"25\":10,\"26\":1}}],[\"errors\",{\"1\":{\"84\":1,\"87\":3,\"89\":5}}],[\"error\",{\"1\":{\"40\":2,\"44\":7,\"45\":2,\"47\":3,\"54\":2,\"56\":3,\"84\":1,\"85\":4,\"86\":1,\"87\":1,\"88\":1,\"89\":1,\"100\":3,\"117\":2,\"152\":2}}],[\"errorf\",{\"1\":{\"40\":2,\"100\":1}}],[\"err\",{\"1\":{\"8\":9,\"9\":18,\"40\":3,\"44\":18,\"45\":3,\"47\":11,\"54\":6,\"56\":6,\"88\":4,\"89\":3,\"100\":3,\"152\":6}}],[\"<stdio\",{\"1\":{\"142\":1}}],[\"<<=\",{\"1\":{\"134\":1,\"136\":1}}],[\"<<\",{\"1\":{\"133\":2,\"136\":1}}],[\"<=\",{\"1\":{\"27\":1,\"97\":1,\"121\":1,\"131\":1,\"136\":1,\"184\":2,\"185\":1,\"186\":2,\"189\":3,\"207\":1}}],[\"<\",{\"1\":{\"9\":1,\"24\":1,\"50\":1,\"52\":1,\"120\":1,\"121\":1,\"122\":3,\"123\":4,\"131\":2,\"136\":1,\"142\":1,\"155\":1,\"160\":3,\"167\":2,\"168\":2,\"169\":2,\"170\":3,\"175\":3,\"177\":2,\"178\":2,\"179\":1,\"180\":2,\"181\":5,\"184\":3,\"185\":5,\"186\":2,\"187\":8,\"188\":5,\"189\":2,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"204\":3,\"206\":2,\"219\":1,\"220\":2,\"221\":1,\"222\":2,\"227\":3,\"229\":5,\"230\":3,\"231\":1,\"235\":1,\"237\":3,\"238\":2,\"239\":1,\"240\":1}}],[\"uint64\",{\"1\":{\"104\":1,\"159\":1}}],[\"uint32\",{\"1\":{\"104\":1,\"159\":1}}],[\"uint16\",{\"1\":{\"104\":1,\"159\":1}}],[\"uint8\",{\"1\":{\"104\":1,\"159\":1}}],[\"uint\",{\"1\":{\"104\":1,\"159\":1}}],[\"uintptr\",{\"1\":{\"68\":1}}],[\"url\",{\"1\":{\"45\":1,\"162\":1}}],[\"unlock\",{\"1\":{\"168\":2,\"219\":1,\"220\":1,\"223\":3,\"235\":1,\"236\":2}}],[\"unlimited\",{\"1\":{\"83\":1}}],[\"unmarshalling\",{\"1\":{\"152\":1}}],[\"unmarshal\",{\"1\":{\"152\":1}}],[\"unsafe\",{\"1\":{\"142\":2,\"155\":2,\"156\":10}}],[\"unsetenv\",{\"1\":{\"45\":1}}],[\"unexported\",{\"1\":{\"102\":1}}],[\"unknown\",{\"1\":{\"9\":1,\"120\":1}}],[\"unknownchanneltype\",{\"1\":{\"9\":1}}],[\"using\",{\"1\":{\"142\":1}}],[\"usage\",{\"1\":{\"33\":3}}],[\"username\",{\"1\":{\"8\":1}}],[\"user\",{\"1\":{\"8\":1,\"154\":1}}],[\"udp\",{\"1\":{\"16\":1}}],[\"happens\",{\"0\":{\"216\":1},\"1\":{\"216\":2,\"223\":4,\"224\":1}}],[\"handlefunc\",{\"1\":{\"16\":1}}],[\"handlechannel\",{\"1\":{\"9\":2}}],[\"handleconn\",{\"1\":{\"9\":2}}],[\"handshake\",{\"1\":{\"9\":1}}],[\"h>\",{\"1\":{\"142\":1}}],[\"hostname\",{\"1\":{\"47\":5}}],[\"hostkeycallback\",{\"1\":{\"8\":1}}],[\"home\",{\"1\":{\"45\":2}}],[\"height\",{\"1\":{\"93\":2,\"101\":2,\"113\":3,\"114\":1,\"116\":4,\"126\":1}}],[\"hello\",{\"1\":{\"36\":4,\"38\":1,\"56\":2,\"67\":1,\"99\":2,\"115\":1,\"120\":1,\"122\":1}}],[\"heapsort\",{\"1\":{\"48\":1}}],[\"heap\",{\"0\":{\"24\":1},\"1\":{\"14\":1,\"24\":7}}],[\"h\",{\"1\":{\"33\":1}}],[\"https\",{\"1\":{\"80\":2,\"82\":1,\"83\":1,\"162\":1}}],[\"http\",{\"1\":{\"16\":5}}],[\"0x000c\",{\"1\":{\"160\":1}}],[\"0x0004\",{\"1\":{\"160\":1}}],[\"0x0000\",{\"1\":{\"160\":2}}],[\"0x1400012a0b0\",{\"1\":{\"140\":1}}],[\"001\",{\"1\":{\"133\":1}}],[\"011\",{\"1\":{\"133\":1}}],[\"0755\",{\"1\":{\"44\":2}}],[\"0\",{\"1\":{\"9\":9,\"24\":3,\"33\":1,\"61\":2,\"62\":3,\"66\":2,\"67\":8,\"72\":2,\"94\":1,\"100\":3,\"106\":2,\"108\":1,\"120\":2,\"121\":2,\"126\":1,\"142\":2,\"155\":1,\"156\":3,\"161\":1,\"163\":1,\"167\":2,\"168\":2,\"169\":2,\"170\":3,\"180\":1,\"181\":1,\"188\":1,\"206\":1,\"219\":1,\"220\":2,\"221\":1,\"229\":1,\"235\":1,\"237\":1,\"239\":1,\"240\":2}}],[\"all\",{\"1\":{\"207\":1,\"239\":1}}],[\"alice\",{\"1\":{\"23\":2,\"25\":1,\"30\":1,\"36\":2,\"39\":2,\"50\":1,\"52\":1,\"125\":1,\"127\":3,\"149\":1,\"152\":2}}],[\"assertion\",{\"1\":{\"116\":1}}],[\"andresult\",{\"1\":{\"132\":1,\"133\":1}}],[\"another\",{\"1\":{\"128\":2}}],[\"anothernan\",{\"1\":{\"128\":3}}],[\"anotherslice\",{\"1\":{\"67\":1}}],[\"an\",{\"1\":{\"120\":1}}],[\"any\",{\"1\":{\"105\":2,\"106\":1,\"108\":1}}],[\"ai\",{\"1\":{\"83\":1}}],[\"are\",{\"1\":{\"239\":1}}],[\"area\",{\"1\":{\"93\":2,\"101\":4,\"112\":1,\"113\":1}}],[\"arithmetic\",{\"1\":{\"142\":1}}],[\"arr\",{\"1\":{\"61\":5,\"62\":11,\"69\":1,\"70\":2,\"72\":7,\"142\":3,\"160\":1}}],[\"array\",{\"1\":{\"61\":1,\"122\":1}}],[\"arraylength\",{\"1\":{\"60\":1,\"61\":1}}],[\"arrayname\",{\"1\":{\"60\":1,\"61\":1}}],[\"arguments\",{\"1\":{\"32\":1}}],[\"args\",{\"1\":{\"32\":4,\"33\":1}}],[\"a\",{\"1\":{\"50\":10,\"52\":10,\"92\":3,\"95\":2,\"98\":2,\"104\":4,\"105\":1,\"106\":2,\"107\":4,\"120\":1,\"122\":1,\"128\":3,\"130\":6,\"131\":5,\"133\":6,\"134\":4,\"136\":4,\"156\":13,\"160\":3,\"214\":2}}],[\"age\",{\"1\":{\"30\":8,\"31\":5,\"32\":1,\"33\":2,\"36\":4,\"37\":4,\"39\":2,\"50\":5,\"52\":2,\"126\":5,\"127\":3,\"135\":2,\"149\":5,\"150\":5,\"151\":14,\"152\":6,\"154\":2,\"160\":1,\"161\":1,\"162\":1}}],[\"after\",{\"1\":{\"25\":1,\"123\":1,\"227\":1,\"230\":1}}],[\"apple\",{\"1\":{\"155\":3}}],[\"apply\",{\"1\":{\"98\":2}}],[\"append\",{\"1\":{\"24\":1,\"67\":12,\"68\":1,\"71\":1,\"106\":1,\"108\":1}}],[\"api\",{\"1\":{\"15\":1,\"77\":1,\"190\":1,\"197\":1}}],[\"add5\",{\"1\":{\"98\":2}}],[\"add\",{\"1\":{\"92\":3,\"95\":2,\"98\":1,\"106\":5,\"160\":2,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"184\":1,\"185\":1,\"186\":1,\"189\":2,\"196\":1,\"207\":2,\"219\":1,\"220\":2,\"221\":1,\"223\":1,\"235\":1,\"236\":1,\"239\":1}}],[\"addint32\",{\"1\":{\"15\":1,\"169\":1,\"221\":1,\"240\":1}}],[\"addhostkey\",{\"1\":{\"9\":1}}],[\"atomic\",{\"0\":{\"240\":1},\"1\":{\"15\":2,\"166\":1,\"169\":2,\"214\":1,\"221\":2,\"240\":3}}],[\"atoi\",{\"1\":{\"14\":1,\"54\":2,\"56\":3}}],[\"accept\",{\"1\":{\"9\":4}}],[\"authmethod\",{\"1\":{\"8\":1}}],[\"auth\",{\"1\":{\"8\":1}}],[\"rlock\",{\"1\":{\"220\":1}}],[\"race\",{\"0\":{\"167\":1},\"1\":{\"164\":1}}],[\"range提供了一种方便的方法来迭代数据结构的元素\",{\"1\":{\"122\":1}}],[\"range会迭代通道接收的数据\",{\"1\":{\"122\":1}}],[\"range返回两个值\",{\"1\":{\"122\":3}}],[\"range关键字用于迭代数组\",{\"1\":{\"122\":1}}],[\"range\",{\"0\":{\"122\":1},\"1\":{\"9\":2,\"24\":1,\"50\":1,\"52\":1,\"94\":1,\"105\":1,\"108\":1,\"109\":1,\"121\":4,\"122\":4,\"126\":1,\"127\":1,\"155\":1,\"170\":1,\"180\":1,\"184\":2,\"185\":3,\"186\":1,\"187\":4,\"189\":1,\"206\":1}}],[\"rightshift\",{\"1\":{\"133\":1}}],[\"ring\",{\"0\":{\"27\":1},\"1\":{\"27\":5,\"28\":3}}],[\"rwmutex\",{\"0\":{\"220\":1},\"1\":{\"127\":1,\"166\":1,\"220\":1,\"235\":1}}],[\"r\",{\"1\":{\"101\":5,\"113\":6,\"116\":6}}],[\"rob\",{\"1\":{\"75\":1}}],[\"robert\",{\"1\":{\"75\":1}}],[\"rotation\",{\"1\":{\"27\":1}}],[\"reached\",{\"1\":{\"196\":1}}],[\"ready\",{\"1\":{\"236\":3}}],[\"read\",{\"1\":{\"220\":2}}],[\"readperson\",{\"1\":{\"151\":6}}],[\"readwritecloser\",{\"1\":{\"117\":1}}],[\"reader\",{\"1\":{\"16\":1,\"117\":1,\"223\":4}}],[\"readfile\",{\"1\":{\"9\":1}}],[\"receive\",{\"1\":{\"173\":1}}],[\"received\",{\"1\":{\"123\":3,\"181\":2,\"229\":2,\"230\":1,\"231\":2}}],[\"rect\",{\"1\":{\"101\":2}}],[\"rectangle结构体实现了shape接口的area\",{\"1\":{\"113\":1}}],[\"rectangle\",{\"1\":{\"101\":5,\"113\":3,\"114\":1,\"116\":2}}],[\"rectanglearea\",{\"1\":{\"93\":1}}],[\"remainder\",{\"1\":{\"93\":2,\"130\":1}}],[\"removal\",{\"1\":{\"25\":1}}],[\"removeall\",{\"1\":{\"44\":2}}],[\"remove\",{\"1\":{\"23\":1,\"25\":1,\"26\":1,\"44\":2}}],[\"remoteaddr\",{\"1\":{\"9\":1}}],[\"results\",{\"1\":{\"184\":6}}],[\"result\",{\"1\":{\"88\":3,\"92\":2,\"95\":2,\"96\":2,\"97\":2,\"98\":4,\"100\":1,\"184\":3}}],[\"rename\",{\"1\":{\"44\":1}}],[\"reply\",{\"1\":{\"9\":2}}],[\"req\",{\"1\":{\"9\":5}}],[\"request\",{\"1\":{\"9\":1}}],[\"requests\",{\"1\":{\"9\":4}}],[\"reqs\",{\"1\":{\"9\":2}}],[\"reject\",{\"1\":{\"9\":1}}],[\"return\",{\"1\":{\"9\":2,\"24\":3,\"39\":1,\"40\":1,\"50\":2,\"52\":2,\"54\":2,\"56\":1,\"87\":1,\"88\":1,\"89\":1,\"92\":1,\"93\":4,\"94\":1,\"95\":1,\"96\":2,\"97\":2,\"98\":3,\"100\":2,\"101\":1,\"104\":2,\"106\":1,\"107\":2,\"108\":1,\"109\":1,\"113\":2,\"127\":1,\"142\":1,\"149\":1,\"152\":2,\"160\":1,\"185\":1,\"187\":3,\"188\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"220\":1}}],[\"runlock\",{\"1\":{\"220\":1}}],[\"run\",{\"1\":{\"8\":2,\"30\":1}}],[\"p++\",{\"1\":{\"189\":1}}],[\"p4\",{\"1\":{\"149\":1}}],[\"p3\",{\"1\":{\"149\":3}}],[\"p2\",{\"1\":{\"149\":1,\"152\":3}}],[\"p1\",{\"1\":{\"149\":1}}],[\"ptr\",{\"1\":{\"135\":4,\"140\":3}}],[\"proceeding\",{\"1\":{\"236\":1}}],[\"process\",{\"0\":{\"209\":1}}],[\"processing\",{\"1\":{\"186\":1,\"189\":1}}],[\"producing\",{\"1\":{\"189\":1}}],[\"producer\",{\"0\":{\"189\":1},\"1\":{\"189\":3}}],[\"product\",{\"1\":{\"130\":1}}],[\"primitives\",{\"1\":{\"234\":1}}],[\"primary\",{\"1\":{\"154\":1}}],[\"priorityqueue\",{\"1\":{\"24\":7}}],[\"priority\",{\"1\":{\"24\":7}}],[\"println\",{\"1\":{\"13\":1,\"23\":3,\"25\":5,\"27\":4,\"30\":2,\"32\":1,\"36\":4,\"39\":1,\"40\":1,\"45\":1,\"47\":2,\"49\":1,\"50\":1,\"52\":1,\"54\":2,\"56\":2,\"61\":2,\"62\":8,\"67\":13,\"68\":6,\"72\":4,\"88\":2,\"89\":1,\"99\":2,\"100\":1,\"101\":6,\"105\":1,\"106\":2,\"107\":2,\"108\":1,\"109\":2,\"116\":3,\"120\":10,\"121\":3,\"122\":1,\"123\":3,\"126\":2,\"127\":1,\"140\":2,\"150\":6,\"152\":3,\"155\":6,\"163\":4,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"179\":1,\"180\":1,\"181\":2,\"184\":1,\"185\":1,\"187\":1,\"188\":2,\"194\":2,\"195\":2,\"196\":2,\"197\":4,\"206\":1,\"207\":1,\"219\":1,\"220\":2,\"221\":1,\"222\":2,\"223\":1,\"229\":2,\"230\":2,\"231\":2,\"235\":1,\"236\":1,\"238\":2,\"239\":1,\"240\":1}}],[\"printf\",{\"1\":{\"9\":4,\"13\":1,\"24\":1,\"36\":3,\"37\":2,\"38\":1,\"46\":1,\"50\":1,\"52\":1,\"54\":2,\"55\":2,\"56\":1,\"115\":1,\"120\":1,\"121\":1,\"122\":3,\"126\":1,\"127\":1,\"128\":2,\"141\":2,\"142\":2,\"151\":2,\"152\":1,\"156\":8,\"184\":2,\"186\":1,\"189\":2,\"197\":1,\"207\":2,\"237\":2,\"239\":1}}],[\"print\",{\"1\":{\"9\":1,\"36\":4,\"38\":1,\"105\":3}}],[\"private\",{\"1\":{\"9\":5}}],[\"privatebytes\",{\"1\":{\"9\":2}}],[\"pool\",{\"0\":{\"184\":1}}],[\"pointer2\",{\"1\":{\"144\":2}}],[\"pointer1\",{\"1\":{\"144\":4}}],[\"pointer\",{\"1\":{\"138\":1,\"139\":2,\"142\":1,\"143\":2}}],[\"post\",{\"1\":{\"121\":3}}],[\"positive\",{\"1\":{\"120\":1}}],[\"pop\",{\"1\":{\"24\":2}}],[\"pkg\",{\"1\":{\"89\":1}}],[\"people\",{\"1\":{\"50\":3,\"52\":5}}],[\"perimeter\",{\"1\":{\"112\":1,\"113\":1}}],[\"perm\",{\"1\":{\"44\":2}}],[\"personarr\",{\"1\":{\"135\":1}}],[\"person\",{\"1\":{\"39\":3,\"50\":3,\"52\":4,\"135\":6,\"149\":11,\"150\":20,\"151\":29,\"152\":3,\"160\":3}}],[\"ppid\",{\"1\":{\"46\":3}}],[\"p\",{\"1\":{\"37\":1,\"39\":5,\"50\":3,\"52\":3,\"142\":6,\"152\":2,\"160\":4,\"189\":3}}],[\"pushfront\",{\"1\":{\"25\":1,\"26\":1}}],[\"push\",{\"1\":{\"24\":2}}],[\"pushback\",{\"1\":{\"23\":2,\"25\":3,\"26\":1}}],[\"pq\",{\"1\":{\"24\":24}}],[\"pipeline\",{\"0\":{\"187\":1}}],[\"pike\",{\"1\":{\"75\":1}}],[\"pid\",{\"1\":{\"46\":3}}],[\"pi\",{\"1\":{\"18\":1}}],[\"panic\",{\"1\":{\"179\":1}}],[\"parsing\",{\"1\":{\"56\":1}}],[\"parseint\",{\"1\":{\"56\":1}}],[\"parsefloat\",{\"1\":{\"54\":2,\"56\":1}}],[\"parse\",{\"1\":{\"9\":1,\"13\":1,\"18\":1,\"30\":3,\"32\":1}}],[\"parseprivatekey\",{\"1\":{\"9\":1}}],[\"payload\",{\"1\":{\"9\":1}}],[\"path\",{\"1\":{\"9\":1,\"44\":4}}],[\"password\",{\"1\":{\"8\":2}}],[\"package\",{\"1\":{\"8\":1,\"9\":1,\"23\":1,\"24\":1,\"25\":1,\"27\":1,\"30\":1,\"32\":1,\"44\":1,\"52\":1,\"54\":2,\"55\":2,\"56\":2,\"72\":1,\"121\":4,\"123\":1,\"127\":1,\"128\":1,\"152\":1,\"155\":4,\"156\":2,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"180\":1,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":2,\"206\":1,\"207\":1,\"219\":1,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"229\":1,\"230\":1,\"231\":1,\"235\":1,\"236\":1,\"237\":1,\"238\":1,\"239\":1,\"240\":1}}],[\"linux\",{\"1\":{\"76\":1}}],[\"list\",{\"0\":{\"25\":1},\"1\":{\"14\":1,\"23\":4,\"25\":6,\"26\":2,\"106\":5}}],[\"listening\",{\"1\":{\"9\":1}}],[\"listen\",{\"1\":{\"9\":2,\"16\":1}}],[\"listener\",{\"1\":{\"9\":2}}],[\"last\",{\"1\":{\"25\":1}}],[\"leftshift\",{\"1\":{\"133\":1}}],[\"less\",{\"1\":{\"24\":1,\"50\":2,\"52\":1}}],[\"len\",{\"1\":{\"9\":1,\"24\":5,\"27\":1,\"50\":3,\"52\":2,\"61\":1,\"67\":1,\"68\":3,\"108\":1,\"126\":2}}],[\"locks\",{\"0\":{\"235\":1}}],[\"lock\",{\"1\":{\"168\":2,\"219\":1,\"220\":1,\"223\":3,\"235\":1,\"236\":2}}],[\"localhost\",{\"1\":{\"45\":1}}],[\"loadint32\",{\"1\":{\"240\":1}}],[\"load\",{\"1\":{\"9\":1,\"127\":1}}],[\"logger\",{\"1\":{\"155\":4}}],[\"log\",{\"1\":{\"8\":4,\"9\":9,\"19\":1,\"44\":7,\"45\":1,\"47\":3,\"155\":3}}],[\"l\",{\"1\":{\"8\":1,\"106\":5}}],[\"ls\",{\"1\":{\"8\":1}}],[\"duration\",{\"1\":{\"188\":1}}],[\"deadline\",{\"1\":{\"196\":3}}],[\"delete\",{\"1\":{\"126\":2}}],[\"describe\",{\"1\":{\"115\":4}}],[\"default\",{\"1\":{\"33\":2,\"120\":5,\"123\":6,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"227\":1,\"231\":3,\"232\":1}}],[\"defer\",{\"1\":{\"8\":1,\"9\":2,\"44\":2,\"99\":3,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"184\":1,\"186\":1,\"189\":2,\"195\":1,\"196\":1,\"197\":1,\"207\":1,\"219\":1,\"220\":3,\"221\":1,\"223\":3,\"235\":2,\"236\":1,\"239\":1}}],[\"dl\",{\"1\":{\"80\":1}}],[\"dave\",{\"1\":{\"149\":1}}],[\"david\",{\"1\":{\"25\":1,\"126\":3}}],[\"day\",{\"1\":{\"120\":1}}],[\"dataslice\",{\"1\":{\"68\":12}}],[\"data\",{\"1\":{\"68\":1,\"231\":1}}],[\"data3\",{\"1\":{\"61\":1}}],[\"data2\",{\"1\":{\"61\":1}}],[\"data1\",{\"1\":{\"61\":1}}],[\"datatype4\",{\"1\":{\"148\":1}}],[\"datatype3\",{\"1\":{\"148\":1}}],[\"datatype2\",{\"1\":{\"148\":1}}],[\"datatype1\",{\"1\":{\"148\":2}}],[\"datatype\",{\"1\":{\"60\":1,\"61\":2,\"148\":1}}],[\"db\",{\"1\":{\"45\":1}}],[\"dowork\",{\"1\":{\"194\":2,\"195\":2,\"196\":2,\"197\":4}}],[\"done\",{\"1\":{\"155\":3,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"184\":1,\"185\":1,\"186\":1,\"189\":2,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"207\":4,\"219\":1,\"220\":2,\"221\":1,\"222\":6,\"223\":2,\"235\":1,\"236\":1,\"237\":1,\"238\":6,\"239\":2}}],[\"doubled\",{\"1\":{\"187\":2}}],[\"doubler\",{\"1\":{\"187\":2}}],[\"double\",{\"1\":{\"96\":2,\"101\":10}}],[\"dosomething\",{\"1\":{\"89\":2,\"193\":2}}],[\"doc\",{\"1\":{\"80\":1}}],[\"docker\",{\"1\":{\"77\":1}}],[\"do\",{\"1\":{\"27\":2,\"28\":1,\"89\":1}}],[\"d\",{\"1\":{\"24\":1,\"27\":1,\"36\":1,\"37\":2,\"39\":1,\"46\":2,\"50\":1,\"52\":1,\"54\":1,\"56\":1,\"121\":2,\"122\":4,\"126\":1,\"127\":1,\"141\":4,\"142\":3,\"151\":2,\"156\":8,\"184\":4,\"186\":2,\"188\":1,\"189\":4,\"207\":2,\"237\":2,\"239\":1}}],[\"diff\",{\"1\":{\"130\":1}}],[\"division\",{\"1\":{\"100\":1}}],[\"divide\",{\"1\":{\"93\":2,\"100\":2}}],[\"dir\",{\"1\":{\"47\":2}}],[\"directory\",{\"1\":{\"45\":1,\"47\":1}}],[\"discardrequests\",{\"1\":{\"9\":1}}],[\"dial\",{\"1\":{\"8\":2,\"16\":1}}],[\"n3\",{\"1\":{\"162\":1}}],[\"n2\",{\"1\":{\"162\":1}}],[\"n1\",{\"1\":{\"162\":1}}],[\"numworkers\",{\"1\":{\"184\":2,\"239\":3}}],[\"numjobs\",{\"1\":{\"184\":4}}],[\"numbers\",{\"1\":{\"121\":3}}],[\"number\",{\"1\":{\"109\":2,\"128\":3}}],[\"nums\",{\"1\":{\"94\":2,\"122\":2,\"187\":4}}],[\"num\",{\"1\":{\"54\":4,\"55\":4,\"56\":2,\"94\":2,\"122\":2,\"139\":3,\"140\":2,\"144\":3}}],[\"nan\",{\"1\":{\"128\":18}}],[\"name\",{\"1\":{\"30\":8,\"31\":5,\"32\":1,\"33\":2,\"36\":4,\"37\":4,\"38\":4,\"39\":2,\"44\":4,\"47\":1,\"50\":2,\"52\":5,\"86\":1,\"126\":2,\"135\":4,\"149\":5,\"150\":11,\"151\":14,\"152\":6,\"153\":2,\"154\":2,\"160\":1,\"161\":4,\"162\":1,\"188\":2}}],[\"nafter\",{\"1\":{\"27\":1}}],[\"n\",{\"1\":{\"24\":3,\"28\":4,\"33\":5,\"36\":1,\"37\":1,\"38\":1,\"46\":1,\"50\":1,\"52\":1,\"54\":2,\"55\":2,\"56\":1,\"67\":6,\"97\":4,\"115\":1,\"120\":1,\"121\":1,\"122\":3,\"126\":1,\"127\":1,\"128\":2,\"142\":2,\"152\":1,\"156\":8,\"160\":2,\"170\":2,\"184\":2,\"185\":4,\"186\":1,\"187\":9,\"189\":2,\"197\":1,\"207\":2,\"237\":2,\"239\":1}}],[\"no\",{\"1\":{\"123\":1,\"231\":1}}],[\"nor\",{\"1\":{\"120\":1}}],[\"non\",{\"1\":{\"32\":1}}],[\"node\",{\"1\":{\"27\":1}}],[\"now\",{\"1\":{\"18\":1,\"196\":1}}],[\"notes\",{\"1\":{\"149\":1,\"150\":5,\"151\":5}}],[\"notresult\",{\"1\":{\"132\":1}}],[\"not\",{\"1\":{\"9\":1,\"126\":1,\"128\":3,\"197\":1,\"242\":1}}],[\"noclientauth\",{\"1\":{\"9\":1}}],[\"neither\",{\"1\":{\"120\":1}}],[\"negative\",{\"1\":{\"120\":1}}],[\"next\",{\"1\":{\"23\":1,\"25\":3,\"26\":1,\"27\":1}}],[\"newcond\",{\"1\":{\"236\":1}}],[\"newchannel\",{\"1\":{\"9\":4}}],[\"newperson\",{\"1\":{\"149\":1}}],[\"newpath\",{\"1\":{\"44\":1}}],[\"newwriter\",{\"1\":{\"19\":1}}],[\"newreader\",{\"1\":{\"19\":1}}],[\"new\",{\"1\":{\"9\":1,\"23\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"66\":1,\"87\":2,\"89\":1,\"149\":5,\"150\":1,\"151\":1}}],[\"newserverconn\",{\"1\":{\"9\":1}}],[\"newsession\",{\"1\":{\"8\":1}}],[\"net\",{\"1\":{\"9\":3,\"16\":3}}],[\"nil\",{\"1\":{\"8\":3,\"9\":8,\"23\":2,\"25\":2,\"40\":1,\"44\":6,\"45\":1,\"47\":3,\"54\":2,\"56\":2,\"66\":1,\"86\":2,\"88\":3,\"89\":1,\"100\":2,\"126\":1,\"143\":3,\"152\":2}}],[\"vs\",{\"0\":{\"176\":1}}],[\"vscode\",{\"0\":{\"82\":1},\"1\":{\"81\":1,\"82\":1,\"83\":5}}],[\"visualstudio\",{\"1\":{\"82\":1}}],[\"val2\",{\"1\":{\"227\":1}}],[\"val1\",{\"1\":{\"227\":1}}],[\"val\",{\"1\":{\"128\":4,\"180\":2,\"206\":2}}],[\"value2\",{\"1\":{\"120\":2}}],[\"value1\",{\"1\":{\"120\":2}}],[\"values\",{\"1\":{\"61\":1}}],[\"value\",{\"1\":{\"23\":2,\"24\":5,\"25\":3,\"26\":2,\"27\":5,\"28\":1,\"45\":3,\"121\":5,\"122\":6,\"125\":1,\"127\":2,\"128\":4,\"175\":1,\"177\":1,\"179\":1,\"197\":5,\"204\":1,\"223\":4}}],[\"variables\",{\"0\":{\"236\":1}}],[\"variablename\",{\"1\":{\"161\":1}}],[\"variablename4\",{\"1\":{\"148\":2}}],[\"variablename3\",{\"1\":{\"148\":2}}],[\"variablename2\",{\"1\":{\"148\":2,\"161\":2}}],[\"variablename1\",{\"1\":{\"148\":2,\"161\":2}}],[\"var\",{\"1\":{\"30\":2,\"38\":1,\"60\":1,\"61\":4,\"62\":2,\"65\":1,\"66\":2,\"70\":1,\"71\":1,\"101\":9,\"109\":1,\"114\":1,\"120\":1,\"125\":1,\"127\":1,\"135\":6,\"138\":1,\"139\":1,\"141\":1,\"143\":1,\"144\":2,\"151\":1,\"152\":1,\"155\":1,\"156\":2,\"160\":9,\"161\":6,\"167\":2,\"168\":2,\"169\":2,\"170\":1,\"184\":1,\"185\":1,\"186\":1,\"189\":1,\"207\":1,\"219\":2,\"220\":2,\"221\":2,\"223\":2,\"235\":2,\"236\":2,\"239\":1,\"240\":1}}],[\"v\",{\"1\":{\"8\":3,\"9\":6,\"37\":2,\"105\":2,\"108\":2,\"109\":2,\"115\":1,\"120\":4,\"128\":4,\"160\":1}}],[\"task\",{\"1\":{\"197\":1}}],[\"taskid\",{\"1\":{\"197\":4}}],[\"thread\",{\"0\":{\"210\":1}}],[\"three\",{\"1\":{\"108\":2}}],[\"this\",{\"1\":{\"152\":1}}],[\"third\",{\"1\":{\"142\":1}}],[\"the\",{\"1\":{\"126\":1,\"155\":1}}],[\"thompson\",{\"1\":{\"75\":1}}],[\"two\",{\"1\":{\"108\":2}}],[\"tmp\",{\"1\":{\"47\":1,\"141\":2}}],[\"txt\",{\"1\":{\"44\":3}}],[\"test\",{\"1\":{\"44\":3}}],[\"t\",{\"1\":{\"37\":2,\"105\":3,\"106\":6,\"107\":3,\"109\":4,\"115\":1,\"120\":1,\"160\":5}}],[\"timeout\",{\"1\":{\"230\":1}}],[\"timed\",{\"1\":{\"195\":1,\"197\":1}}],[\"time\",{\"1\":{\"18\":3,\"123\":6,\"155\":3,\"180\":3,\"181\":4,\"184\":3,\"185\":3,\"186\":3,\"187\":1,\"188\":5,\"189\":5,\"194\":7,\"195\":6,\"196\":7,\"197\":6,\"206\":3,\"207\":2,\"227\":2,\"229\":5,\"230\":5,\"237\":5}}],[\"type\",{\"1\":{\"9\":2,\"24\":2,\"39\":1,\"50\":2,\"52\":2,\"67\":3,\"68\":1,\"85\":1,\"101\":3,\"106\":1,\"107\":1,\"109\":1,\"112\":2,\"113\":1,\"117\":3,\"120\":2,\"135\":1,\"148\":3,\"149\":1,\"151\":2,\"152\":1,\"154\":1,\"155\":3,\"156\":3,\"160\":2,\"161\":4}}],[\"true\",{\"1\":{\"9\":2,\"115\":1,\"119\":4,\"120\":1,\"127\":1,\"128\":1,\"131\":2,\"132\":2,\"222\":1,\"236\":1,\"238\":1}}],[\"todo\",{\"1\":{\"192\":1}}],[\"total\",{\"1\":{\"94\":5}}],[\"too\",{\"1\":{\"61\":1}}],[\"to\",{\"1\":{\"8\":3,\"9\":6,\"44\":2,\"89\":1}}],[\"tcp\",{\"1\":{\"8\":1,\"9\":1,\"16\":1}}],[\"final\",{\"1\":{\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"219\":1,\"220\":1,\"221\":1,\"235\":1,\"240\":1}}],[\"finished\",{\"1\":{\"155\":1,\"184\":1}}],[\"fieldname\",{\"1\":{\"150\":1}}],[\"filemode\",{\"1\":{\"44\":2}}],[\"file\",{\"1\":{\"44\":6,\"86\":1}}],[\"fn\",{\"1\":{\"98\":2}}],[\"floats\",{\"1\":{\"109\":2}}],[\"float64\",{\"1\":{\"109\":2,\"112\":2,\"113\":3,\"128\":2,\"159\":1}}],[\"float64s\",{\"1\":{\"49\":1}}],[\"float32\",{\"1\":{\"104\":3,\"109\":1,\"159\":1}}],[\"float\",{\"1\":{\"54\":2}}],[\"flag\",{\"0\":{\"29\":1},\"1\":{\"13\":3,\"19\":1,\"29\":2,\"30\":8,\"31\":4,\"32\":6,\"33\":2,\"34\":1}}],[\"fprintln\",{\"1\":{\"41\":1}}],[\"fprint\",{\"1\":{\"41\":1}}],[\"fprintf\",{\"1\":{\"33\":5,\"41\":1}}],[\"f\",{\"1\":{\"37\":1,\"54\":1,\"55\":1}}],[\"found\",{\"1\":{\"197\":1,\"242\":1}}],[\"foo\",{\"1\":{\"24\":2}}],[\"formatfloat\",{\"1\":{\"55\":2}}],[\"formatint\",{\"1\":{\"14\":1}}],[\"forward\",{\"1\":{\"25\":1}}],[\"for\",{\"0\":{\"121\":1},\"1\":{\"9\":4,\"23\":1,\"24\":2,\"25\":2,\"26\":1,\"27\":1,\"28\":2,\"50\":1,\"52\":1,\"94\":1,\"105\":1,\"108\":1,\"109\":1,\"121\":17,\"122\":4,\"123\":1,\"126\":1,\"142\":1,\"155\":1,\"167\":2,\"168\":2,\"169\":2,\"170\":3,\"180\":2,\"181\":1,\"184\":4,\"185\":4,\"186\":3,\"187\":4,\"188\":2,\"189\":4,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"206\":2,\"207\":1,\"219\":1,\"220\":2,\"221\":1,\"229\":1,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"240\":1}}],[\"front\",{\"1\":{\"23\":8,\"25\":3,\"26\":1}}],[\"from\",{\"1\":{\"9\":1,\"123\":3,\"197\":1}}],[\"fmt\",{\"0\":{\"35\":1},\"1\":{\"13\":3,\"23\":4,\"24\":2,\"25\":6,\"27\":6,\"30\":3,\"32\":2,\"33\":5,\"35\":2,\"36\":11,\"37\":1,\"38\":4,\"39\":2,\"40\":4,\"41\":4,\"42\":1,\"45\":1,\"46\":1,\"47\":2,\"49\":1,\"50\":2,\"52\":3,\"54\":6,\"55\":4,\"56\":5,\"61\":2,\"62\":8,\"67\":13,\"68\":6,\"72\":5,\"88\":2,\"89\":1,\"99\":2,\"100\":2,\"101\":6,\"105\":1,\"106\":2,\"107\":2,\"108\":1,\"109\":2,\"115\":1,\"116\":3,\"120\":11,\"121\":8,\"122\":4,\"123\":4,\"126\":3,\"127\":3,\"128\":3,\"140\":2,\"141\":2,\"150\":6,\"151\":2,\"152\":5,\"155\":10,\"156\":10,\"163\":4,\"167\":2,\"168\":2,\"169\":2,\"170\":2,\"179\":1,\"180\":2,\"181\":2,\"184\":4,\"185\":2,\"186\":2,\"187\":2,\"188\":4,\"189\":3,\"194\":3,\"195\":3,\"196\":3,\"197\":7,\"206\":2,\"207\":4,\"219\":2,\"220\":3,\"221\":2,\"222\":3,\"223\":2,\"229\":3,\"230\":3,\"231\":3,\"235\":2,\"236\":2,\"237\":3,\"238\":3,\"239\":3,\"240\":2}}],[\"fanin\",{\"1\":{\"185\":3}}],[\"fan\",{\"0\":{\"185\":1,\"186\":1}}],[\"factorial\",{\"1\":{\"97\":3}}],[\"factor\",{\"1\":{\"96\":2}}],[\"fatal\",{\"1\":{\"44\":6,\"45\":1,\"47\":3}}],[\"fatalf\",{\"1\":{\"8\":3,\"9\":3}}],[\"false\",{\"1\":{\"9\":1,\"119\":2,\"121\":1,\"128\":2,\"131\":2,\"132\":3,\"236\":1}}],[\"failed\",{\"1\":{\"8\":3,\"9\":5,\"89\":1,\"116\":1}}],[\"func\",{\"1\":{\"8\":1,\"9\":3,\"23\":1,\"24\":6,\"25\":1,\"27\":3,\"28\":1,\"30\":1,\"32\":1,\"33\":1,\"39\":2,\"40\":2,\"44\":8,\"45\":3,\"46\":3,\"47\":3,\"49\":1,\"50\":4,\"52\":4,\"54\":2,\"55\":2,\"56\":2,\"67\":1,\"68\":3,\"72\":3,\"86\":1,\"87\":1,\"89\":2,\"92\":2,\"93\":3,\"94\":1,\"95\":1,\"96\":3,\"97\":1,\"98\":5,\"99\":1,\"100\":1,\"101\":6,\"104\":2,\"105\":1,\"106\":2,\"107\":1,\"108\":1,\"109\":1,\"113\":2,\"115\":1,\"121\":4,\"122\":1,\"123\":3,\"127\":2,\"128\":1,\"141\":2,\"149\":1,\"151\":6,\"152\":1,\"155\":6,\"156\":2,\"160\":2,\"167\":2,\"168\":2,\"169\":2,\"170\":3,\"177\":1,\"180\":2,\"181\":3,\"184\":2,\"185\":5,\"186\":2,\"187\":7,\"188\":3,\"189\":3,\"193\":2,\"194\":2,\"195\":2,\"196\":2,\"197\":4,\"206\":2,\"207\":2,\"219\":3,\"220\":5,\"221\":3,\"222\":2,\"223\":3,\"229\":3,\"230\":2,\"231\":1,\"235\":3,\"236\":4,\"237\":2,\"238\":2,\"239\":2,\"240\":2}}],[\"squared\",{\"1\":{\"187\":2}}],[\"squarer\",{\"1\":{\"187\":2}}],[\"safety\",{\"0\":{\"165\":1},\"1\":{\"164\":1}}],[\"saturday\",{\"1\":{\"120\":1}}],[\"signal\",{\"1\":{\"236\":1}}],[\"signalcondition\",{\"1\":{\"236\":3}}],[\"size\",{\"1\":{\"156\":4}}],[\"sizeof\",{\"1\":{\"155\":1,\"156\":2}}],[\"sin\",{\"1\":{\"18\":1}}],[\"sleep\",{\"1\":{\"123\":2,\"155\":1,\"180\":1,\"181\":2,\"184\":1,\"185\":1,\"186\":1,\"188\":1,\"189\":2,\"194\":3,\"195\":2,\"196\":2,\"197\":2,\"206\":1,\"207\":1,\"229\":2,\"230\":1,\"237\":2}}],[\"sliceheader\",{\"1\":{\"68\":1}}],[\"slice\",{\"0\":{\"22\":1},\"1\":{\"65\":1,\"66\":6,\"67\":39,\"68\":13,\"69\":1,\"71\":2,\"72\":6,\"122\":1,\"160\":1}}],[\"sunday\",{\"1\":{\"120\":1}}],[\"sum\",{\"1\":{\"94\":2,\"104\":2,\"109\":6,\"121\":5,\"130\":1}}],[\"syntax\",{\"1\":{\"56\":1}}],[\"sync\",{\"1\":{\"15\":3,\"127\":5,\"167\":3,\"168\":4,\"169\":4,\"170\":3,\"184\":3,\"185\":1,\"186\":3,\"189\":4,\"207\":5,\"214\":2,\"219\":3,\"220\":3,\"221\":3,\"223\":5,\"235\":3,\"236\":4,\"239\":4,\"240\":2}}],[\"something\",{\"1\":{\"40\":1,\"87\":2,\"89\":2}}],[\"somefunction\",{\"1\":{\"40\":2,\"87\":1,\"88\":1}}],[\"sorted\",{\"1\":{\"50\":1,\"52\":1}}],[\"sort\",{\"1\":{\"14\":1,\"48\":2,\"49\":5,\"50\":3,\"52\":12}}],[\"scan\",{\"1\":{\"38\":2}}],[\"sprintf\",{\"1\":{\"27\":1,\"39\":1,\"41\":1,\"188\":1}}],[\"switah\",{\"1\":{\"120\":1}}],[\"switch\",{\"0\":{\"120\":1},\"1\":{\"9\":1,\"120\":14,\"123\":1,\"181\":1}}],[\"swap\",{\"1\":{\"24\":1,\"50\":2,\"52\":1,\"141\":2}}],[\"shape\",{\"1\":{\"112\":1,\"114\":1}}],[\"sha256\",{\"1\":{\"18\":1}}],[\"shell\",{\"1\":{\"9\":1}}],[\"starting\",{\"1\":{\"207\":1}}],[\"start\",{\"1\":{\"185\":2}}],[\"started\",{\"1\":{\"155\":2,\"184\":1,\"197\":1}}],[\"store\",{\"1\":{\"127\":2}}],[\"stice\",{\"1\":{\"67\":1}}],[\"str\",{\"1\":{\"54\":4,\"55\":4,\"56\":4,\"122\":2}}],[\"stringlist\",{\"1\":{\"106\":4}}],[\"strings\",{\"1\":{\"49\":1,\"105\":2}}],[\"string\",{\"1\":{\"24\":1,\"30\":1,\"33\":1,\"38\":1,\"39\":4,\"44\":7,\"45\":4,\"47\":3,\"50\":1,\"52\":1,\"55\":4,\"85\":2,\"86\":1,\"105\":1,\"106\":1,\"108\":1,\"120\":2,\"122\":2,\"123\":2,\"125\":2,\"126\":1,\"128\":2,\"135\":1,\"149\":1,\"151\":2,\"152\":4,\"154\":1,\"155\":2,\"159\":1,\"160\":3,\"161\":1,\"188\":3,\"197\":2}}],[\"stringvar\",{\"1\":{\"13\":1,\"30\":2,\"31\":2}}],[\"structname\",{\"1\":{\"148\":2,\"150\":1}}],[\"struct\",{\"1\":{\"24\":1,\"39\":1,\"50\":1,\"52\":1,\"68\":1,\"101\":1,\"106\":1,\"113\":1,\"135\":1,\"148\":3,\"149\":1,\"151\":2,\"152\":1,\"154\":1,\"155\":9,\"156\":3,\"160\":2,\"237\":3}}],[\"strconv\",{\"0\":{\"53\":1},\"1\":{\"14\":3,\"53\":2,\"54\":4,\"55\":4,\"56\":5,\"57\":2}}],[\"stderr\",{\"1\":{\"8\":2,\"33\":5}}],[\"stdout\",{\"1\":{\"8\":2}}],[\"s\",{\"1\":{\"9\":2,\"24\":1,\"33\":1,\"36\":1,\"37\":2,\"38\":1,\"39\":1,\"50\":1,\"52\":1,\"55\":2,\"105\":2,\"109\":2,\"114\":2,\"116\":2,\"122\":1,\"126\":2,\"127\":2,\"151\":2,\"156\":10,\"188\":1,\"197\":1}}],[\"sem\",{\"1\":{\"237\":5}}],[\"semaphores\",{\"0\":{\"237\":1}}],[\"send\",{\"1\":{\"173\":1}}],[\"second\",{\"1\":{\"123\":2,\"155\":1,\"180\":1,\"181\":2,\"184\":1,\"186\":1,\"188\":2,\"189\":1,\"194\":2,\"195\":2,\"196\":2,\"197\":2,\"206\":1,\"207\":1,\"227\":1,\"229\":2,\"230\":2,\"237\":2}}],[\"secondelement\",{\"1\":{\"25\":2}}],[\"select\",{\"0\":{\"123\":1,\"181\":1,\"226\":1},\"1\":{\"123\":13,\"181\":3,\"188\":2,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"226\":3,\"227\":1,\"228\":1,\"229\":2,\"230\":2,\"231\":2,\"232\":3,\"233\":2}}],[\"set\",{\"1\":{\"102\":1,\"155\":1}}],[\"setenv\",{\"1\":{\"45\":2}}],[\"search\",{\"1\":{\"52\":1}}],[\"session\",{\"1\":{\"8\":6,\"9\":1}}],[\"serverconfig\",{\"1\":{\"9\":2}}],[\"server\",{\"1\":{\"8\":1,\"155\":5}}],[\"sshconn\",{\"1\":{\"9\":4}}],[\"ssh\",{\"0\":{\"4\":1},\"1\":{\"5\":3,\"6\":2,\"8\":9,\"9\":12,\"10\":2,\"11\":1}}],[\"ipc\",{\"1\":{\"209\":1}}],[\"identifier\",{\"1\":{\"161\":1}}],[\"id\",{\"1\":{\"154\":1,\"184\":3,\"186\":2,\"189\":4,\"197\":1,\"207\":3,\"237\":3,\"239\":2}}],[\"ignored\",{\"1\":{\"152\":1}}],[\"ignore\",{\"1\":{\"152\":3}}],[\"isfalse\",{\"1\":{\"132\":3}}],[\"istrue\",{\"1\":{\"132\":4}}],[\"isgreaterorequal\",{\"1\":{\"131\":1}}],[\"isless\",{\"1\":{\"131\":1}}],[\"isnotequal\",{\"1\":{\"131\":1}}],[\"isequal\",{\"1\":{\"131\":1}}],[\"is\",{\"1\":{\"120\":9,\"126\":3,\"127\":1,\"155\":1,\"237\":2,\"238\":2,\"239\":1}}],[\"itoa\",{\"1\":{\"55\":2}}],[\"items\",{\"1\":{\"24\":2,\"106\":4}}],[\"item\",{\"1\":{\"24\":16,\"106\":2}}],[\"i++\",{\"1\":{\"27\":1,\"121\":1,\"167\":2,\"168\":2,\"169\":2,\"170\":2,\"180\":1,\"181\":1,\"185\":1,\"188\":2,\"206\":1,\"207\":1,\"219\":1,\"220\":2,\"221\":1,\"229\":1,\"235\":1,\"237\":1,\"239\":1,\"240\":1}}],[\"i\",{\"1\":{\"24\":7,\"27\":3,\"50\":7,\"52\":5,\"67\":2,\"115\":3,\"120\":6,\"121\":3,\"135\":3,\"141\":3,\"142\":3,\"160\":5,\"163\":2,\"167\":4,\"168\":4,\"169\":4,\"170\":4,\"180\":3,\"181\":2,\"185\":3,\"188\":4,\"206\":3,\"207\":3,\"211\":1,\"212\":2,\"219\":2,\"220\":4,\"221\":2,\"229\":2,\"235\":2,\"237\":3,\"239\":3,\"240\":2}}],[\"increment\",{\"1\":{\"167\":2,\"168\":2,\"169\":2,\"170\":2,\"219\":2,\"221\":2,\"235\":4}}],[\"include\",{\"1\":{\"142\":1}}],[\"incoming\",{\"1\":{\"9\":1}}],[\"install\",{\"1\":{\"80\":1}}],[\"insecureignorehostkey\",{\"1\":{\"8\":1}}],[\"in\",{\"0\":{\"185\":1},\"1\":{\"61\":1,\"126\":1,\"155\":1,\"187\":4,\"197\":1}}],[\"invalid\",{\"1\":{\"56\":1}}],[\"initialization\",{\"1\":{\"121\":3}}],[\"initializer\",{\"1\":{\"61\":1}}],[\"init\",{\"1\":{\"24\":1}}],[\"index\",{\"1\":{\"24\":5,\"106\":2,\"121\":5,\"122\":6}}],[\"intlist\",{\"1\":{\"106\":4}}],[\"int64\",{\"1\":{\"104\":1,\"109\":1,\"156\":5,\"159\":1}}],[\"int32\",{\"1\":{\"104\":1,\"109\":1,\"156\":5,\"159\":1,\"169\":1,\"221\":1,\"240\":2}}],[\"int16\",{\"1\":{\"104\":1,\"159\":1}}],[\"int8\",{\"1\":{\"104\":1,\"159\":1}}],[\"interval\",{\"1\":{\"188\":2}}],[\"interface\",{\"1\":{\"24\":4,\"26\":2,\"27\":2,\"28\":1,\"50\":1,\"52\":1,\"85\":1,\"107\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":2,\"115\":2,\"117\":3,\"120\":1,\"127\":1}}],[\"integer\",{\"1\":{\"54\":2,\"56\":2}}],[\"ints\",{\"1\":{\"49\":5,\"105\":2,\"109\":2}}],[\"intvar\",{\"1\":{\"30\":2,\"31\":2}}],[\"int\",{\"1\":{\"24\":5,\"28\":2,\"30\":1,\"33\":1,\"39\":1,\"46\":3,\"49\":1,\"50\":6,\"52\":4,\"61\":4,\"62\":2,\"65\":1,\"66\":5,\"67\":5,\"68\":8,\"70\":2,\"71\":2,\"72\":3,\"92\":6,\"93\":8,\"94\":2,\"95\":2,\"96\":5,\"97\":2,\"98\":11,\"100\":2,\"101\":22,\"104\":3,\"105\":1,\"106\":2,\"108\":1,\"109\":2,\"117\":1,\"120\":2,\"121\":1,\"122\":3,\"125\":2,\"126\":1,\"128\":1,\"135\":4,\"138\":1,\"141\":2,\"142\":4,\"143\":1,\"149\":1,\"151\":2,\"152\":1,\"154\":2,\"159\":1,\"160\":18,\"167\":1,\"168\":1,\"170\":2,\"174\":2,\"177\":1,\"178\":1,\"180\":2,\"181\":2,\"184\":5,\"185\":9,\"186\":3,\"187\":9,\"189\":5,\"203\":1,\"205\":1,\"206\":2,\"207\":1,\"219\":1,\"220\":2,\"223\":1,\"229\":2,\"230\":1,\"231\":1,\"235\":1,\"237\":1,\"239\":1}}],[\"iota\",{\"0\":{\"163\":1},\"1\":{\"163\":8}}],[\"io\",{\"1\":{\"9\":2,\"16\":4,\"19\":2,\"41\":1}}],[\"if\",{\"0\":{\"119\":1},\"1\":{\"8\":3,\"9\":8,\"23\":1,\"40\":1,\"44\":6,\"45\":1,\"47\":3,\"54\":2,\"56\":2,\"88\":2,\"89\":1,\"97\":1,\"100\":2,\"107\":1,\"116\":1,\"119\":11,\"120\":1,\"121\":1,\"126\":1,\"127\":1,\"143\":1,\"152\":2,\"155\":1,\"179\":1,\"197\":2}}],[\"import\",{\"1\":{\"8\":1,\"9\":1,\"23\":1,\"24\":1,\"25\":1,\"27\":1,\"30\":1,\"32\":1,\"40\":1,\"44\":1,\"49\":1,\"52\":1,\"54\":2,\"55\":2,\"56\":2,\"72\":1,\"87\":1,\"89\":1,\"121\":4,\"123\":1,\"127\":1,\"128\":1,\"152\":1,\"155\":4,\"156\":2,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"180\":1,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":2,\"206\":1,\"207\":1,\"219\":1,\"220\":1,\"221\":1,\"222\":1,\"223\":1,\"229\":1,\"230\":1,\"231\":1,\"235\":1,\"236\":1,\"237\":1,\"238\":1,\"239\":1,\"240\":1}}],[\"=操作的类型\",{\"1\":{\"107\":1}}],[\"==\",{\"1\":{\"9\":1,\"92\":1,\"93\":2,\"94\":1,\"95\":1,\"96\":1,\"97\":1,\"98\":2,\"100\":1,\"101\":1,\"126\":3,\"131\":2,\"136\":1,\"143\":1}}],[\"=\",{\"1\":{\"8\":9,\"9\":16,\"23\":6,\"24\":15,\"25\":8,\"27\":5,\"32\":1,\"33\":1,\"36\":2,\"37\":2,\"39\":1,\"40\":2,\"44\":12,\"45\":3,\"46\":2,\"47\":6,\"49\":1,\"50\":3,\"52\":3,\"54\":6,\"55\":4,\"56\":6,\"61\":4,\"62\":3,\"66\":4,\"67\":14,\"68\":6,\"70\":1,\"71\":1,\"72\":4,\"88\":3,\"89\":3,\"92\":1,\"93\":2,\"94\":3,\"95\":2,\"96\":2,\"97\":1,\"98\":3,\"100\":2,\"101\":13,\"105\":3,\"106\":3,\"108\":5,\"109\":3,\"114\":1,\"116\":2,\"120\":3,\"121\":6,\"122\":8,\"123\":4,\"125\":2,\"126\":6,\"127\":1,\"128\":6,\"130\":7,\"131\":8,\"132\":5,\"133\":7,\"134\":9,\"135\":5,\"136\":9,\"139\":2,\"140\":2,\"141\":5,\"142\":5,\"144\":3,\"149\":9,\"150\":7,\"151\":8,\"152\":6,\"155\":7,\"160\":10,\"161\":4,\"162\":4,\"163\":3,\"167\":2,\"168\":2,\"169\":2,\"170\":5,\"174\":1,\"175\":1,\"177\":2,\"178\":1,\"179\":1,\"180\":3,\"181\":5,\"184\":8,\"185\":8,\"186\":4,\"187\":10,\"188\":7,\"189\":5,\"192\":1,\"193\":1,\"194\":1,\"195\":1,\"196\":2,\"197\":7,\"203\":1,\"204\":1,\"205\":1,\"206\":3,\"207\":1,\"219\":1,\"220\":2,\"221\":1,\"222\":1,\"223\":1,\"227\":1,\"229\":5,\"230\":2,\"231\":2,\"235\":1,\"236\":3,\"237\":3,\"238\":1,\"239\":2,\"240\":2}}],[\"cpu\",{\"1\":{\"210\":1,\"217\":1}}],[\"ctx\",{\"1\":{\"192\":1,\"193\":3,\"194\":4,\"195\":4,\"196\":4,\"197\":11}}],[\"c2\",{\"1\":{\"185\":3,\"188\":2}}],[\"c1\",{\"1\":{\"185\":3,\"188\":2}}],[\"c语言\",{\"1\":{\"142\":1}}],[\"c++\",{\"1\":{\"90\":1,\"120\":1,\"137\":1,\"142\":2,\"189\":1}}],[\"cn\",{\"1\":{\"80\":2}}],[\"c\",{\"1\":{\"75\":1,\"90\":1,\"105\":1,\"120\":1,\"122\":2,\"136\":2,\"137\":1,\"142\":3,\"156\":13,\"185\":7,\"188\":3,\"189\":3,\"214\":2}}],[\"cancel\",{\"1\":{\"194\":2,\"195\":2,\"196\":2,\"197\":2}}],[\"cancelled\",{\"1\":{\"194\":1,\"197\":1}}],[\"cap\",{\"1\":{\"68\":1}}],[\"case\",{\"1\":{\"9\":1,\"120\":14,\"123\":12,\"181\":2,\"188\":2,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"226\":2,\"227\":5,\"229\":2,\"230\":3,\"231\":1,\"232\":1}}],[\"current\",{\"1\":{\"47\":1}}],[\"ch2\",{\"1\":{\"123\":7,\"181\":3,\"227\":2,\"229\":4}}],[\"ch1\",{\"1\":{\"123\":6,\"181\":3,\"227\":2,\"229\":4}}],[\"ch\",{\"1\":{\"122\":6,\"160\":6,\"170\":7,\"174\":1,\"175\":2,\"177\":3,\"178\":3,\"179\":2,\"180\":8,\"203\":1,\"204\":2,\"205\":1,\"206\":8,\"230\":3,\"231\":2}}],[\"chdir\",{\"1\":{\"47\":2}}],[\"character\",{\"1\":{\"122\":1}}],[\"char\",{\"1\":{\"122\":2}}],[\"charlie\",{\"1\":{\"25\":1,\"50\":1,\"52\":1,\"149\":1}}],[\"chan<\",{\"1\":{\"184\":1,\"185\":1,\"189\":1}}],[\"changeperson\",{\"1\":{\"151\":4}}],[\"changeslicelength\",{\"1\":{\"68\":4}}],[\"changeslicevalue\",{\"1\":{\"68\":2}}],[\"chan\",{\"1\":{\"9\":1,\"122\":1,\"123\":2,\"155\":1,\"160\":2,\"170\":2,\"174\":1,\"177\":1,\"178\":1,\"180\":2,\"181\":2,\"184\":3,\"185\":6,\"186\":2,\"187\":8,\"188\":2,\"189\":2,\"203\":1,\"205\":1,\"206\":2,\"222\":2,\"229\":2,\"230\":1,\"231\":1,\"237\":2,\"238\":2}}],[\"channels\",{\"0\":{\"222\":1},\"1\":{\"76\":2,\"166\":1,\"185\":2}}],[\"channel\",{\"0\":{\"172\":1},\"1\":{\"9\":9,\"122\":2,\"123\":1,\"155\":2,\"160\":2,\"172\":1,\"188\":2,\"199\":1,\"202\":1}}],[\"channeltype\",{\"1\":{\"9\":1,\"160\":2}}],[\"chans\",{\"1\":{\"9\":2}}],[\"csv\",{\"1\":{\"17\":2}}],[\"coroutine\",{\"0\":{\"211\":1}}],[\"collection\",{\"1\":{\"121\":1}}],[\"count++\",{\"1\":{\"121\":1,\"167\":1,\"168\":1,\"219\":1,\"220\":1,\"235\":1}}],[\"count\",{\"1\":{\"121\":6,\"167\":4,\"168\":4,\"169\":4,\"170\":4,\"219\":3,\"220\":4,\"221\":4,\"235\":3,\"240\":4}}],[\"could\",{\"1\":{\"9\":1}}],[\"community\",{\"0\":{\"243\":1}}],[\"communication\",{\"1\":{\"123\":1}}],[\"communicationcase2\",{\"1\":{\"123\":1}}],[\"communicationcase1\",{\"1\":{\"123\":2}}],[\"complex128\",{\"1\":{\"159\":1}}],[\"complex64\",{\"1\":{\"159\":1}}],[\"comparable\",{\"1\":{\"107\":4,\"108\":1}}],[\"com\",{\"1\":{\"82\":1,\"83\":1,\"89\":1,\"162\":1}}],[\"coder\",{\"1\":{\"150\":4,\"151\":3}}],[\"codermast\",{\"1\":{\"135\":1,\"160\":1,\"161\":2,\"162\":1}}],[\"code\",{\"1\":{\"46\":1,\"82\":1}}],[\"copy\",{\"1\":{\"9\":1,\"16\":1}}],[\"cond\",{\"1\":{\"236\":3}}],[\"condition2\",{\"1\":{\"119\":3}}],[\"condition1\",{\"1\":{\"119\":3}}],[\"condition\",{\"0\":{\"167\":1,\"236\":1},\"1\":{\"119\":5,\"121\":4,\"164\":1,\"236\":1}}],[\"consumer\",{\"0\":{\"189\":1},\"1\":{\"189\":3}}],[\"const\",{\"1\":{\"162\":4,\"163\":2,\"184\":2,\"237\":1}}],[\"concurrency\",{\"0\":{\"165\":1},\"1\":{\"164\":1}}],[\"converted\",{\"1\":{\"54\":4,\"55\":4,\"56\":2}}],[\"control\",{\"1\":{\"234\":1}}],[\"contents\",{\"1\":{\"23\":1,\"25\":2,\"27\":1}}],[\"context\",{\"0\":{\"190\":1},\"1\":{\"15\":1,\"190\":2,\"192\":3,\"193\":3,\"194\":6,\"195\":6,\"196\":6,\"197\":14,\"198\":2}}],[\"container\",{\"0\":{\"21\":1},\"1\":{\"14\":1,\"21\":2,\"22\":1,\"23\":2,\"24\":2,\"25\":3,\"26\":1,\"27\":3,\"28\":1}}],[\"continue\",{\"1\":{\"9\":2}}],[\"conn\",{\"1\":{\"9\":5}}],[\"connection\",{\"1\":{\"9\":3}}],[\"config\",{\"1\":{\"8\":2,\"9\":5}}],[\"clear\",{\"1\":{\"67\":2}}],[\"closer\",{\"1\":{\"117\":2}}],[\"close\",{\"1\":{\"8\":1,\"9\":2,\"44\":2,\"117\":1,\"122\":1,\"155\":1,\"170\":1,\"173\":1,\"179\":1,\"180\":1,\"184\":2,\"185\":2,\"186\":1,\"187\":3,\"189\":1,\"206\":1}}],[\"clientversion\",{\"1\":{\"9\":1}}],[\"client\",{\"1\":{\"8\":2}}],[\"clientconfig\",{\"1\":{\"8\":1}}],[\"create\",{\"1\":{\"8\":1,\"44\":2}}],[\"crypto\",{\"0\":{\"4\":1},\"1\":{\"5\":1,\"6\":2,\"8\":1,\"9\":1,\"11\":1,\"18\":1}}],[\"o\",{\"1\":{\"211\":1,\"212\":2}}],[\"out\",{\"0\":{\"186\":1},\"1\":{\"185\":4,\"187\":12,\"195\":1,\"197\":1}}],[\"output\",{\"1\":{\"99\":1,\"185\":2}}],[\"operations\",{\"0\":{\"240\":1},\"1\":{\"166\":1}}],[\"operator\",{\"1\":{\"160\":4}}],[\"open\",{\"1\":{\"13\":1,\"44\":2,\"86\":2}}],[\"optimizedstruct\",{\"1\":{\"156\":5}}],[\"omitempty\",{\"1\":{\"152\":2,\"153\":2}}],[\"ok\",{\"1\":{\"116\":2,\"127\":2,\"179\":2,\"197\":4}}],[\"object\",{\"1\":{\"115\":1}}],[\"or\",{\"1\":{\"197\":1}}],[\"orm\",{\"1\":{\"154\":1}}],[\"orresult\",{\"1\":{\"132\":1,\"133\":1}}],[\"order\",{\"0\":{\"48\":1}}],[\"org\",{\"0\":{\"4\":1},\"1\":{\"5\":1,\"6\":2,\"8\":1,\"9\":1,\"11\":1}}],[\"offsetof\",{\"1\":{\"156\":6}}],[\"offset\",{\"1\":{\"156\":12}}],[\"of\",{\"1\":{\"33\":1,\"120\":1,\"156\":16}}],[\"oldpath\",{\"1\":{\"44\":1}}],[\"old\",{\"1\":{\"24\":4,\"126\":1,\"127\":1}}],[\"one\",{\"1\":{\"108\":2}}],[\"on\",{\"1\":{\"9\":1}}],[\"os\",{\"0\":{\"43\":1},\"1\":{\"8\":3,\"9\":1,\"13\":3,\"33\":6,\"43\":2,\"44\":7,\"45\":2,\"46\":3,\"47\":4,\"86\":1}}],[\"客户端和服务器实现\",{\"1\":{\"16\":1}}],[\"客户端和服务器的包\",{\"1\":{\"5\":1}}],[\"客户端示例\",{\"1\":{\"8\":1}}],[\"客户端\",{\"0\":{\"8\":1}}],[\"generator\",{\"1\":{\"185\":4,\"187\":2,\"188\":3}}],[\"getvalue\",{\"1\":{\"120\":1}}],[\"getwd\",{\"1\":{\"47\":2}}],[\"getppid\",{\"1\":{\"46\":2}}],[\"getpid\",{\"1\":{\"46\":2}}],[\"getenv\",{\"1\":{\"13\":1,\"45\":2}}],[\"get\",{\"1\":{\"6\":2,\"16\":1,\"102\":1,\"106\":3}}],[\"gin\",{\"1\":{\"77\":1}}],[\"github\",{\"1\":{\"11\":1,\"89\":1}}],[\"griesemer\",{\"1\":{\"75\":1}}],[\"guest\",{\"1\":{\"30\":1,\"31\":2,\"33\":1}}],[\"gorm\",{\"1\":{\"154\":3}}],[\"goroot\",{\"1\":{\"83\":1}}],[\"goroutine可能会暂时阻塞在发送或接收操作上\",{\"1\":{\"173\":1}}],[\"goroutines\",{\"0\":{\"207\":1},\"1\":{\"76\":2,\"180\":1,\"182\":2,\"207\":4}}],[\"goroutine\",{\"0\":{\"199\":1,\"200\":1,\"201\":1},\"1\":{\"15\":1,\"123\":1,\"127\":1,\"155\":2,\"160\":2,\"165\":1,\"166\":3,\"167\":4,\"168\":1,\"170\":2,\"171\":2,\"172\":1,\"181\":1,\"184\":3,\"185\":1,\"186\":2,\"187\":2,\"189\":2,\"190\":1,\"198\":1,\"199\":4,\"200\":2,\"201\":4,\"205\":1,\"206\":1,\"207\":1,\"213\":1,\"214\":1,\"219\":1,\"220\":1,\"222\":1,\"223\":5,\"224\":1,\"226\":1,\"229\":1,\"235\":4,\"236\":3,\"237\":2,\"238\":1,\"239\":4,\"240\":3}}],[\"go语言可以更灵活地处理各种数据类型\",{\"1\":{\"110\":1}}],[\"go语言在1\",{\"1\":{\"103\":1}}],[\"go语言的错误处理机制非常简单且灵活\",{\"1\":{\"89\":1}}],[\"go语言通过\",{\"1\":{\"89\":1}}],[\"go语言通过内置的\",{\"1\":{\"84\":1}}],[\"go语言中\",{\"1\":{\"136\":1}}],[\"go语言中最基本的输出函数是\",{\"1\":{\"36\":1}}],[\"go语言中的切片是一个动态数组\",{\"1\":{\"22\":1}}],[\"gomoduls\",{\"1\":{\"83\":1}}],[\"gopath\",{\"1\":{\"83\":1}}],[\"goland\",{\"0\":{\"83\":1},\"1\":{\"81\":1,\"83\":6}}],[\"golangnotes\",{\"1\":{\"161\":1,\"162\":1}}],[\"golang环境\",{\"0\":{\"80\":1}}],[\"golang\",{\"0\":{\"0\":1,\"4\":1,\"74\":1},\"1\":{\"5\":1,\"6\":2,\"8\":1,\"9\":1,\"11\":1,\"22\":1,\"58\":2,\"61\":1,\"75\":2,\"76\":6,\"77\":5,\"78\":3,\"79\":2,\"80\":2,\"82\":1,\"83\":3,\"90\":3,\"101\":5,\"102\":3,\"111\":2,\"113\":1,\"121\":2,\"125\":1,\"137\":3,\"138\":1,\"142\":1,\"147\":2,\"148\":1,\"149\":4,\"150\":6,\"151\":6,\"152\":1,\"155\":2,\"156\":1,\"158\":1,\"160\":1,\"161\":3,\"162\":1,\"163\":2}}],[\"google\",{\"1\":{\"75\":1,\"80\":2}}],[\"go\",{\"0\":{\"214\":1},\"1\":{\"5\":1,\"6\":2,\"9\":4,\"12\":3,\"20\":2,\"30\":2,\"35\":1,\"37\":1,\"48\":1,\"51\":1,\"52\":1,\"53\":1,\"67\":1,\"69\":1,\"75\":1,\"80\":1,\"83\":2,\"102\":1,\"120\":1,\"121\":4,\"122\":1,\"123\":6,\"124\":1,\"127\":1,\"128\":1,\"142\":1,\"155\":1,\"156\":2,\"159\":1,\"160\":1,\"161\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":3,\"177\":1,\"180\":1,\"181\":2,\"182\":1,\"183\":1,\"184\":1,\"185\":4,\"186\":1,\"187\":3,\"188\":1,\"189\":2,\"190\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":5,\"200\":2,\"201\":1,\"202\":2,\"206\":1,\"207\":1,\"213\":1,\"214\":1,\"217\":1,\"218\":1,\"219\":1,\"220\":2,\"221\":1,\"222\":2,\"223\":3,\"224\":1,\"226\":1,\"229\":2,\"230\":1,\"233\":1,\"235\":2,\"236\":2,\"237\":2,\"238\":2,\"239\":2,\"240\":2}}],[\"您可以使用\",{\"1\":{\"6\":1}}],[\"连接的所有必要功能\",{\"1\":{\"5\":1}}],[\"语句构建复杂的并发逻辑\",{\"1\":{\"233\":1}}],[\"语句阻塞\",{\"1\":{\"232\":1}}],[\"语句中包含了一个超时机制\",{\"1\":{\"230\":1}}],[\"语句中初始化一个变量\",{\"1\":{\"120\":1}}],[\"语句能够处理哪个通道先接收到数据\",{\"1\":{\"229\":1}}],[\"语句的注意事项\",{\"0\":{\"232\":1}}],[\"语句的\",{\"1\":{\"231\":1}}],[\"语句的示例\",{\"1\":{\"228\":1}}],[\"语句的基本用法\",{\"0\":{\"227\":1}}],[\"语句的具体用法\",{\"1\":{\"119\":1}}],[\"语句会阻塞\",{\"1\":{\"226\":1}}],[\"语句会等待并接收来自\",{\"1\":{\"123\":1}}],[\"语句从多个通道中选择可用的通道进行处理\",{\"1\":{\"188\":1}}],[\"语句从多个通道接收数据\",{\"1\":{\"181\":1}}],[\"语句使得一个\",{\"1\":{\"181\":1}}],[\"语句是处理并发任务时非常有用的工具\",{\"1\":{\"226\":1}}],[\"语句是一种控制结构\",{\"1\":{\"226\":1}}],[\"语句是\",{\"1\":{\"123\":1}}],[\"语句是编程语言中最为基础也是最重要的一个逻辑控制语句\",{\"1\":{\"119\":1}}],[\"语句类似于\",{\"1\":{\"123\":1}}],[\"语句在每次执行时\",{\"1\":{\"123\":1}}],[\"语句在\",{\"1\":{\"123\":1}}],[\"语句在匹配到某个\",{\"1\":{\"120\":1}}],[\"语句用于处理并发操作\",{\"1\":{\"123\":1}}],[\"语句用于进行多分支条件判断\",{\"1\":{\"120\":1}}],[\"语句还可以用于类型断言\",{\"1\":{\"120\":1}}],[\"语句可以正常接收到数据\",{\"1\":{\"232\":1}}],[\"语句可以和\",{\"1\":{\"123\":1}}],[\"语句可以嵌套使用\",{\"1\":{\"119\":1}}],[\"语句可以延迟函数或方法的执行直到封闭函数返回\",{\"1\":{\"99\":1}}],[\"语句\",{\"0\":{\"119\":1,\"120\":1,\"121\":1,\"123\":1,\"181\":1,\"226\":1},\"1\":{\"119\":3,\"120\":2,\"121\":1,\"123\":1,\"181\":1,\"233\":1}}],[\"语法如下\",{\"1\":{\"150\":1}}],[\"语法简化的目的是为了在保证语义唯一的情况下尽可能简化\",{\"1\":{\"149\":1}}],[\"语法表示\",{\"1\":{\"37\":1}}],[\"语法核心\",{\"0\":{\"2\":1}}],[\"语言提供的一种类型安全的通信机制\",{\"1\":{\"202\":1}}],[\"语言提供的一种轻量级线程\",{\"1\":{\"199\":1}}],[\"语言提供了强大且简洁的排序功能\",{\"1\":{\"52\":1}}],[\"语言特有的用于在\",{\"1\":{\"166\":1}}],[\"语言\",{\"1\":{\"75\":2}}],[\"语言中的原子操作\",{\"1\":{\"240\":1}}],[\"语言中的互斥锁和读写锁使用示例\",{\"1\":{\"235\":1}}],[\"语言中没有直接的栅栏实现\",{\"1\":{\"239\":1}}],[\"语言中没有直接的信号量实现\",{\"1\":{\"237\":1}}],[\"语言中可以使用通道来实现事件机制\",{\"1\":{\"238\":1}}],[\"语言中可以直接进行指针的运算\",{\"1\":{\"142\":1}}],[\"语言中使用条件变量\",{\"1\":{\"236\":1}}],[\"语言中强大且灵活的并发编程工具\",{\"1\":{\"182\":1}}],[\"语言中不允许将布尔值类型强制转换为整型\",{\"1\":{\"159\":1}}],[\"语言中处理并发编程的重要工具之一\",{\"1\":{\"123\":1}}],[\"语言中\",{\"1\":{\"48\":1,\"53\":1,\"69\":1,\"123\":1,\"124\":1,\"160\":1,\"190\":1,\"198\":1,\"226\":1}}],[\"语言开发的效率和质量\",{\"1\":{\"20\":1}}],[\"语言标准库是\",{\"1\":{\"12\":1}}],[\"语言的内存模型定义了对共享变量的访问顺序规则\",{\"1\":{\"213\":1}}],[\"语言的内存安全检查\",{\"1\":{\"142\":1}}],[\"语言的示例代码来介绍它们的应用\",{\"1\":{\"183\":1}}],[\"语言的排序函数是稳定的\",{\"1\":{\"51\":1}}],[\"语言的标准库中\",{\"1\":{\"35\":1}}],[\"语言的标准库提供了丰富的功能模块\",{\"1\":{\"20\":1}}],[\"语言的\",{\"1\":{\"5\":1}}],[\"xorresult\",{\"1\":{\"133\":1}}],[\"xml映射等\",{\"1\":{\"152\":1}}],[\"xml\",{\"1\":{\"17\":2}}],[\"x\",{\"0\":{\"4\":1},\"1\":{\"5\":1,\"6\":2,\"8\":1,\"9\":1,\"11\":1,\"24\":2,\"93\":5,\"96\":2,\"98\":2,\"100\":2,\"101\":34,\"120\":10,\"141\":8}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
